<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DanaCoding</title>
    <link>https://danacoding.github.io/</link>
    <description>Recent content on DanaCoding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <copyright>&amp;copy;{year}, DanaCoding</copyright>
    <lastBuildDate>Sun, 26 Jan 2020 04:15:05 +0900</lastBuildDate>
    
        <atom:link href="https://danacoding.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>May 2019</title>
        <link>https://danacoding.github.io/updates/2019_may/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:51 +0900</pubDate>
        
        <guid>https://danacoding.github.io/updates/2019_may/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Basic Usage</title>
        <link>https://danacoding.github.io/docs/gettingstarted/basicusage/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:51 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/gettingstarted/basicusage/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>April 2019</title>
        <link>https://danacoding.github.io/updates/2019_april/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:48 +0900</pubDate>
        
        <guid>https://danacoding.github.io/updates/2019_april/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Configuration</title>
        <link>https://danacoding.github.io/docs/gettingstarted/configuration/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:56 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/gettingstarted/configuration/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>March 2019</title>
        <link>https://danacoding.github.io/updates/2019_march/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:42 +0900</pubDate>
        
        <guid>https://danacoding.github.io/updates/2019_march/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Installation</title>
        <link>https://danacoding.github.io/docs/gettingstarted/installation/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:13 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/gettingstarted/installation/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>February 2019</title>
        <link>https://danacoding.github.io/updates/2019_february/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:37 +0900</pubDate>
        
        <guid>https://danacoding.github.io/updates/2019_february/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Quick Start</title>
        <link>https://danacoding.github.io/docs/gettingstarted/quickstart/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:41 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/gettingstarted/quickstart/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>January 2019</title>
        <link>https://danacoding.github.io/updates/2019_january/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:09 +0900</pubDate>
        
        <guid>https://danacoding.github.io/updates/2019_january/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Array</title>
        <link>https://danacoding.github.io/jsts/array/array-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/array/array-bp/</guid>
        <description>一、四个必备的js数组方法 1. Array.prototype.map() 数组元素更新 创建一个新数组。结果是一个与原数组长度相同的数组，并根据提供的函数转换元素。 1 2 3 4 const arr = [1, 2, 3]; const</description>
      </item>
      
      <item>
        <title>Collect &amp; Ramda</title>
        <link>https://danacoding.github.io/jsts/cr/cr/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/cr/cr/</guid>
        <description>collect.js &amp;amp; ramda（ 处理数组和对象的好帮手 ） Step1. 安装 yarn add collect.js yarn add ramda Step2. 导入 import collect from &#39;collect.js&#39; import * as R from &#39;ramda&#39; Step3. （项目实例，用来渲染多屏，每屏里面有 8 张卡片） 使用 collect.js 示</description>
      </item>
      
      <item>
        <title>CORS 跨域资源共享</title>
        <link>https://danacoding.github.io/others/cors/cors/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/cors/cors/</guid>
        <description>CORS (跨域资源共享)，它是浏览器获取内容的方式的一部分。 一、没有 CORS 的跨域访问存在不安全问题 这不是我们的错，只能说这是WEB技术发展的历史问题 &amp;lt;script</description>
      </item>
      
      <item>
        <title>D3.js</title>
        <link>https://danacoding.github.io/dataview/d3-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/dataview/d3-base/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Docker</title>
        <link>https://danacoding.github.io/nodejs/docker/docker/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/docker/docker/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Expo 基础</title>
        <link>https://danacoding.github.io/react-native/expo/expo-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/expo/expo-base/</guid>
        <description>一、运行设备 Expo客户端App 浏览器 模拟器(使用genymotion) 下载并安装 Android Studio 3.0+ 在Android Studio中，转到首选项&amp;gt;外</description>
      </item>
      
      <item>
        <title>Fastify</title>
        <link>https://danacoding.github.io/nodejs/fastify/fastify/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/fastify/fastify/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Hapi</title>
        <link>https://danacoding.github.io/nodejs/hapi/hapi-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/hapi/hapi-base/</guid>
        <description>Hapi起初是给沃尔玛的“黑色星期五”开发的，是企业级的开发框架。 Express等开发框架的大部分功能都严重依赖中间件，中间件只是不良设计的</description>
      </item>
      
      <item>
        <title>Kali Linux</title>
        <link>https://danacoding.github.io/nodejs/kali/kali/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/kali/kali/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Nginx</title>
        <link>https://danacoding.github.io/nodejs/nginx/nginx/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/nginx/nginx/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Prisma ORM</title>
        <link>https://danacoding.github.io/nodejs/orm/prisma/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/orm/prisma/</guid>
        <description>Prisma Prisma 是一个开源的下一代 ORM。它由以下部分组成： Prisma 客户端：用于 Node.js 和 TypeScript 的自动生成和类型安全的查询构建器 Prisma Migrate : 迁移系统 Prisma Studio：用于查看和</description>
      </item>
      
      <item>
        <title>React &amp; Redux</title>
        <link>https://danacoding.github.io/react/redux/react-redux/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/redux/react-redux/</guid>
        <description>这两种技术的关键原则是什么? React 是提供数据的视图库，能以高效、可预测的方式渲染视图。 Redux 是状态管理框架，可用于简化 APP 应用状态的管理。 在 React Redux app 应用</description>
      </item>
      
      <item>
        <title>React 基础</title>
        <link>https://danacoding.github.io/react/react/react-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/react/react-base/</guid>
        <description>简介：React 是由 Facebook 创建和维护的开源视图库。 它是渲染现代 Web 应用程序用户界面（UI）的好工具。 一、JSX（JS 语法扩展） React 使用名为 JSX 的 JavaScript 语法</description>
      </item>
      
      <item>
        <title>React 最佳实践</title>
        <link>https://danacoding.github.io/react/react/react-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/react/react-bp/</guid>
        <description>React 是一个声明式、高效且灵活的 JavaScript 库 一、特性 虚拟 DOM：保存在内存中并通过 ReactDOM 等库与“真实”DOM 同步的 UI 表示。使用这种方法，只有实际更改的组件才</description>
      </item>
      
      <item>
        <title>React-Native 基础</title>
        <link>https://danacoding.github.io/react-native/react-native/rn-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/react-native/rn-base/</guid>
        <description>开发平台：Windows 目标平台：Android ReactNative 版本：0.62.2 一、安装依赖 Node (&amp;gt;=12) Python2 (Windows x86 MSI installer) Java SE Development Kit (JDK) (1.8 版本) 注意：要最新版本，要时常更新</description>
      </item>
      
      <item>
        <title>Redux</title>
        <link>https://danacoding.github.io/react/redux/redux-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/redux/redux-base/</guid>
        <description>Redux 是一个状态管理框架，可以与包括 React 在内的许多不同的 Web 技术一起使用。 在 Redux 中，有一个状态对象负责应用程序的整个状态， 这意味着如果你有一个包含十个</description>
      </item>
      
      <item>
        <title>Rust</title>
        <link>https://danacoding.github.io/rust/rust-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/rust/rust-base/</guid>
        <description>高级人体工程学和低级控制在编程语言设计中往往是不一致的；Rust 挑战了这种冲突。 一、安装 下载安装器，然后运行该程序并遵循屏幕上的指示。 二、获</description>
      </item>
      
      <item>
        <title>Ubuntu</title>
        <link>https://danacoding.github.io/nodejs/ubuntu/ubuntu/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/nodejs/ubuntu/ubuntu/</guid>
        <description></description>
      </item>
      
      <item>
        <title>UI-Kitten 基础</title>
        <link>https://danacoding.github.io/react-native/ui/ui-kitten/kitten-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/ui/ui-kitten/kitten-base/</guid>
        <description>一、安装 //确保已安装 React Native CLI npm un -g react-native-cli &amp;amp;&amp;amp; npm i -g @react-native-community/cli //用 Kitten 模板创建新项目 npx react-native init MyApp --template @ui-kitten/template-js //启动应用 yarn android 二、配置路由（配置应用程序在屏幕之间导航，基</description>
      </item>
      
      <item>
        <title>优化加载顺序</title>
        <link>https://danacoding.github.io/react-patterns/performance-patterns/loading-sequence/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/performance-patterns/loading-sequence/</guid>
        <description>注意：本文深受 Chrome 中 Aurora 团队的见解的影响，尤其是 Shubhie Panicker，他一直在研究最佳加载顺序。 在每个成功的网页加载中，一些关键组件和资源会在适当</description>
      </item>
      
      <item>
        <title>原型链和继承</title>
        <link>https://danacoding.github.io/jsts/prototype/prototype-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/prototype/prototype-bp/</guid>
        <description>一、关键字 对象 object：是数据的集合 原型继承 构造器 原型链 子类继承 JavaScript 中的（几乎）一切都是对象，除了原始值以外（number,string,</description>
      </item>
      
      <item>
        <title>在 JavaScript 中实现单例</title>
        <link>https://danacoding.github.io/jsts/function/single/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/single/</guid>
        <description>单例是一种面向对象的软件设计模式，它确保给定的类只被实例化一次。 比如，数据库连接。 Proxy Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自</description>
      </item>
      
      <item>
        <title>如何开发功能和解决问题</title>
        <link>https://danacoding.github.io/others/devmethod/devmethod/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/devmethod/devmethod/</guid>
        <description>一、收集需求 第一步也是最重要的一步是收集所有需求。 我们生活在一个非常复杂的世界中，不同背景的人可以帮助我们填补空白（自己的局限性）。 因此，应</description>
      </item>
      
      <item>
        <title>渲染模式介绍</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/render-patterns-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/render-patterns-base/</guid>
        <description>介绍 如今，可以通过多种方式在 Web 上呈现内容。 如何以及在何处获取和呈现内容的决定是应用程序性能的关键。 可用的框架和库可用于实现不同的渲染模式，如</description>
      </item>
      
      <item>
        <title>解构赋值</title>
        <link>https://danacoding.github.io/jsts/array/jiegou/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/array/jiegou/</guid>
        <description>1. 忽略值 1 2 3 const [apple, , banana] = [&amp;#39;apple&amp;#39;, &amp;#39;pear&amp;#39;, &amp;#39;banana&amp;#39;]; console.log(apple, banana); // apple banana 2. 分配剩余值 1 2 3 4 5 6 const [one, two, ...remainingNum] = [1, 2, 3, 4, 5]; console.log(remainingNum); // [3, 4, 5] const { apple, pear, ...remainFruits } = { apple:&amp;#39;apple&amp;#39;, pear:&amp;#39;pear&amp;#39;, banana:&amp;#39;banana&amp;#39;, cherry:&amp;#39;cherry&amp;#39; }; console.log(remainFruits); // { banana:&amp;#39;banana&amp;#39;, cherry:&amp;#39;cherry&amp;#39; } 3. 组合的</description>
      </item>
      
      <item>
        <title>设计模式介绍</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/design-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/design-patterns/</guid>
        <description>注意：菜单项目中（X）的都为过时或者不建议使用的模式，依然写出来只是为了让我们了解历史 设计模式是软件开发的基本部分， 因为它们为软件设计中经常</description>
      </item>
      
      <item>
        <title>Expo 最佳实践</title>
        <link>https://danacoding.github.io/react-native/expo/expo-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/expo/expo-bp/</guid>
        <description>一、创建项目 expo init MyProject 创建项目，选择托管工作流的TypeScript的空白模板，然后用 expo eject 退出到裸漏工作流。 之所以选择这种方式创建项目，是因为灵</description>
      </item>
      
      <item>
        <title>Hooks 最佳实践</title>
        <link>https://danacoding.github.io/react/hooks/hooks-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/hooks/hooks-bp/</guid>
        <description>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。 Hook 使</description>
      </item>
      
      <item>
        <title>React-Native 最佳实践</title>
        <link>https://danacoding.github.io/react-native/react-native/rn-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/react-native/rn-bp/</guid>
        <description>一、将.pk8 和.pem 转换成 react-native 的 debug.keystore Step1. 安装 openssl 参考：https://stackoverflow.com/questions/42918916/</description>
      </item>
      
      <item>
        <title>React.js 概述</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/overview-react/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/overview-react/</guid>
        <description>React 简介 多年来，对使用 JavaScript 编写用户界面的直接方法的需求不断增加。 React，也称为 React.js，是 Facebook 设计的开源 JavaScript 库，用于构建用户界面或 UI 组件</description>
      </item>
      
      <item>
        <title>UI-Kitten 最佳实践</title>
        <link>https://danacoding.github.io/react-native/ui/ui-kitten/kitten-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/ui/ui-kitten/kitten-bp/</guid>
        <description>一、DrawerGroup （UI-Kitten ） DrawerGroup 导航问题 xxx 这个问题没有解决 UI-Kitten Version@5.0.0 @ui-kitten/components DrawerGroup const DrawerContent = ({ navigation, state }) =&amp;gt; { const routes = [//1.定义对应的组件（组件名</description>
      </item>
      
      <item>
        <title>webpack 基础</title>
        <link>https://danacoding.github.io/others/webpack/webpack-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/webpack/webpack-base/</guid>
        <description>一、入口 （entry） #.单个入口（简写/数组）语法 用法：entry: string | [string] 优缺点：通过一个入口（例如一个库）为应用程序设置 webpack 配置时，单一入</description>
      </item>
      
      <item>
        <title>webpack 实践</title>
        <link>https://danacoding.github.io/others/webpack/webpack-adv/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/webpack/webpack-adv/</guid>
        <description>静态网站，多个html页面（非SPA），WebPack配置 (基础篇) Step1. 初始化项目 mkdir multiple-htmlpages &amp;amp;&amp;amp; cd multiple-htmlpages yarn init yarn add -D webpack webpack-cli webpack-dev-server html-webpack-plugin mkdir src &amp;amp;&amp;amp; cd src echo &amp;gt;index.html echo &amp;gt;index.js //index</description>
      </item>
      
      <item>
        <title>单例模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/single-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/single-patterns/</guid>
        <description>单例（统一用名词 Singleton 代替）是可以实例化一次的类，并且可以全局访问。单个实例可以在整个应用程序中共享，非常适合管理应用程序中的全局状态。 计数器案</description>
      </item>
      
      <item>
        <title>命令式 vs 函数式 vs 链式</title>
        <link>https://danacoding.github.io/jsts/function/for/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/for/</guid>
        <description>这里用 For 循环举例 命令式 1 2 3 4 5 6 7 8 9 10 11 12 13 const files = [&amp;#34;foo.txt &amp;#34;, &amp;#34;.bar&amp;#34;, &amp;#34; &amp;#34;, &amp;#34;baz.foo&amp;#34;]; let filePaths = []; for (let file of files) { const fileName = file.trim(); if (fileName) { const filePath = `~/cool_app/${fileName}`; filePaths.push(filePath); } } // filePaths = [ &amp;#39;~/cool_app/foo.txt&amp;#39;, &amp;#39;~/cool_app/.bar&amp;#39;, &amp;#39;~/cool_app/baz.foo&amp;#39;] 函数式 封装性</description>
      </item>
      
      <item>
        <title>字面量 vs 构造器 vs class</title>
        <link>https://danacoding.github.io/jsts/function/new/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/new/</guid>
        <description>Object 概述 Object 是 JavaScript 的一种 数据类型 。它用于存储各种键值集合和更复杂的实体。 Objects 可以通过 对象字面量、构造函数 或者 class 的方式创建 一、对象字面量 （{&amp;hell</description>
      </item>
      
      <item>
        <title>箭头函数 vs 常规函数</title>
        <link>https://danacoding.github.io/jsts/function/arrow/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/arrow/</guid>
        <description>JavaScript 的箭头函数从表面上看可能与常规函数相同，但它们有一些非常重要的区别： 关键区别 语法 this 值（执行上下文） 用作类方法 用作构造函数 arguments 参数绑定 #. 语法 1</description>
      </item>
      
      <item>
        <title>闭包、递归和回调</title>
        <link>https://danacoding.github.io/jsts/function/callback/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/callback/</guid>
        <description>闭包 涉及变量作用域 内部函数使用外部函数的变量 1 2 3 4 5 6 7 8 9 10 11 12 13 function outerFunc() { const outerVal = 100; function interFunc() { console.log(outerVal); } return interFunc; // 记得返回你的内部函数 } const inter = outerFunc(); inter(); //100 递归 自</description>
      </item>
      
      <item>
        <title>静态导入</title>
        <link>https://danacoding.github.io/react-patterns/performance-patterns/static-import/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/performance-patterns/static-import/</guid>
        <description>import 关键字允许导入由另一个模块导出的代码。 默认情况下，静态导入的所有模块都会添加到初始包中。 使用默认的 ES2015 导入语法 import module from &#39;module&#39; 导入的模块是静态导入的</description>
      </item>
      
      <item>
        <title>Git 最佳实践</title>
        <link>https://danacoding.github.io/others/git/git-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/git/git-bp/</guid>
        <description>一、OpenSSL SSL_connect git clone/git pull/git push 报错 fatal: unable to access &#39;https://github.com/xxx.git/&#39;: OpenSSL SSL_connect: Connection was reset in connection to github.com:443 解决办法：这个办法可以让git速度更快。 git config --global --add remote.origin.proxy &amp;quot;127.0.0.1:(proxy http port number)&amp;quot; //我的是 git config --global --add remote.origin.proxy &amp;quot;127.0.0.1:1080&amp;quot;</description>
      </item>
      
      <item>
        <title>Hooks &amp; Redux</title>
        <link>https://danacoding.github.io/react/redux/hooks-redux/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/redux/hooks-redux/</guid>
        <description>现在，有了 Hooks, 甚至可以自己编写 Reducer，通过 Proxy 对状态进行操作。 但是，为了更融入市场而且现在有了 Redux Tookit（可以减少很多代码量），所以</description>
      </item>
      
      <item>
        <title>Next.js 概述</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/overview-next/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/overview-next/</guid>
        <description>Next.js 简介 Next.js 由 Vercel 创建，是一个混合 React 应用程序的框架。 通常很难理解加载内容的所有不同方式。 Next.js 将其抽象化以使其尽可能简单。 该框架允许构建可扩展、高性能</description>
      </item>
      
      <item>
        <title>react-native-static-server</title>
        <link>https://danacoding.github.io/react-native/react-native/react-native-static-server/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/react-native/react-native-static-server/</guid>
        <description>搭建本地静态服务器和使用本地静态资源， 需要在expo弹出的裸漏工作流中 Step1. 配置android文件 /android/app/build.gradle 中添加 sourceSets { main { assets.srcDirs = [&#39;src/main/assets&#39;,&#39;../../assets&#39;]}} android { compileSdkVersion rootProject.ext.compileSdkVersion compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } defaultConfig</description>
      </item>
      
      <item>
        <title>React-Navigation</title>
        <link>https://danacoding.github.io/react-native/expo/react-navigation/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/expo/react-navigation/</guid>
        <description>一、goBack()返回上一屏幕刷新状态的方法 通过路由传递数据时，当向同一个页面（详情页）传递一些唯一数据，使用push，而不是 naviga</description>
      </item>
      
      <item>
        <title>zustand</title>
        <link>https://danacoding.github.io/react/zustand/zustand-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/zustand/zustand-base/</guid>
        <description>zustand 基于 hooks 的 api，小型、快速且可扩展的状态管理解决方案。 一、安装 yarn add zustand 二、最简使用方法 Step1. 创建一个 Store store 是一个钩子！ 可以在里面放任何东西：原始数</description>
      </item>
      
      <item>
        <title>代理模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/proxy-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/proxy-patterns/</guid>
        <description>使用 Proxy 对象，可以更好地控制与某些对象的交互。 每当与对象交互时，代理对象都可以确定行为，例如当我们获取一个值或设置一个值时。 一般来说，代理是指</description>
      </item>
      
      <item>
        <title>动态导入 ✔</title>
        <link>https://danacoding.github.io/react-patterns/performance-patterns/dynamic-import/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/performance-patterns/dynamic-import/</guid>
        <description>在聊天应用程序中，有四个主要部分：UserInfo，ChatList，ChatInput和EmojiPicker。 但是，在初始页面加载时，只</description>
      </item>
      
      <item>
        <title>错误处理，try{...}catch{...}</title>
        <link>https://danacoding.github.io/jsts/function/try-catch/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/try-catch/</guid>
        <description>try&amp;hellip;catch语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。 1 2 3 4 5 6 7 8 9 10 11 try { // 尝试运行这段代码 } catch(err) { //</description>
      </item>
      
      <item>
        <title>expo-video-player</title>
        <link>https://danacoding.github.io/react-native/expo/expo-video-player/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/expo/expo-video-player/</guid>
        <description>expo-video-player Step.1 安装 expo install expo-video-player expo install expo-av @react-native-community/netinfo @react-native-community/slider Step.2 使用 import { Video } from &#39;expo-av&#39; import VideoPlayer from &#39;expo-video-player&#39; &amp;lt;VideoPlayer videoProps={{ shouldPlay: true, resizeMode: Video.RESIZE_MODE_CONTAIN, source: { uri: &#39;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&#39;, }, }} inFullscreen={true} /&amp;gt; 视频列表解决思路 用图片作为列表 用model模态框作为全屏视频播</description>
      </item>
      
      <item>
        <title>IIS PHP</title>
        <link>https://danacoding.github.io/others/php/iisphp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/php/iisphp/</guid>
        <description>Windows Server 2012 R2 x64 IIS服务器 PHP环境搭建 阿里云服务器ECS Windows Server 2012 R2 64位中文标准版下手动搭建PHP环境。 IIS8.5 + MySQL5.6.15 + PHP5.5.19 + FastCGI + phpMyAdmin4.2.12 特别注意：服务器内存不</description>
      </item>
      
      <item>
        <title>Promise, async/await</title>
        <link>https://danacoding.github.io/jsts/function/promise/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/jsts/function/promise/</guid>
        <description>一、Promise 概述 Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。 #. Promise 有 3 个状态 待定（pending）: 初始状态，既没有被兑现</description>
      </item>
      
      <item>
        <title>Recoil 最佳实践</title>
        <link>https://danacoding.github.io/react/recoil/recoil-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/recoil/recoil-bp/</guid>
        <description>Recoil 是 React 官方 meta (facebook) 官方实验室的状态管理库，贴合 React hooks，自由度很高，所以要在项目中做一些规范，以便提供最佳的实践。 官方文档有对核心概念的解释</description>
      </item>
      
      <item>
        <title>客户端渲染</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/client-side-rendering/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/client-side-rendering/</guid>
        <description>在客户端呈现 (CSR) 中，服务器仅呈现页面的准系统 HTML 容器。 在页面上显示内容所需的逻辑、数据获取、模板和路由由在浏览器/客户端中执行的 JavaScript 代码处理。 CSR 作</description>
      </item>
      
      <item>
        <title>导入可见性 ✔</title>
        <link>https://danacoding.github.io/react-patterns/performance-patterns/import-on-visibility/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/performance-patterns/import-on-visibility/</guid>
        <description>除了用户交互，经常有在初始页面上不可见的组件。 一个很好的例子是延迟加载在视口中不直接可见的图像，但只有在用户向下滚动时才会加载。 由于不会立即</description>
      </item>
      
      <item>
        <title>提供者模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/provider-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/provider-pattern/</guid>
        <description>在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。 单向数据流 props 存在的问题 虽然我们可以使用 props 将数据传递给组件，但如果应</description>
      </item>
      
      <item>
        <title>Next.js 速览</title>
        <link>https://danacoding.github.io/react/next/next-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/next/next-base/</guid>
        <description>Next.js：React 框架 Next.js 提供生产所需的所有功能的最佳开发人员体验：混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取</description>
      </item>
      
      <item>
        <title>Remix 基础</title>
        <link>https://danacoding.github.io/react/remix/remix-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/remix/remix-base/</guid>
        <description>一、创建 Remix 应用 npx create-remix@latest yarn dev 二、创建文件路由 app/root.tsx Layout 组件中 &amp;lt;li&amp;gt; &amp;lt;Link to=&amp;quot;/posts&amp;quot;&amp;gt;Posts&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; 创建 app/routes/posts/index.tsx export default function Posts() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Posts&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; ) } 三、加载数据 Remix 的路由文件相当于后端的模板视图，也是控制</description>
      </item>
      
      <item>
        <title>Spritespin.js &amp; krpano </title>
        <link>https://danacoding.github.io/react-native/expo/spritespin-krpano/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-native/expo/spritespin-krpano/</guid>
        <description>Spritespin 图片排序 在用数字标志图片名称的时候，图片的旋转顺序应该为逆时针，这样在用鼠标拖拽的时候才能按照鼠标拖拽的方向旋转。 否则，图片旋转方向看起来</description>
      </item>
      
      <item>
        <title>Win &#43; Office</title>
        <link>https://danacoding.github.io/others/windows/win-office/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/windows/win-office/</guid>
        <description>操作系统 系统激活 Office激活 U盘系统安装：</description>
      </item>
      
      <item>
        <title>交互导入 ✔</title>
        <link>https://danacoding.github.io/react-patterns/performance-patterns/import-on-interaction/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/performance-patterns/import-on-interaction/</guid>
        <description>页面可能包含并非立即需要的组件或资源的代码或数据。 例如，用户不会看到部分用户界面，除非他们单击或滚动页面的某些部分。 这适用于编写的多种第一方</description>
      </item>
      
      <item>
        <title>原型模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/prototype-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/prototype-pattern/</guid>
        <description>原型模式是一种在许多相同类型的对象之间共享属性的有用方法。 原型prototype是 JavaScript 原生的对象，对象可以通过原型链__proto__访问。 在</description>
      </item>
      
      <item>
        <title>容器/展示模式（X）</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/presentational-container-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/presentational-container-pattern/</guid>
        <description>这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史 在 React 中，一种强制分离关注点的方法是通过使用容器/演示模式</description>
      </item>
      
      <item>
        <title>服务端渲染</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/server-side-rendering/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/server-side-rendering/</guid>
        <description>服务器端渲染 (SSR) 是最古老的 Web 内容渲染方法之一。 SSR 为要呈现的页面内容生成完整的 HTML，以响应用户请求。 内容可能包括来自数据存储或外部 API 的数据。</description>
      </item>
      
      <item>
        <title>Remix 进阶</title>
        <link>https://danacoding.github.io/react/remix/remix-adv/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/remix/remix-adv/</guid>
        <description>一、创建 Remix 项目 npx create-remix@latest yarn yarn dev 二、目录结构 app/ - 所有Remix应用程序代码的位置 app/entry.client.tsx- JavaScript 的第一部分，它将在应用程序在浏览器中加载时运行。我们使用此文件来</description>
      </item>
      
      <item>
        <title>yarn 最佳实践</title>
        <link>https://danacoding.github.io/others/yarn/yarn-bp/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/yarn/yarn-bp/</guid>
        <description>一、全局配置yarn Step1. 获取yarn的安装位置 yarn global bin Step2. 配置yarn全局变量</description>
      </item>
      
      <item>
        <title>观察者模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/observer-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/observer-pattern/</guid>
        <description>使用观察者模式，我们可以将某些对象（观察者）订阅到另一个称为 observable（可观察） 的对象。 每当一个事件发生时，observable 就</description>
      </item>
      
      <item>
        <title>静态生成</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/static-rendering/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/static-rendering/</guid>
        <description>根据我们对 SSR 的讨论，知道服务器上较长的请求处理时间会对 TTFB 产生负面影响。 类似地，对于 CSR，由于下载和处理脚本所花费的时间，大型 JavaScript 包可能对应用</description>
      </item>
      
      <item>
        <title>Babel</title>
        <link>https://danacoding.github.io/others/babel/babel-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/babel/babel-base/</guid>
        <description>Babel是Web Developer工具集中的出色条目。 这是一个了不起的工具，已经存在了一段时间，但是如今几乎每个JavaScript开发人</description>
      </item>
      
      <item>
        <title>Storybook 基础</title>
        <link>https://danacoding.github.io/react/storybook/sb-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react/storybook/sb-base/</guid>
        <description>一、安装配置 在next.js项目中执行 npx sb init yarn storybook .storybook/preview.js 为 Storybook 配置 Next.js Images + import * as NextImage from &amp;quot;next/image&amp;quot;; + const OriginalNextImage = NextImage.default; + Object.defineProperty(NextImage, &amp;quot;default&amp;quot;, { configurable: true, value: (props) =&amp;gt; ( &amp;lt;OriginalNextImage {...props} unoptimized /&amp;gt; ), }); package.json 为 Storybook 提供 Next.js 公共目录 {</description>
      </item>
      
      <item>
        <title>右键添加cmd和psl窗口命令</title>
        <link>https://danacoding.github.io/others/cmd/cmdpsl/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/others/cmd/cmdpsl/</guid>
        <description>直接新建txt，粘贴进去保存，然后选择另存为，保存类型选所有文件、编码选ANSI、文件名为CmdAndPowershellAll.reg(名</description>
      </item>
      
      <item>
        <title>增量静态生成 ✔</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/incremental-static-rendering/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/incremental-static-rendering/</guid>
        <description>静态生成 (SSG) 解决了 SSR 和 CSR 的大部分问题，但适用于渲染大部分静态内容。 当要呈现的内容是动态的或经常变化时，它会造成限制。 想想一个有多个帖子的不断增</description>
      </item>
      
      <item>
        <title>模块模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/module-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/module-pattern/</guid>
        <description>随着应用程序和代码库的增长，保持代码的可维护性和分离性变得越来越重要。 模块模式将代码拆分为更小的、可重用的部分。 除了能够将代码拆分为更小的可</description>
      </item>
      
      <item>
        <title>混合模式（X）</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/mixin-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/mixin-pattern/</guid>
        <description>mixin 是一个对象，可以使用它来向另一个对象或类添加可重用的功能，而无需使用继承。 不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象</description>
      </item>
      
      <item>
        <title>渐进补水 ✔</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/progressive-hydration/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/progressive-hydration/</guid>
        <description>简介 服务器呈现的应用程序使用服务器为当前导航生成 HTML。 一旦服务器完成生成 HTML 内容（其中还包含正确显示静态 UI 所需的 CSS 和 JSON 数据），它就会将数据</description>
      </item>
      
      <item>
        <title>中介者/中间件模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/mediator-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/mediator-pattern/</guid>
        <description>中介者模式使组件可以通过一个中心点相互交互：中介者（也称中介器或中间件）。 中介器不是直接相互交谈，而是接收请求，并将它们转发！ 在 JavaScript 中，中介者</description>
      </item>
      
      <item>
        <title>流(媒体)式服务器端渲染 ✔</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/streaming-ssr/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/streaming-ssr/</guid>
        <description>我们可以通过流式服务器渲染我们的应用程序的内容来减少服务器渲染我们的应用程序的时间。 我们可以将其拆分为更小的块，而不是生成包含当前导航所需标</description>
      </item>
      
      <item>
        <title>React 服务器组件 ✔</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/react-server-components/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/react-server-components/</guid>
        <description>React 团队正在研究零包大小的 React 服务器组件，旨在通过服务器驱动的思维模型实现现代 UX。 这与组件的服务器端渲染 (SSR) 完全不同，并且可能导致客户端 JavaScript 包显着</description>
      </item>
      
      <item>
        <title>render 道具模式（X）</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/render-props-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/render-props-pattern/</guid>
        <description>这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史 通过 props 道具将 JSX 元素传递给组件 在高阶组件部分，我们看到如果</description>
      </item>
      
      <item>
        <title>Hooks 模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/hooks-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/hooks-pattern/</guid>
        <description>React 16.8 引入了一个名为 Hooks 的新功能。 Hooks 使得使用 React 状态和生命周期方法成为可能，而无需使用 ES2015 类组件。 尽管 Hooks 不一定是一种设计模式，但 Hooks 在您的应用程序设计</description>
      </item>
      
      <item>
        <title>选择性水合作用 ✔</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/react-selective-hydration/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/react-selective-hydration/</guid>
        <description>在之前的文章中，我们介绍了 SSR 和 Hydration 如何改善用户体验。 React 能够（快速）使用 react-dom/server 库提供的 renderToString 方法在服务器上生成一棵树，该方法在整个树生成后发送到客户端。</description>
      </item>
      
      <item>
        <title>HOC 模式（X）</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/hoc-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/hoc-pattern/</guid>
        <description>这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史 在我们的应用程序中，我们经常希望在多个组件中使用相同的逻</description>
      </item>
      
      <item>
        <title>岛屿架构 ✔</title>
        <link>https://danacoding.github.io/react-patterns/render-patterns/islands-architecture/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/render-patterns/islands-architecture/</guid>
        <description>岛屿架构鼓励在服务器渲染的网页中进行小的、集中的交互块。 岛屿的输出是逐步增强的 HTML，在增强发生的方式上具有更多的特异性。 不是单个应用程序</description>
      </item>
      
      <item>
        <title>亨元模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/flyweight-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/flyweight-pattern/</guid>
        <description>当创建大量相似的对象时，享元模式是一种节省内存的有用方法。 图书馆案例 在应用程序中，我们希望用户能够添加书籍。 所有的书都有书名、作者和书号！ 但</description>
      </item>
      
      <item>
        <title>工厂模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/factory-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/factory-pattern/</guid>
        <description>使用工厂模式，我们可以使用工厂函数来创建新对象。 当一个函数在不使用 new 关键字的情况下返回一个新对象时，它就是一个工厂函数！ 用户案例 假设我们的应</description>
      </item>
      
      <item>
        <title>复合模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/compound-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/compound-pattern/</guid>
        <description>在应用程序中，经常有属于彼此的组件。 它们通过共享状态相互依赖，并共享逻辑。 经常会在选择、下拉组件或菜单项等组件中看到这一点。 复合组件模式允许</description>
      </item>
      
      <item>
        <title>命令模式</title>
        <link>https://danacoding.github.io/react-patterns/design-patterns/command-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/react-patterns/design-patterns/command-pattern/</guid>
        <description>使用命令模式，我们可以将执行特定任务的对象与调用该方法的对象解耦。 订单管理案例 假设我们有一个在线食品配送平台。 用户可以下订单、跟踪订单和取消</description>
      </item>
      
      <item>
        <title>Related content</title>
        <link>https://danacoding.github.io/docs/relatedcontent/</link>
        <pubDate>Tue, 28 Jan 2020 00:39:09 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/relatedcontent/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Page Resources</title>
        <link>https://danacoding.github.io/docs/pageresources/</link>
        <pubDate>Tue, 28 Jan 2020 00:39:06 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/pageresources/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Page Bundles</title>
        <link>https://danacoding.github.io/docs/pagebundles/</link>
        <pubDate>Tue, 28 Jan 2020 00:38:59 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/pagebundles/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Content Formats</title>
        <link>https://danacoding.github.io/docs/contentfortmats/</link>
        <pubDate>Tue, 28 Jan 2020 00:38:51 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/contentfortmats/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Image Processing</title>
        <link>https://danacoding.github.io/docs/imageprocessing/</link>
        <pubDate>Tue, 28 Jan 2020 00:38:48 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/imageprocessing/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Shortcodes</title>
        <link>https://danacoding.github.io/docs/contentmanagement/shortcodes/</link>
        <pubDate>Tue, 28 Jan 2020 00:36:19 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/contentmanagement/shortcodes/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Frontmatter</title>
        <link>https://danacoding.github.io/docs/contentmanagement/frontmatter/</link>
        <pubDate>Tue, 28 Jan 2020 00:36:14 +0900</pubDate>
        
        <guid>https://danacoding.github.io/docs/contentmanagement/frontmatter/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Markdown Syntax Guide</title>
        <link>https://danacoding.github.io/blog/markdown-syntax/</link>
        <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://danacoding.github.io/blog/markdown-syntax/</guid>
        <description>&lt;p&gt;Lorem est tota propiore conpellat pectoribus de&lt;br /&gt;
pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice&lt;br /&gt;
subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc&lt;br /&gt;
caluere tempus&lt;/p&gt;</description>
      </item>
      
      <item>
        <title>Section</title>
        <link>https://danacoding.github.io/docs/contentmanagement/sections/</link>
        <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://danacoding.github.io/docs/contentmanagement/sections/</guid>
        <description>&lt;p&gt;This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p&gt;</description>
      </item>
      
      <item>
        <title>Placeholder Text</title>
        <link>https://danacoding.github.io/blog/placeholder-text/</link>
        <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://danacoding.github.io/blog/placeholder-text/</guid>
        <description>&lt;p&gt;Lorem est tota propiore conpellat pectoribus de&lt;br /&gt;
pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice&lt;br /&gt;
subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc&lt;br /&gt;
caluere tempus&lt;/p&gt;</description>
      </item>
      
      <item>
        <title>Emoji Support</title>
        <link>https://danacoding.github.io/blog/emoji-support/</link>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://danacoding.github.io/blog/emoji-support/</guid>
        <description>&lt;p&gt;Lorem est tota propiore conpellat pectoribus de&lt;br /&gt;
pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice&lt;br /&gt;
subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc&lt;br /&gt;
caluere tempus&lt;/p&gt;</description>
      </item>
      
    
  </channel>
</rss>