<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Patterns 设计模式 on DanaCoding</title>
    <link>https://danacoding.github.io/patterns/design-patterns/</link>
    <description>Recent content in Design Patterns 设计模式 on DanaCoding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <copyright>&amp;copy;{year}, DanaCoding</copyright>
    <lastBuildDate>Tue, 28 Jan 2020 00:34:39 +0900</lastBuildDate>
    
        <atom:link href="https://danacoding.github.io/patterns/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>设计模式介绍</title>
        <link>https://danacoding.github.io/patterns/design-patterns/design-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/design-patterns/</guid>
        <description>设计模式是软件开发的基本部分， 因为它们为软件设计中经常出现的问题提供了典型的解决方案。 设计模式不是提供特定的软件部分，而是可以用来以优化的方</description>
      </item>
      
      <item>
        <title>单例模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/single-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/single-patterns/</guid>
        <description>单例（统一用名词 Singleton 代替）是可以实例化一次的类，并且可以全局访问。单个实例可以在整个应用程序中共享，非常适合管理应用程序中的全局状态。 ES6 中的单</description>
      </item>
      
      <item>
        <title>代理模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/proxy-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/proxy-patterns/</guid>
        <description>使用 Proxy 对象，可以更好地控制与某些对象的交互。 每当与对象交互时，代理对象都可以确定行为，例如当我们获取一个值或设置一个值时。 一般来说，代理是指</description>
      </item>
      
      <item>
        <title>提供者模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/provider-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/provider-pattern/</guid>
        <description>在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。 单向数据流 props 存在的问题 虽然我们可以使用 props 将数据传递给组件，但如果应</description>
      </item>
      
      <item>
        <title>原型模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/prototype-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/prototype-pattern/</guid>
        <description>原型模式是一种在许多相同类型的对象之间共享属性的有用方法。 原型prototype是 JavaScript 原生的对象，对象可以通过原型链__proto__访问。 在</description>
      </item>
      
      <item>
        <title>容器/展示模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/presentational-container-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/presentational-container-pattern/</guid>
        <description>在 React 中，一种强制分离关注点的方法是通过使用容器/演示模式。使用这种模式，我们可以将视图与应用程序逻辑分开。 在 React 中，强制分离关注点的一种方法是</description>
      </item>
      
      <item>
        <title>观察者模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/observer-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/observer-pattern/</guid>
        <description>使用观察者模式，我们可以将某些对象（观察者）订阅到另一个称为 observable（可观察） 的对象。 每当一个事件发生时，observable 就</description>
      </item>
      
      <item>
        <title>模块模式</title>
        <link>https://danacoding.github.io/patterns/design-patterns/module-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://danacoding.github.io/patterns/design-patterns/module-pattern/</guid>
        <description>随着应用程序和代码库的增长，保持代码的可维护性和分离性变得越来越重要。 模块模式将代码拆分为更小的、可重用的部分。 除了能够将代码拆分为更小的可</description>
      </item>
      
    
  </channel>
</rss>